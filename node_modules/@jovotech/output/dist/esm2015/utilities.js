import { Type } from 'class-transformer';
import _mergeWith from 'lodash.mergewith';
import _unset from 'lodash.unset';
import { IsOptional, ValidateNested } from '.';
import { NormalizedOutputTemplatePlatforms } from './models/NormalizedOutputTemplatePlatforms';
export function registerOutputPlatform(platformKey, platformType) {
    IsOptional()(NormalizedOutputTemplatePlatforms.prototype, platformKey);
    ValidateNested()(NormalizedOutputTemplatePlatforms.prototype, platformKey);
    Type(() => platformType)(NormalizedOutputTemplatePlatforms.prototype, platformKey);
}
export function formatValidationErrors(errors, options) {
    const errorMessages = [];
    // go through each validation error, add message for constraints, if children add children with updated path
    function handleValidationError(error, path = '') {
        var _a;
        path += error.property;
        if (error.constraints) {
            const values = Object.values(error.constraints);
            errorMessages.push(...values.map((text) => {
                return `${path.endsWith('.') ? path.slice(0, path.length - 1) : path}: ${text}`;
            }));
        }
        if ((_a = error.children) === null || _a === void 0 ? void 0 : _a.length) {
            for (let i = 0, len = error.children.length; i < len; i++) {
                handleValidationError(error.children[i], path + '.');
            }
        }
    }
    for (let i = 0, len = errors.length; i < len; i++) {
        handleValidationError(errors[i], (options === null || options === void 0 ? void 0 : options.path) ? `${options.path}.` : undefined);
    }
    const { text, delimiter } = Object.assign({ text: '', delimiter: '\n - ' }, (options || {}));
    return `${text}${delimiter}${errorMessages.join(delimiter)}`;
}
export function formatList(items, delimiter = ', ', lastDelimiter = ' or ') {
    if (items.length === 0) {
        return '';
    }
    if (items.length === 1) {
        return items[0].toString();
    }
    return `${items
        .slice(0, items.length - 1)
        .map((item) => item.toString())
        .join(delimiter)}${lastDelimiter}${items[items.length - 1].toString()}`;
}
export function isAnInstance(instance, ignoredConstructorNames = ['Object', 'Array']) {
    var _a;
    return (typeof instance === 'object' &&
        !!((_a = instance === null || instance === void 0 ? void 0 : instance.constructor) === null || _a === void 0 ? void 0 : _a.name) &&
        !ignoredConstructorNames.includes(instance.constructor.name));
}
export function instanceToObject(instance) {
    if (!isAnInstance(instance)) {
        return instance;
    }
    return Object.keys(instance).reduce((object, key) => {
        const value = instance[key];
        object[key] = isAnInstance(value) ? instanceToObject(value) : value;
        return object;
    }, {});
}
// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any
export function mergeInstances(destination, ...sources) {
    return _mergeWith(destination, ...sources.map((source) => instanceToObject(source)), 
    // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any
    (value, srcValue, key, object) => {
        if (Array.isArray(srcValue) && Array.isArray(value)) {
            return value.concat(srcValue);
        }
        if (typeof srcValue === 'undefined') {
            _unset(object, key);
        }
    });
}
export function mergeListen(target, mergeWith) {
    // if target is an object and not null and mergeWith is true, target should not be overwritten
    if (typeof target === 'object' && target && mergeWith === true) {
        return target;
    }
    // if mergeWith is not undefined, target should become mergeWith
    if (typeof mergeWith !== 'undefined') {
        // if mergeWith is an object and not null, just return a copy of mergeWith, otherwise return mergeWith
        return typeof mergeWith === 'object' && mergeWith ? Object.assign({}, mergeWith) : mergeWith;
    }
    // if mergeWith is undefined, just return target
    return target;
}
//# sourceMappingURL=utilities.js.map