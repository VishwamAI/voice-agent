var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { Type } from 'class-transformer';
import _mergeWith from 'lodash.mergewith';
import _unset from 'lodash.unset';
import { IsOptional, ValidateNested } from '.';
import { NormalizedOutputTemplatePlatforms } from './models/NormalizedOutputTemplatePlatforms';
export function registerOutputPlatform(platformKey, platformType) {
    IsOptional()(NormalizedOutputTemplatePlatforms.prototype, platformKey);
    ValidateNested()(NormalizedOutputTemplatePlatforms.prototype, platformKey);
    Type(function () { return platformType; })(NormalizedOutputTemplatePlatforms.prototype, platformKey);
}
export function formatValidationErrors(errors, options) {
    var errorMessages = [];
    // go through each validation error, add message for constraints, if children add children with updated path
    function handleValidationError(error, path) {
        var _a;
        if (path === void 0) { path = ''; }
        path += error.property;
        if (error.constraints) {
            var values = Object.values(error.constraints);
            errorMessages.push.apply(errorMessages, values.map(function (text) {
                return (path.endsWith('.') ? path.slice(0, path.length - 1) : path) + ": " + text;
            }));
        }
        if ((_a = error.children) === null || _a === void 0 ? void 0 : _a.length) {
            for (var i = 0, len = error.children.length; i < len; i++) {
                handleValidationError(error.children[i], path + '.');
            }
        }
    }
    for (var i = 0, len = errors.length; i < len; i++) {
        handleValidationError(errors[i], (options === null || options === void 0 ? void 0 : options.path) ? options.path + "." : undefined);
    }
    var _a = __assign({ text: '', delimiter: '\n - ' }, (options || {})), text = _a.text, delimiter = _a.delimiter;
    return "" + text + delimiter + errorMessages.join(delimiter);
}
export function formatList(items, delimiter, lastDelimiter) {
    if (delimiter === void 0) { delimiter = ', '; }
    if (lastDelimiter === void 0) { lastDelimiter = ' or '; }
    if (items.length === 0) {
        return '';
    }
    if (items.length === 1) {
        return items[0].toString();
    }
    return "" + items
        .slice(0, items.length - 1)
        .map(function (item) { return item.toString(); })
        .join(delimiter) + lastDelimiter + items[items.length - 1].toString();
}
export function isAnInstance(instance, ignoredConstructorNames) {
    var _a;
    if (ignoredConstructorNames === void 0) { ignoredConstructorNames = ['Object', 'Array']; }
    return (typeof instance === 'object' &&
        !!((_a = instance === null || instance === void 0 ? void 0 : instance.constructor) === null || _a === void 0 ? void 0 : _a.name) &&
        !ignoredConstructorNames.includes(instance.constructor.name));
}
export function instanceToObject(instance) {
    if (!isAnInstance(instance)) {
        return instance;
    }
    return Object.keys(instance).reduce(function (object, key) {
        var value = instance[key];
        object[key] = isAnInstance(value) ? instanceToObject(value) : value;
        return object;
    }, {});
}
// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any
export function mergeInstances(destination) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return _mergeWith.apply(void 0, __spreadArray(__spreadArray([destination], sources.map(function (source) { return instanceToObject(source); }), false), [
        // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any
        function (value, srcValue, key, object) {
            if (Array.isArray(srcValue) && Array.isArray(value)) {
                return value.concat(srcValue);
            }
            if (typeof srcValue === 'undefined') {
                _unset(object, key);
            }
        }], false));
}
export function mergeListen(target, mergeWith) {
    // if target is an object and not null and mergeWith is true, target should not be overwritten
    if (typeof target === 'object' && target && mergeWith === true) {
        return target;
    }
    // if mergeWith is not undefined, target should become mergeWith
    if (typeof mergeWith !== 'undefined') {
        // if mergeWith is an object and not null, just return a copy of mergeWith, otherwise return mergeWith
        return typeof mergeWith === 'object' && mergeWith ? __assign({}, mergeWith) : mergeWith;
    }
    // if mergeWith is undefined, just return target
    return target;
}
//# sourceMappingURL=utilities.js.map