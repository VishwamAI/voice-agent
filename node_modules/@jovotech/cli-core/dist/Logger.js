"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Log = exports.LogLevel = void 0;
const chalk_1 = __importDefault(require("chalk"));
const util_1 = require("util");
const _1 = require(".");
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["None"] = 0] = "None";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
    LogLevel[LogLevel["Raw"] = 4] = "Raw";
    LogLevel[LogLevel["Debug"] = 5] = "Debug";
    LogLevel[LogLevel["Verbose"] = 6] = "Verbose";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
class Log {
    static get level() {
        let logLevel = LogLevel.Error;
        if (process.env.JOVO_CLI_LOG_LEVEL) {
            logLevel = process.env.JOVO_CLI_LOG_LEVEL;
        }
        if (typeof logLevel === 'string') {
            logLevel = this.parseLogLevel(logLevel);
        }
        return logLevel;
    }
    /**
     * Parses the log level from string to the corresponding enum value
     */
    static parseLogLevel(level) {
        const logLevelCaps = level.toUpperCase();
        switch (logLevelCaps) {
            case 'NONE':
                return LogLevel.None;
            case 'INFO':
                return LogLevel.Info;
            case 'WARN':
                return LogLevel.Warn;
            case 'ERROR':
                return LogLevel.Error;
            case 'DEBUG':
                return LogLevel.Debug;
            case 'VERBOSE':
                return LogLevel.Verbose;
            default:
                return LogLevel.Error;
        }
    }
    /**
     * Checks, if the provided level applies to the current log level
     * @param logLevel - Log level to check for
     */
    static isLogLevel(logLevel) {
        return this.level >= logLevel;
    }
    /**
     * Checks if color output is currently supported or not.
     */
    static isRaw() {
        return (process.env.JOVO_CLI_COLOR === 'false' && !process.env.NO_COLOR && process.env.TERM === 'dumb');
    }
    /**
     * Log a output to a provided stream output
     * TODO: Log to file.
     */
    static log(output, options, stream = process.stdout) {
        if (!this.isLogLevel(options.logLevel)) {
            return undefined;
        }
        // Pretty print boolean values in orange
        if (typeof output === 'boolean') {
            output = chalk_1.default.hex('#ff8c00')(`${output}`);
        }
        if (typeof output === 'object') {
            output = util_1.inspect(output, { colors: true });
        }
        const formattedOutput = [`${output}`];
        if (options.indent) {
            formattedOutput.unshift(' '.repeat(options.indent));
            formattedOutput[formattedOutput.length - 1] = formattedOutput[formattedOutput.length - 1].replace(/\n/g, `\n${' '.repeat(options.indent)}`);
        }
        if (options.prefix) {
            formattedOutput.unshift(options.prefix, ' ');
            formattedOutput[formattedOutput.length - 1] = formattedOutput[formattedOutput.length - 1].replace(/\n/g, `\n${options.prefix} `);
        }
        if (options.newLine !== false) {
            formattedOutput.push('\n');
        }
        let outputString = formattedOutput.join('');
        if (this.isRaw()) {
            outputString = _1.getRawString(outputString);
        }
        if (options.dry) {
            return outputString;
        }
        stream.write(outputString, 'utf-8');
    }
    /**
     * Prints out an empty line
     */
    static spacer(symbol = ' ', repeat = 80, options) {
        return this.log(symbol.repeat(repeat), Object.assign({ logLevel: LogLevel.Info }, options));
    }
    static info(output, options) {
        return this.log(output, Object.assign({ logLevel: LogLevel.Info }, options));
    }
    static warning(output, options) {
        return this.log(output, Object.assign({ logLevel: LogLevel.Warn, prefix: _1.WARNING }, options), process.stderr);
    }
    static error(error, options) {
        return this.log(chalk_1.default.redBright(error), Object.assign({ logLevel: LogLevel.Error, prefix: _1.ERROR }, options), process.stderr);
    }
    static debug(output, options) {
        return this.log(output, Object.assign({ logLevel: LogLevel.Debug }, options));
    }
    static verbose(output, options) {
        return this.log(output, Object.assign({ logLevel: LogLevel.Verbose, prefix: chalk_1.default.bgMagenta.white('DEBUG') }, options));
    }
}
exports.Log = Log;
//# sourceMappingURL=Logger.js.map