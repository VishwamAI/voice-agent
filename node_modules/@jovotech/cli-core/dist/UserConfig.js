"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserConfig = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("fs");
const lodash_get_1 = __importDefault(require("lodash.get"));
const lodash_set_1 = __importDefault(require("lodash.set"));
const os_1 = require("os");
const path_1 = require("path");
const uuid_1 = require("uuid");
const _1 = require(".");
const constants_1 = require("./constants");
const JovoCliError_1 = require("./JovoCliError");
const prompts_1 = require("./prompts");
class UserConfig {
    constructor() {
        Object.assign(this, this.load());
        // If the loaded config has v3 structure,
        // rename configv4 to config and deprecate the v3 config
        if (!this.cli) {
            // Rename the v3 config to config3
            fs_1.renameSync(path_1.join(os_1.homedir(), UserConfig.getPath('v4')), path_1.join(os_1.homedir(), UserConfig.getPath('v3')));
            // If configv4 exists, rename it, otherwise create a fresh config with this.load()
            if (fs_1.existsSync(path_1.join(os_1.homedir(), '.jovo', 'configv4'))) {
                fs_1.renameSync(path_1.join(os_1.homedir(), '.jovo', 'configv4'), path_1.join(os_1.homedir(), UserConfig.getPath('v4')));
            }
            _1.Log.spacer();
            _1.Log.warning(`The Jovo CLI @v4 is now using ${UserConfig.getPath('v4')} as the default config.`);
            _1.Log.warning(`Your existing config has been moved to ${UserConfig.getPath('v3')}.`);
            _1.Log.spacer();
            // Reload config if v3 was loaded and detected
            Object.assign(this, this.load());
        }
        // Save a default template for users with the beta configv4 file,
        // since the default template previously had the key "Default_TS"
        if (!this.cli.presets.find((preset) => preset.name === 'default')) {
            this.savePreset(this.getDefaultPreset());
        }
        if (!this.cli.plugins.find((plugin) => plugin === '@jovotech/cli-command-update')) {
            this.cli.plugins.push('@jovotech/cli-command-update');
            this.save();
        }
    }
    static getInstance() {
        if (!this.instance) {
            this.instance = new UserConfig();
        }
        return this.instance;
    }
    /**
     * Returns the path of the Jovo user config.
     */
    static getPath(version = 'v4') {
        return version === 'v4' ? path_1.join('.jovo', 'config') : path_1.join('.jovo', 'config3');
    }
    /**
     * Loads and returns Jovo user config.
     */
    load() {
        try {
            const data = fs_1.readFileSync(path_1.join(os_1.homedir(), UserConfig.getPath()), 'utf-8');
            return JSON.parse(data);
        }
        catch (error) {
            // If file cannot be found, create it.
            if (error.code === 'ENOENT') {
                return this.create();
            }
            // Otherwise propagate error.
            throw new JovoCliError_1.JovoCliError({
                message: `Error while trying to parse ${UserConfig.getPath()}.`,
                details: error.message,
            });
        }
    }
    /**
     * Saves the provided user config.
     * @param config - JovoUserConfig object.
     */
    save(config = this) {
        if (!fs_1.existsSync(path_1.join(os_1.homedir(), '.jovo'))) {
            fs_1.mkdirSync(path_1.join(os_1.homedir(), '.jovo'));
        }
        fs_1.writeFileSync(path_1.join(os_1.homedir(), UserConfig.getPath()), JSON.stringify(config, null, 2));
        // Make sure the current instance is updated as well
        Object.assign(this, config);
    }
    /**
     * Creates and returns a new Jovo user config.
     */
    create() {
        const config = {
            webhook: {
                uuid: uuid_1.v4(),
            },
            cli: {
                plugins: [
                    '@jovotech/cli-command-build',
                    '@jovotech/cli-command-deploy',
                    '@jovotech/cli-command-get',
                    '@jovotech/cli-command-new',
                    '@jovotech/cli-command-run',
                    '@jovotech/cli-command-update',
                ],
                presets: [this.getDefaultPreset()],
            },
        };
        if (!fs_1.existsSync(path_1.join(os_1.homedir(), '.jovo'))) {
            fs_1.mkdirSync(path_1.join(os_1.homedir(), '.jovo'));
        }
        fs_1.writeFileSync(path_1.join(os_1.homedir(), UserConfig.getPath()), JSON.stringify(config, null, 2));
        return config;
    }
    getParameter(path) {
        return lodash_get_1.default(this, path);
    }
    setParameter(path, value) {
        lodash_set_1.default(this, path, value);
    }
    /**
     * Returns the webhook uuid for the current user from the Jovo user config.
     */
    getWebhookUuid() {
        return this.getParameter('webhook.uuid');
    }
    /**
     * Gets array of presets defined inside .jovo/config.
     */
    getPresets() {
        return this.getParameter('cli.presets');
    }
    /**
     * Gets a preset from .jovo/config.
     * @param presetKey - Key for the preset.
     * @throws JovoCliError, if the preset could not be found.
     */
    getPreset(presetKey) {
        const presets = this.getPresets();
        const preset = presets.find((preset) => preset.name === presetKey);
        if (!preset) {
            throw new JovoCliError_1.JovoCliError({
                message: `Could not find preset ${presetKey}.`,
                hint: 'Please check for spelling or check your .jovo/config.',
            });
        }
        return preset;
    }
    /**
     * Saves preset to .jovo/config.
     * @param preset - Preset to save.
     */
    async savePreset(preset) {
        // Check if preset already exists.
        if (this.cli.presets.find((p) => p.name === preset.name)) {
            const { overwrite } = await prompts_1.promptOverwrite(`Preset ${preset.name} already exists. Do you want to overwrite it?`);
            if (overwrite === constants_1.ANSWER_CANCEL) {
                throw new JovoCliError_1.JovoCliError({ message: `Preset ${chalk_1.default.bold(preset.name)} already exists.` });
            }
            else {
                // Remove existing preset.
                this.cli.presets = this.cli.presets.filter((p) => p.name !== preset.name);
            }
        }
        this.cli.presets.push(preset);
        this.save();
    }
    getDefaultPreset() {
        return {
            name: 'default',
            projectName: 'helloworld',
            locales: ['en'],
            platforms: [],
            language: 'typescript',
        };
    }
}
exports.UserConfig = UserConfig;
//# sourceMappingURL=UserConfig.js.map