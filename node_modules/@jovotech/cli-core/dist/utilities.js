"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isJovoCliError = exports.getLanguagePascalCase = exports.getResolvedLocales = exports.getRawString = exports.mergeArrayCustomizer = exports.checkForProjectDirectory = exports.getOutdatedPackages = exports.getPackageVersions = exports.getPackages = exports.deleteFolderRecursive = exports.wait = exports.execAsync = void 0;
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const latest_version_1 = __importDefault(require("latest-version"));
const lodash_get_1 = __importDefault(require("lodash.get"));
const lodash_intersectionby_1 = __importDefault(require("lodash.intersectionby"));
const path_1 = require("path");
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const JovoCliError_1 = require("./JovoCliError");
const Logger_1 = require("./Logger");
/**
 * Provides own version of execSync by returning a promise on exec().
 * This offers a few advantages, such as handling stream output more precise.
 * @param cmd - Command to execute, can be an array which will be joined with together with whitespaces
 * @param options - Options to pass to exec()
 */
function execAsync(cmd, options = {}) {
    return new Promise((resolve, reject) => {
        if (!Array.isArray(cmd)) {
            cmd = [cmd];
        }
        child_process_1.exec(cmd.join(' '), options, (error, stdout, stderr) => {
            if (error) {
                reject({ stderr: error.message, stdout });
            }
            else {
                // Reject only if stdout is empty.
                if (stderr && !stdout) {
                    reject({ stderr });
                }
                // Pass stderr to result for the case that some warning was passed into the error stream.
                resolve({ stderr, stdout });
            }
        });
    });
}
exports.execAsync = execAsync;
/**
 * Waits for the provided amount of time.
 * @param ms - Time to wait in ms.
 */
function wait(ms) {
    return new Promise((resolve) => {
        setTimeout(() => resolve(), ms);
    });
}
exports.wait = wait;
/**
 * Recursively deletes all files and folders within a directory.
 * @param path - Path to directory to delete.
 */
function deleteFolderRecursive(path) {
    if (fs_1.existsSync(path)) {
        for (const file of fs_1.readdirSync(path)) {
            const curPath = path_1.join(path, file);
            // If current path points to directory, delete recursively.
            if (fs_1.lstatSync(curPath).isDirectory()) {
                deleteFolderRecursive(curPath);
            }
            else {
                // Delete file.
                fs_1.unlinkSync(curPath);
            }
        }
        // Finally, delete empty directory.
        fs_1.rmdirSync(path);
    }
}
exports.deleteFolderRecursive = deleteFolderRecursive;
/**
 * Returns packages with their respective versions from project dependency files, comparing dependencies listed
 * in both package.json and package-lock.json.
 * @param packageRegex - RegExp to filter for packages
 * @param projectPath - Path for the current project
 */
function getPackages(packageRegex) {
    // Get all packages matching the regex from either package-lock.json, or package.json
    const packageFiles = ['package-lock.json', 'package.json'].filter((file) => fs_1.existsSync(file));
    if (!packageFiles.length) {
        throw new JovoCliError_1.JovoCliError({
            message: "Could not find an NPM dependency file, such as your project's package.json.",
            hint: 'Try creating one by running "npm init" inside your project.',
        });
    }
    const versionRegex = /^\^?\d{1,2}\.\d{1,2}\.\d{1,2}(?:-(?:alpha|beta).\d{1,2})?$/;
    const parseDependencyVersion = (dependencies, isDev) => {
        const packages = [];
        for (const [dependencyKey, dependency] of Object.entries(dependencies)) {
            if (!dependencyKey.match(packageRegex)) {
                continue;
            }
            if (typeof dependency === 'string') {
                if (dependency.match(versionRegex))
                    packages.push({
                        name: dependencyKey,
                        version: { local: dependency.replace('^', '') },
                        isDev,
                    });
            }
            else {
                if (dependency.version.match(versionRegex)) {
                    packages.push({
                        name: dependencyKey,
                        version: { local: dependency.version.replace('^', '') },
                        isDev,
                    });
                }
            }
        }
        return packages;
    };
    try {
        const packages = [];
        for (const packageFile of packageFiles) {
            const rawPackageFileContent = fs_1.readFileSync(packageFile, 'utf-8');
            const packageFileContent = JSON.parse(rawPackageFileContent);
            packages.push(...parseDependencyVersion(packageFileContent.dependencies || {}), ...parseDependencyVersion(packageFileContent.devDependencies || {}, true));
        }
        return lodash_intersectionby_1.default(packages, 'name');
    }
    catch (error) {
        console.log(error);
        throw new JovoCliError_1.JovoCliError({
            message: `Something went wrong while reading your file.`,
        });
    }
}
exports.getPackages = getPackages;
/**
 * Gets all packages from the project dependency file, matching packageRegex, with their
 * respective @latest version.
 * @param packageRegex - RegExp to filter for packages.
 */
async function getPackageVersions(packageRegex) {
    const packages = getPackages(packageRegex);
    const versionPromises = [];
    for (const pkg of packages) {
        versionPromises.push((async () => (Object.assign(Object.assign({}, pkg), { version: Object.assign(Object.assign({}, pkg.version), { npm: await latest_version_1.default(pkg.name) }) })))());
    }
    return await Promise.all(versionPromises);
}
exports.getPackageVersions = getPackageVersions;
async function getOutdatedPackages(packageRegex) {
    const packageVersions = await getPackageVersions(packageRegex);
    const outdatedPackages = [];
    for (const pkg of packageVersions) {
        if (pkg.version.local !== pkg.version.npm) {
            outdatedPackages.push(pkg);
        }
    }
    return outdatedPackages;
}
exports.getOutdatedPackages = getOutdatedPackages;
/**
 * Checks if the current working directory is a Jovo Project.
 */
function checkForProjectDirectory(isInProjectDirectory) {
    if (!isInProjectDirectory) {
        Logger_1.Log.spacer();
        Logger_1.Log.warning('To use this command, please go into the directory of a valid Jovo project.');
        Logger_1.Log.spacer();
        process.exit(126);
    }
}
exports.checkForProjectDirectory = checkForProjectDirectory;
/**
 * Customizer for _.mergeWith() to merge arrays instead of overwriting.
 * @param objValue - Array to merge into source.
 * @param srcValue - Source array.
 */
function mergeArrayCustomizer(target, source) {
    // Since _.merge simply overwrites the original array, concatenate them instead.
    if (Array.isArray(target) && Array.isArray(source)) {
        return target.concat(source);
    }
}
exports.mergeArrayCustomizer = mergeArrayCustomizer;
/**
 * Strips ANSI escape codes from the provided string.
 * @param output - String potentially containing ANSI escape codes to be stripped.
 */
function getRawString(output) {
    return strip_ansi_1.default(output);
}
exports.getRawString = getRawString;
/**
 * Returns platform-specific resolved locales. If no locale map is specified, returns [locale].
 * @param locale - Locale for which to return resolved locales.
 * @param supportedLocales - Array of supported locales, required to match glob patterns such as en-*.
 * @param localeMap - Optional locale map from the plugin configuration.
 */
function getResolvedLocales(locale, supportedLocales, localeMap) {
    const resolvedLocales = lodash_get_1.default(localeMap, locale);
    if (resolvedLocales) {
        if (!Array.isArray(resolvedLocales)) {
            throw new JovoCliError_1.JovoCliError({ message: `Locale ${locale} does not resolve to an array.` });
        }
        const globPattern = resolvedLocales.find((locale) => /[a-zA-Z]{2}-\*/.test(locale));
        if (globPattern) {
            const genericLocale = globPattern.replace('-*', '');
            return supportedLocales.filter((locale) => locale.includes(genericLocale));
        }
        return resolvedLocales;
    }
    return [locale];
}
exports.getResolvedLocales = getResolvedLocales;
/**
 * Converts the provided programming language to Pascal Case
 * @param lng - Programming language to convert
 */
function getLanguagePascalCase(lng) {
    switch (lng) {
        case 'typescript':
            return 'TypeScript';
        case 'javascript':
            return 'JavaScript';
        default:
            return '';
    }
}
exports.getLanguagePascalCase = getLanguagePascalCase;
/**
 * Checks whether the provided error is a JovoCliError.
 * Since the Jovo CLI uses both global and local modules, an error thrown in a local module
 * is not the same instance of a JovoCliError as in a global one.
 * @param error - Error to check
 */
function isJovoCliError(error) {
    return error instanceof JovoCliError_1.JovoCliError || !!error['properties'];
}
exports.isJovoCliError = isJovoCliError;
//# sourceMappingURL=utilities.js.map