"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Project = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const tv4_1 = __importDefault(require("tv4"));
const _1 = require(".");
const ProjectConfig_1 = require("./ProjectConfig");
const constants_1 = require("./constants");
const JovoCliError_1 = require("./JovoCliError");
class Project {
    constructor(projectPath) {
        this.projectPath = projectPath;
        // Look for --stage in process.argv.
        const stageIndex = process.argv.findIndex((el) => el === '--stage');
        // If a flag --stage has been set, set it to this.jovoStage. Otherwise intialize default stage.
        if (stageIndex > -1) {
            this.stage = process.argv[stageIndex + 1];
        }
        else {
            if (process.env.JOVO_STAGE) {
                this.stage = process.env.JOVO_STAGE;
            }
            else if (process.env.NODE_ENV) {
                this.stage = process.env.NODE_ENV;
            }
        }
        this.config = ProjectConfig_1.ProjectConfig.getInstance(this.projectPath, this.stage);
        // If stage was not explicitly defined, try to get it from config.
        if (!this.stage) {
            this.stage = this.config.getParameter('defaultStage');
        }
    }
    /**
     * Returns singleton project instance.
     * @param projectPath - Current project path.
     */
    static getInstance(projectPath) {
        if (!this.instance) {
            this.instance = new Project(projectPath);
        }
        return this.instance;
    }
    /**
     * Returns directory name for build folder
     */
    getBuildDirectory() {
        const buildDirectory = this.config.getParameter('buildDirectory') || 'build';
        // If a stage is provided, generate build files in a subfolder for that stage
        return path_1.join(buildDirectory, this.stage || '');
    }
    /**
     * Returns path to build folder
     */
    getBuildPath() {
        return path_1.join(this.projectPath, this.getBuildDirectory());
    }
    /**
     * Returns directory name for models folder.
     */
    getModelsDirectory() {
        return this.config.getParameter('models.directory') || 'models';
    }
    /**
     * Returns path to Jovo model files.
     */
    getModelsPath() {
        return path_1.join(this.projectPath, this.getModelsDirectory());
    }
    /**
     * Returns the path for a specific Jovo model.
     * @param locale - The locale under which the Jvoo model is stored.
     */
    getModelPath(locale) {
        return path_1.join(this.getModelsPath(), locale);
    }
    /**
     * Requires and returns Jovo model for the provided locale.
     * @param locale - Locale under which the Jovo model is stored.
     */
    async getModel(locale) {
        try {
            const path = this.getModelPath(locale);
            // Require model file, so it works with both .js and .json.
            const content = require(path);
            if (typeof content === 'function') {
                const builtContent = await content();
                return builtContent;
            }
            return content;
        }
        catch (error) {
            if (error.code === 'MODULE_NOT_FOUND') {
                throw new JovoCliError_1.JovoCliError({ message: `Could not find model file for locale: ${locale}` });
            }
            throw new JovoCliError_1.JovoCliError({ message: error.message });
        }
    }
    /**
     * Checks if model files for given locales exist
     * @param locales - Locales for which to check
     */
    hasModelFiles(locales) {
        if (!locales) {
            return false;
        }
        // If at least one model does not exist for a given locale, return false
        for (const locale of locales) {
            const path = this.getModelPath(locale);
            if (!fs_1.existsSync(`${path}.js`) && !fs_1.existsSync(`${path}.json`)) {
                return false;
            }
        }
        return true;
    }
    async validateModel(locale, model, validator, plugin) {
        if (!tv4_1.default.validate(model, validator)) {
            throw new JovoCliError_1.JovoCliError({
                message: `Validation failed for locale "${locale}"`,
                module: plugin,
                details: `${tv4_1.default.error.message} ${tv4_1.default.error.dataPath ? `at ${tv4_1.default.error.dataPath}` : ''}`,
            });
        }
    }
    /**
     * Backs up model file.
     * @param locale - Locale of the model file.
     */
    backupModel(locale) {
        if (!this.hasModelFiles([locale])) {
            throw new JovoCliError_1.JovoCliError({
                message: `Model file for locale ${locale} to backup could not be found.`,
            });
        }
        const todayDate = new Date();
        const todayString = todayDate.toISOString().substring(0, 10);
        const modelPath = this.getModelPath(locale);
        // Try to copy model file for either .json or .js.
        const fileExtensions = ['json', 'js'];
        for (const ext of fileExtensions) {
            const targetPath = `${modelPath}.${ext}`;
            if (!fs_1.existsSync(targetPath)) {
                continue;
            }
            const destinationFile = `${modelPath}.${todayString}.${ext}`;
            fs_1.copyFileSync(targetPath, destinationFile);
        }
    }
    /**
     * Saves model to file.
     * @param model - Model to save.
     * @param locale - Locale to save the model under.
     */
    saveModel(model, locale) {
        const modelsPath = this.getModelsPath();
        if (!fs_1.existsSync(modelsPath)) {
            fs_1.mkdirSync(modelsPath);
        }
        const modelFilePath = `${this.getModelPath(locale)}.json`;
        fs_1.writeFileSync(modelFilePath, JSON.stringify(model, null, 2));
    }
    /**
     * Returns project locales from Jovo models folder.
     */
    getLocales() {
        if (!fs_1.existsSync(this.getModelsPath())) {
            return [constants_1.DEFAULT_LOCALE];
        }
        const files = fs_1.readdirSync(this.getModelsPath());
        // If models folder doesn't contain any files, return default locale.
        if (!files.length) {
            return [constants_1.DEFAULT_LOCALE];
        }
        // RegExp to match all locale files in format of en.json or en-US.json.
        const localeRegex = /^([a-z]{2}(?:-?(?:[A-Z]{2})?)).(?:json|js)$/m;
        return files.reduce((locales, file) => {
            const match = localeRegex.exec(file);
            if (match) {
                locales.push(match[1]);
            }
            return locales;
        }, []);
    }
    /**
     * Returns project name extracted from project path.
     */
    getProjectName() {
        return this.projectPath.split(path_1.sep).pop();
    }
    /**
     * Returns true, if project has a platform folder in build path.
     * @param platformDir - The platform to look up inside the build folder.
     */
    hasPlatform(platformDir) {
        return fs_1.existsSync(path_1.join(this.getBuildPath(), platformDir));
    }
    /**
     * Checks if the project is a typescript project.
     */
    isTypeScriptProject() {
        const packagePath = path_1.join(this.projectPath, 'package.json');
        const content = fs_1.readFileSync(packagePath).toString();
        const packageFile = JSON.parse(content);
        return (packageFile.hasOwnProperty('devDependencies') &&
            packageFile.devDependencies.hasOwnProperty('typescript'));
    }
    collectPlugins() {
        _1.Log.verbose('Loading project-scoped CLI plugins');
        const plugins = [];
        const projectPlugins = this.config.getParameter('plugins') || [];
        for (const plugin of projectPlugins) {
            plugins.push(plugin);
        }
        return plugins;
    }
}
exports.Project = Project;
//# sourceMappingURL=Project.js.map