"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectConfig = void 0;
const lodash_get_1 = __importDefault(require("lodash.get"));
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const lodash_mergewith_1 = __importDefault(require("lodash.mergewith"));
const path_1 = require("path");
const JovoCliError_1 = require("./JovoCliError");
const Logger_1 = require("./Logger");
const utilities_1 = require("./utilities");
class ProjectConfig {
    constructor(configOrPath, stage) {
        if (typeof configOrPath === 'object') {
            Object.assign(this, configOrPath);
        }
        else {
            const configContent = this.loadContent(configOrPath);
            if (!stage) {
                stage = lodash_get_1.default(configContent, 'defaultStage');
            }
            Object.assign(this, this.load(configOrPath, stage));
        }
        Logger_1.Log.verbose('Loaded project configuration');
    }
    /**
     * Returns singleton project instance.
     * @param projectPath - Current project path.
     * @param stage - Optional stage.
     */
    static getInstance(projectPath, stage) {
        if (!this.instance) {
            this.instance = new ProjectConfig(projectPath, stage);
        }
        return this.instance;
    }
    /**
     * Returns configuration, considering the stage. If no stage is set, just returns this.getConfigContent().
     */
    load(projectPath, stage) {
        const configContent = this.loadContent(projectPath);
        if (stage) {
            const stagedConfig = lodash_get_1.default(configContent, `stages.${stage}`);
            if (stagedConfig) {
                lodash_mergewith_1.default(configContent, stagedConfig, utilities_1.mergeArrayCustomizer);
                // Merge plugins with the same constructor.
                const plugins = configContent.plugins || [];
                const mergedPlugins = {};
                for (const plugin of plugins) {
                    const constructor = plugin.constructor.name;
                    // ! This has a potential runtime of O(nÂ²).
                    if (!Object.keys(mergedPlugins).includes(constructor)) {
                        mergedPlugins[constructor] = plugin;
                    }
                    else {
                        lodash_merge_1.default(mergedPlugins[constructor], plugin);
                    }
                }
                configContent.plugins = Object.values(mergedPlugins);
                for (const plugin of configContent.plugins) {
                    if (plugin.mergeConfig) {
                        plugin.mergeConfig(plugin.initConfig);
                    }
                }
                delete configContent.stages;
            }
            else {
                Logger_1.Log.warning(`Stage ${stage} could not be found in your project configuration. Taking default configuration...`);
            }
        }
        return configContent;
    }
    /**
     * Reads and returns the content of the project's config file.
     */
    loadContent(projectPath) {
        try {
            const path = path_1.join(projectPath, ProjectConfig.getFileName());
            const config = require(path);
            return config;
        }
        catch (error) {
            throw new JovoCliError_1.JovoCliError({
                message: 'Could not load project configuration.',
                details: error.message,
            });
        }
    }
    /**
     * Gets the value for a provided path from the configuration.
     * @param path
     */
    getParameter(path) {
        return lodash_get_1.default(this, path);
    }
    /**
     * Returns the name of the Jovo config file.
     */
    static getFileName(version = 'v4') {
        return version === 'v4' ? 'jovo.project.js' : 'project.js';
    }
}
exports.ProjectConfig = ProjectConfig;
//# sourceMappingURL=ProjectConfig.js.map