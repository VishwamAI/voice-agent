import { NluPlugin, } from '@jovotech/framework';
import { JovoModelNlpjs } from '@jovotech/model-nlpjs';
import { promises } from 'fs';
import { join } from 'path';
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { Nlp } = require('@nlpjs/nlp');
export var NlpJsEntityType;
(function (NlpJsEntityType) {
    NlpJsEntityType["Age"] = "age";
    NlpJsEntityType["Boolean"] = "boolean";
    NlpJsEntityType["Currency"] = "currency";
    NlpJsEntityType["Date"] = "date";
    NlpJsEntityType["DateRange"] = "daterange";
    NlpJsEntityType["DateTime"] = "datetime";
    NlpJsEntityType["DateTimeRange"] = "datetimerange";
    NlpJsEntityType["Dimension"] = "dimension";
    NlpJsEntityType["Duration"] = "duration";
    NlpJsEntityType["Email"] = "email";
    NlpJsEntityType["Enum"] = "enum";
    NlpJsEntityType["Hashtag"] = "hashtag";
    NlpJsEntityType["Ip"] = "ip";
    NlpJsEntityType["Mention"] = "mention";
    NlpJsEntityType["Number"] = "number";
    NlpJsEntityType["NumberRange"] = "numberrange";
    NlpJsEntityType["Ordinal"] = "ordinal";
    NlpJsEntityType["Percentage"] = "percentage";
    NlpJsEntityType["PhoneNumber"] = "phoneNumber";
    NlpJsEntityType["Regex"] = "regex";
    NlpJsEntityType["Temperature"] = "temperature";
    NlpJsEntityType["Time"] = "time";
    NlpJsEntityType["TimeRange"] = "timerange";
    NlpJsEntityType["Timezone"] = "timezone";
    NlpJsEntityType["Url"] = "url";
})(NlpJsEntityType || (NlpJsEntityType = {}));
export class NlpjsNlu extends NluPlugin {
    constructor(config) {
        super(config);
    }
    // TODO fully determine default config
    getDefaultConfig() {
        return Object.assign(Object.assign({}, super.getDefaultConfig()), { languageMap: {}, preTrainedModelFilePath: './model.nlp', useModel: false, modelsPath: './models' });
    }
    async initialize(parent) {
        var _a, _b;
        this.nlpjs = new Nlp({
            languages: Object.keys(this.config.languageMap),
            autoLoad: this.config.useModel,
            // TODO: add condition to check if writing is even possible
            autoSave: this.config.useModel,
            modelFileName: this.config.preTrainedModelFilePath,
            nlu: {
                log: false,
            },
        });
        Object.values(this.config.languageMap).forEach((languagePackage) => {
            var _a;
            (_a = this.nlpjs) === null || _a === void 0 ? void 0 : _a.use(languagePackage);
        });
        // TODO: register fs if write-access is available
        if (this.config.setupModelCallback) {
            await this.config.setupModelCallback(parent, this.nlpjs);
        }
        else if (this.config.useModel) {
            await ((_a = this.nlpjs) === null || _a === void 0 ? void 0 : _a.load(this.config.preTrainedModelFilePath));
        }
        else {
            await this.addCorpusFromModelsIn(this.config.modelsPath);
            await ((_b = this.nlpjs) === null || _b === void 0 ? void 0 : _b.train());
        }
    }
    async processText(jovo, text) {
        var _a, _b;
        const language = ((_a = jovo.$request.getLocale()) === null || _a === void 0 ? void 0 : _a.substr(0, 2)) || 'en';
        const nlpResult = await ((_b = this.nlpjs) === null || _b === void 0 ? void 0 : _b.process(language, text));
        const entities = ((nlpResult === null || nlpResult === void 0 ? void 0 : nlpResult.entities) || []).reduce((entityMap, entity) => {
            const entityName = entity.alias || entity.entity;
            const resolvedValue = this.getResolvedValue(entity);
            entityMap[entityName] = {
                id: resolvedValue,
                resolved: resolvedValue,
                value: entity.utteranceText,
                native: entity,
            };
            return entityMap;
        }, {});
        return (nlpResult === null || nlpResult === void 0 ? void 0 : nlpResult.intent)
            ? {
                intent: {
                    name: nlpResult.intent,
                },
                entities,
                native: nlpResult,
                raw: nlpResult, // @deprecated please use 'native' property
            }
            : undefined;
    }
    async addCorpusFromModelsIn(dir) {
        const files = await promises.readdir(dir);
        const jovoNlpjsConverter = new JovoModelNlpjs();
        for (let i = 0, len = files.length; i < len; i++) {
            const lastDotIndex = files[i].lastIndexOf('.');
            const extension = files[i].substr(lastDotIndex + 1);
            const locale = files[i].substr(0, lastDotIndex);
            const filePath = join(dir, files[i]);
            let jovoModelData;
            if (extension === 'js') {
                jovoModelData = require(join(process.cwd(), filePath));
            }
            else if (extension === 'json') {
                const fileBuffer = await promises.readFile(filePath);
                jovoModelData = JSON.parse(fileBuffer.toString());
            }
            jovoNlpjsConverter.importJovoModel(jovoModelData, locale);
            const nlpJsModeFiles = jovoNlpjsConverter.exportNative() || [];
            nlpJsModeFiles.forEach((model) => {
                var _a;
                (_a = this.nlpjs) === null || _a === void 0 ? void 0 : _a.addCorpus(model.content);
            });
        }
    }
    getResolvedValue(entity) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
        switch (entity.type) {
            case NlpJsEntityType.Enum:
                return (_a = entity.option) !== null && _a !== void 0 ? _a : entity.utteranceText;
            case NlpJsEntityType.Regex:
                return entity.utteranceText;
            case NlpJsEntityType.Age:
            case NlpJsEntityType.Currency:
            case NlpJsEntityType.Dimension:
            case NlpJsEntityType.Number:
            case NlpJsEntityType.Ordinal:
            case NlpJsEntityType.Temperature:
                return (_c = (_b = entity === null || entity === void 0 ? void 0 : entity.resolution) === null || _b === void 0 ? void 0 : _b.strValue) !== null && _c !== void 0 ? _c : entity.utteranceText;
            case NlpJsEntityType.Date:
                return ((_g = (_e = (_d = entity === null || entity === void 0 ? void 0 : entity.resolution) === null || _d === void 0 ? void 0 : _d.strValue) !== null && _e !== void 0 ? _e : (_f = entity === null || entity === void 0 ? void 0 : entity.resolution) === null || _f === void 0 ? void 0 : _f.strFutureValue) !== null && _g !== void 0 ? _g : entity.utteranceText);
            case NlpJsEntityType.Boolean:
            case NlpJsEntityType.Percentage:
                return ((_h = entity === null || entity === void 0 ? void 0 : entity.resolution) === null || _h === void 0 ? void 0 : _h.value)
                    ? entity.resolution.value.toString()
                    : entity.utteranceText;
            case NlpJsEntityType.Time:
            case NlpJsEntityType.DateTime:
                return (_m = (_l = (_k = (_j = entity === null || entity === void 0 ? void 0 : entity.resolution) === null || _j === void 0 ? void 0 : _j.values) === null || _k === void 0 ? void 0 : _k[0]) === null || _l === void 0 ? void 0 : _l.value) !== null && _m !== void 0 ? _m : entity.utteranceText;
            case NlpJsEntityType.Duration:
            case NlpJsEntityType.TimeRange:
                return (_r = (_q = (_p = (_o = entity === null || entity === void 0 ? void 0 : entity.resolution) === null || _o === void 0 ? void 0 : _o.values) === null || _p === void 0 ? void 0 : _p[0]) === null || _q === void 0 ? void 0 : _q.timex) !== null && _r !== void 0 ? _r : entity.utteranceText;
            case NlpJsEntityType.Email:
            case NlpJsEntityType.Hashtag:
            case NlpJsEntityType.Ip:
            case NlpJsEntityType.Mention:
            case NlpJsEntityType.PhoneNumber:
            case NlpJsEntityType.Url:
                return (_u = (_t = (_s = entity === null || entity === void 0 ? void 0 : entity.resolution) === null || _s === void 0 ? void 0 : _s.value) === null || _t === void 0 ? void 0 : _t.toString()) !== null && _u !== void 0 ? _u : entity.utteranceText;
            case NlpJsEntityType.DateRange:
            case NlpJsEntityType.DateTimeRange:
                return (_w = (_v = entity === null || entity === void 0 ? void 0 : entity.resolution) === null || _v === void 0 ? void 0 : _v.timex) !== null && _w !== void 0 ? _w : entity.utteranceText;
            case NlpJsEntityType.NumberRange:
            case NlpJsEntityType.Timezone:
            default:
                // if no explicit mapping, use utteranceText
                // can still access full details from "native" property
                return entity.utteranceText;
        }
    }
}
//# sourceMappingURL=NlpjsNlu.js.map