"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var BuildPlatform_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildPlatform = void 0;
const cli_core_1 = require("@jovotech/cli-core");
const fs_1 = require("fs");
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const utilities_1 = require("../utilities");
let BuildPlatform = BuildPlatform_1 = class BuildPlatform extends cli_core_1.PluginCommand {
    static install(cli, plugin, emitter) {
        // Override PluginCommand.install() to fill options for --platform.
        this.availablePlatforms.push(...cli.getPlatforms());
        super.install(cli, plugin, emitter);
    }
    install() {
        this.middlewareCollection = {
            'build:platform': [this.prepareBuild.bind(this)],
        };
    }
    async prepareBuild() {
        // Create "fake" tasks for more verbose logs.
        const initTask = new cli_core_1.Task(`${cli_core_1.CONSTRUCTION} Initializing build process`);
        const collectConfigTask = new cli_core_1.Task('Collecting platform configuration from project.js.', async () => {
            await cli_core_1.wait(500);
            return `Platforms: ${this.$context.platforms.join(',')}`;
        });
        const collectModelsTask = new cli_core_1.Task(`Collecting Jovo language model files from ./${this.$cli.project.getModelsDirectory()} folder.`, async () => {
            await cli_core_1.wait(500);
            return `Locales: ${this.$context.locales.join(',')}`;
        });
        initTask.add(collectConfigTask, collectModelsTask);
        await initTask.run();
        // Create build/ folder depending on user config.
        const buildPath = this.$cli.project.getBuildPath();
        if (!fs_1.existsSync(buildPath)) {
            fs_1.mkdirSync(buildPath, { recursive: true });
        }
    }
    async run() {
        cli_core_1.Log.spacer();
        cli_core_1.Log.info(`jovo build:platform: ${BuildPlatform_1.description}`);
        cli_core_1.Log.info(cli_core_1.printSubHeadline('Learn more: https://jovo.tech/docs/build-command#build-platform'));
        const { args, flags } = this.parse(BuildPlatform_1);
        // Build plugin context, containing information about the current command environment.
        lodash_merge_1.default(this.$context, {
            args,
            flags,
            locales: flags.locale || this.$cli.project.getLocales(),
            platforms: args.platform.length ? args.platform : this.$cli.getPlatforms(),
        });
        // If --reverse flag has been set and more than one platform has been specified, prompt for one.
        if (flags.reverse) {
            if (this.$context.platforms.length !== 1) {
                const { platform } = await utilities_1.promptForPlatform(this.$context.platforms);
                this.$context.platforms = [platform];
            }
            // On build --reverse, omit selecting default locales with $project.getLocales()
            this.$context.locales = flags.locale || [];
            await this.$emitter.run('build:platform.reverse');
            cli_core_1.Log.spacer();
            cli_core_1.Log.info(`${cli_core_1.TADA} Reverse build completed.`);
            cli_core_1.Log.spacer();
            return;
        }
        await this.$emitter.run('before.build:platform');
        await this.$emitter.run('build:platform');
        await this.$emitter.run('after.build:platform');
        if (flags.deploy) {
            cli_core_1.Log.spacer();
            await this.$emitter.run('before.deploy:platform');
            await this.$emitter.run('deploy:platform');
            await this.$emitter.run('after.deploy:platform');
        }
        cli_core_1.Log.spacer();
        cli_core_1.Log.info(`${cli_core_1.TADA} Build completed.`);
        cli_core_1.Log.spacer();
        // Display a hint for the deployment command, if it's not already been used
        if (!this.$context.flags.deploy && !this.$cli.userConfig.cli.omitHints) {
            cli_core_1.Log.info(`${cli_core_1.BULB} To deploy your built platform, run the following command:`);
            cli_core_1.Log.info(cli_core_1.chalk.dim(`$ jovo deploy:platform ${this.$context.args.platform.join(' ')}`), {
                indent: 3,
            });
            cli_core_1.Log.spacer();
        }
    }
};
BuildPlatform.id = 'build:platform';
BuildPlatform.description = 'Build platform-specific language models based on Jovo models folder';
BuildPlatform.examples = ['jovo build:platform alexa'];
BuildPlatform.availablePlatforms = [];
BuildPlatform.flags = Object.assign({ clean: cli_core_1.flags.boolean({
        description: 'Delete the relevant folders in build at the beginning of the process',
    }), deploy: cli_core_1.flags.boolean({
        char: 'd',
        description: 'Directly deploy the platform after the build process. Run "deploy:platform --help" command for more information.',
        exclusive: ['reverse'],
    }), locale: cli_core_1.flags.string({
        char: 'l',
        description: 'The locales to be built from the models folder',
        multiple: true,
    }), reverse: cli_core_1.flags.boolean({
        char: 'r',
        description: 'Turn contents of the build folder into Jovo Model files',
        exclusive: ['deploy'],
    }) }, cli_core_1.PluginCommand.flags);
BuildPlatform.args = [
    {
        name: 'platform',
        description: 'Specifies a build platform',
        options: BuildPlatform_1.availablePlatforms,
        multiple: true,
    },
];
// Allow multiple arguments by disabling argument length validation
BuildPlatform.strict = false;
BuildPlatform = BuildPlatform_1 = __decorate([
    cli_core_1.ProjectCommand()
], BuildPlatform);
exports.BuildPlatform = BuildPlatform;
//# sourceMappingURL=build.platform.js.map