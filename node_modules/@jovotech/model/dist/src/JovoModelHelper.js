"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JovoModelHelper = void 0;
const _has = require("lodash.has");
const utilities_1 = require("./utilities");
class JovoModelHelper {
    static new(invocation = 'app', intents = {}, entityTypes = {}) {
        return {
            version: '4.0',
            invocation,
            intents,
            entityTypes,
        };
    }
    static prepareModel(model) {
        if (this.isJovoModelV3(model)) {
            if (model.inputTypes && model.inputTypes.length > 0) {
                model.inputTypes.forEach((inputType) => {
                    if (inputType.values && inputType.values.length > 0) {
                        inputType.values.forEach((value) => {
                            if (!value.id) {
                                value.id = '';
                            }
                            if (!value.synonyms) {
                                value.synonyms = [];
                            }
                        });
                    }
                    else {
                        inputType.values = [];
                    }
                });
            }
            else {
                model.inputTypes = [];
            }
            if (model.intents && model.intents.length > 0) {
                model.intents.forEach((intent) => {
                    if (!intent.phrases) {
                        intent.phrases = [];
                    }
                    if (!intent.samples) {
                        intent.samples = [];
                    }
                    if (!intent.inputs) {
                        intent.inputs = [];
                    }
                });
            }
            else {
                model.intents = [];
            }
        }
        else {
            if (model.entityTypes && Object.keys(model.entityTypes).length > 0) {
                for (const entityType of Object.values(model.entityTypes)) {
                    if (entityType.values && entityType.values.length > 0) {
                        entityType.values.forEach((value) => {
                            if (typeof value === 'object') {
                                if (!value.id) {
                                    value.id = '';
                                }
                                if (!value.synonyms) {
                                    value.synonyms = [];
                                }
                            }
                        });
                    }
                    else {
                        entityType.values = [];
                    }
                }
            }
            else {
                model.entityTypes = {};
            }
            if (model.intents && model.intents.length > 0) {
                for (const intent of Object.values(model.intents)) {
                    if (!intent.phrases) {
                        intent.phrases = [];
                    }
                    if (!intent.samples) {
                        intent.samples = [];
                    }
                    if (!intent.entities) {
                        intent.entities = {};
                    }
                }
            }
            else {
                model.intents = {};
            }
        }
        return model;
    }
    static hasIntents(model) {
        if (!model.intents) {
            return false;
        }
        return this.isJovoModelV3(model)
            ? model.intents.length >= 0
            : Object.keys(model.intents).length >= 0;
    }
    static addIntent(model, intent, intentData) {
        if (this.isJovoModelV3(model)) {
            if (!this.getIntentByName(model, intent)) {
                if (!model.intents) {
                    model.intents = [];
                }
                model.intents.push(intentData);
            }
        }
        else {
            if (!this.getIntentByName(model, intent)) {
                if (!model.intents) {
                    model.intents = {};
                }
                model.intents[intent] = intentData;
            }
        }
    }
    static removeIntent(model, intent) {
        if (this.isJovoModelV3(model)) {
            const index = this.getIntentIndex(model, intent);
            if (index >= 0 && model.intents) {
                model.intents.splice(index, 1);
            }
        }
        else {
            if (model.intents) {
                delete model.intents[intent];
            }
        }
    }
    static updateIntent(model, intent, intentData) {
        if (this.isJovoModelV3(model)) {
            const index = this.getIntentIndex(model, intent);
            if (index >= 0 && model.intents) {
                const intents = model.intents.slice();
                intents[index] = intentData;
                model.intents = intents;
            }
        }
        else {
            if (model.intents) {
                model.intents[intent] = intentData;
            }
        }
    }
    static isJovoModelV3(model) {
        return !model.version;
    }
    static isIntentV3(intent) {
        return !!intent.name;
    }
    static getIntents(model) {
        if (this.isJovoModelV3(model)) {
            if (!model.intents) {
                return {};
            }
            const intents = (0, utilities_1.reduceToMap)('name', model.intents);
            return intents;
        }
        else {
            return model.intents || {};
        }
    }
    static getIntentByName(model, intent) {
        if (!model.intents) {
            return;
        }
        return this.getIntents(model)[intent];
    }
    static getPhrases(model, intent) {
        const foundIntent = this.getIntentByName(model, intent);
        return (foundIntent === null || foundIntent === void 0 ? void 0 : foundIntent.phrases) || [];
    }
    static addPhrase(model, intent, phrase) {
        const foundIntent = this.getIntentByName(model, intent);
        if (foundIntent) {
            if (!foundIntent.phrases) {
                foundIntent.phrases = [];
            }
            if (!foundIntent.phrases.includes(phrase)) {
                foundIntent.phrases.push(phrase);
            }
        }
    }
    static removePhrase(model, intent, phrase) {
        if (this.isJovoModelV3(model)) {
            const intentIndex = this.getIntentIndex(model, intent);
            const phraseIndex = this.getPhraseIndex(model, intent, phrase);
            if (_has(model, `intents[${intentIndex}].phrases[${phraseIndex}]`)) {
                model.intents[intentIndex].phrases.splice(phraseIndex, 1);
            }
        }
        else {
            const index = this.getPhraseIndex(model, intent, phrase);
            if (_has(model, `intents[${intent}].phrases[${index}]`)) {
                model.intents[intent].phrases.splice(index, 1);
            }
        }
    }
    static updatePhrase(model, intent, oldPhrase, newPhrase) {
        if (this.isJovoModelV3(model)) {
            const intentIndex = this.getIntentIndex(model, intent);
            const phraseIndex = this.getPhraseIndex(model, intent, oldPhrase);
            if (_has(model, `intents[${intentIndex}].phrases[${phraseIndex}]`)) {
                const phrases = model.intents[intentIndex].phrases.slice();
                phrases[phraseIndex] = newPhrase;
                model.intents[intentIndex].phrases = phrases;
            }
        }
        else {
            const index = this.getPhraseIndex(model, intent, oldPhrase);
            if (_has(model, `intents[${intent}].phrases[${index}]`)) {
                model.intents[intent].phrases[index] = newPhrase;
            }
        }
    }
    static getPhraseIndex(model, intent, phrase) {
        if (this.isJovoModelV3(model)) {
            const intentIndex = this.getIntentIndex(model, intent);
            if (!_has(model, `intents[${intentIndex}].phrases`)) {
                return -1;
            }
            return model.intents[intentIndex].phrases.indexOf(phrase);
        }
        else {
            if (_has(model, `intents[${intent}].phrases`)) {
                return model.intents[intent].phrases.indexOf(phrase);
            }
            return -1;
        }
    }
    static hasPhrase(model, phrase) {
        if (!model.intents) {
            return false;
        }
        return Object.values(model.intents).some((intent) => {
            return (intent.phrases || []).includes(phrase);
        });
    }
    static hasEntities(model, intent) {
        const foundIntent = this.getIntentByName(model, intent);
        return foundIntent
            ? this.isIntentV3(foundIntent)
                ? !!foundIntent.inputs
                : !!foundIntent.entities
            : false;
    }
    static getEntities(model, intent) {
        const foundIntent = this.getIntentByName(model, intent);
        if (!foundIntent) {
            return {};
        }
        if (this.isIntentV3(foundIntent)) {
            if (!foundIntent.inputs) {
                return {};
            }
            return (0, utilities_1.reduceToMap)('name', foundIntent.inputs);
        }
        else {
            return foundIntent.entities || {};
        }
    }
    static getEntityByName(model, intent, entity) {
        const entities = this.getEntities(model, intent);
        return entities[entity];
    }
    static addEntity(model, intent, entity, entityData = { type: '', text: '' }, checkForDuplicates = true) {
        const foundIntent = this.getIntentByName(model, intent);
        if (!foundIntent) {
            return;
        }
        if (!foundIntent.entities) {
            foundIntent.entities = {};
        }
        if (!checkForDuplicates || !foundIntent.entities[entity]) {
            foundIntent.entities[entity] = entityData;
        }
    }
    static removeEntity(model, intent, entity) {
        if (this.isJovoModelV3(model)) {
            const intentIndex = this.getIntentIndex(model, intent);
            const inputIndex = this.getInputIndex(model, intent, entity);
            if (_has(model, `intents[${intentIndex}].inputs[${inputIndex}]`)) {
                model.intents[intentIndex].inputs.splice(inputIndex, 1);
            }
        }
        else {
            if (_has(model, `intents[${intent}].entities[${entity}]`)) {
                delete model.intents[intent].entities[entity];
            }
        }
    }
    static updateEntity(model, intent, entity, entityData) {
        if (this.isJovoModelV3(model)) {
            const intentIndex = this.getIntentIndex(model, intent);
            const inputIndex = this.getInputIndex(model, intent, entity);
            if (_has(model, `intents[${intentIndex}].inputs[${inputIndex}]`)) {
                const inputs = model.intents[intentIndex].inputs.slice();
                inputs[inputIndex] = entityData;
                model.intents[intentIndex].inputs = inputs;
            }
        }
        else {
            if (_has(model, `intents[${intent}].entities[${entity}]`)) {
                model.intents[intent].entities[entity] = entityData;
            }
        }
    }
    static hasEntityTypes(model) {
        return this.isJovoModelV3(model) ? !!model.inputTypes : !!model.entityTypes;
    }
    static addEntityType(model, entityType, entityTypeData = { values: [] }) {
        if (!this.hasEntityTypes(model)) {
            if (this.isJovoModelV3(model)) {
                model.inputTypes = [];
            }
            else {
                model.entityTypes = {};
            }
        }
        if (!this.getEntityTypeByName(model, entityType)) {
            if (this.isJovoModelV3(model)) {
                model.inputTypes.push(Object.assign(Object.assign({}, entityTypeData), { name: entityType }));
            }
            else {
                model.entityTypes[entityType] = entityTypeData;
            }
        }
    }
    static removeEntityType(model, entityType) {
        if (this.isJovoModelV3(model)) {
            const inputIndex = this.getInputTypeIndex(model, entityType);
            if (inputIndex >= 0 && model.inputTypes) {
                model.inputTypes.splice(inputIndex, 1);
            }
        }
        else {
            if (model.entityTypes) {
                delete model.entityTypes[entityType];
            }
        }
    }
    static updateEntityType(model, entityType, entityTypeData) {
        if (this.isJovoModelV3(model)) {
            const index = this.getInputTypeIndex(model, entityType);
            if (index >= 0 && model.inputTypes) {
                const inputTypes = model.inputTypes.slice();
                inputTypes[index] = entityTypeData;
                model.inputTypes = inputTypes;
            }
        }
        else {
            if (model.entityTypes) {
                model.entityTypes[entityType] = entityTypeData;
            }
        }
    }
    static getEntityTypes(model) {
        if (this.isJovoModelV3(model)) {
            if (!model.inputTypes) {
                return {};
            }
            return (0, utilities_1.reduceToMap)('name', model.inputTypes);
        }
        else {
            return model.entityTypes || {};
        }
    }
    static getEntityTypeByName(model, entityType) {
        const entityTypes = this.getEntityTypes(model);
        return entityTypes[entityType];
    }
    static getEntityTypeValues(model, entityType) {
        if (this.isJovoModelV3(model)) {
            const foundInputType = this.getInputTypeByName(model, entityType);
            return foundInputType && foundInputType.values ? foundInputType.values : [];
        }
        else {
            const foundEntityType = this.getEntityTypeByName(model, entityType);
            return (foundEntityType === null || foundEntityType === void 0 ? void 0 : foundEntityType.values) || [];
        }
    }
    static addEntityTypeValue(model, entityType, entityTypeValue, checkForDuplicates = true) {
        if (this.isJovoModelV3(model)) {
            const foundInputType = this.getInputTypeByName(model, entityType);
            if (foundInputType) {
                if (!foundInputType.values) {
                    foundInputType.values = [];
                }
                if (checkForDuplicates) {
                    if (!foundInputType.values.some((inputTypeValue) => {
                        return inputTypeValue.value === entityTypeValue.value;
                    })) {
                        foundInputType.values.push(entityTypeValue);
                    }
                }
                else {
                    foundInputType.values.push(entityTypeValue);
                }
            }
        }
        else {
            const foundEntityType = this.getEntityTypeByName(model, entityType);
            if (!foundEntityType) {
                return;
            }
            if (!foundEntityType.values) {
                foundEntityType.values = [];
            }
            if (typeof entityTypeValue === 'string') {
                entityTypeValue = {
                    value: entityTypeValue,
                    synonyms: [],
                    id: '',
                };
            }
            if (!checkForDuplicates ||
                !foundEntityType.values.some((el) => (typeof el === 'string' ? el : el.value) === entityTypeValue.value)) {
                foundEntityType.values.push(entityTypeValue);
            }
        }
    }
    static removeEntityTypeValue(model, entityType, entityTypeValue) {
        if (this.isJovoModelV3(model)) {
            const inputTypeIndex = this.getInputTypeIndex(model, entityType);
            const inputTypeValueIndex = this.getInputTypeValueIndex(model, entityType, entityTypeValue);
            if (_has(model, `inputTypes[${inputTypeIndex}].values[${inputTypeValueIndex}]`)) {
                model.inputTypes[inputTypeIndex].values.splice(inputTypeValueIndex, 1);
            }
        }
        else {
            const index = this.getEntityTypeValueIndex(model, entityType, entityTypeValue);
            if (_has(model, `entityTypes[${entityType}].values[${index}]`)) {
                model.entityTypes[entityType].values.splice(index, 1);
            }
        }
    }
    static updateEntityTypeValue(model, entityType, entityTypeValue, entityTypeValueData) {
        if (this.isJovoModelV3(model)) {
            const inputTypeIndex = this.getInputTypeIndex(model, entityType);
            const inputTypeValueIndex = this.getInputTypeValueIndex(model, entityType, entityTypeValue);
            if (_has(model, `inputTypes[${inputTypeIndex}].values[${inputTypeValueIndex}]`)) {
                const values = model.inputTypes[inputTypeIndex].values.slice();
                values[inputTypeValueIndex] = entityTypeValueData;
                model.inputTypes[inputTypeIndex].values = values;
            }
        }
        else {
            const index = this.getEntityTypeValueIndex(model, entityType, entityTypeValue);
            if (_has(model, `entityTypes[${entityType}].values[${index}]`)) {
                model.entityTypes[entityType].values[index] = entityTypeValueData;
            }
        }
    }
    static getIntentIndex(model, intent) {
        if (!model.intents) {
            return -1;
        }
        return model.intents.findIndex((el) => el === intent);
    }
    static getInputIndex(model, intent, input) {
        const intentIndex = this.getIntentIndex(model, intent);
        if (!_has(model, `intents[${intentIndex}].inputs`)) {
            return -1;
        }
        return model.intents[intentIndex].inputs.findIndex((intentInput) => intentInput.name === input);
    }
    static getInputTypeIndex(model, inputType) {
        if (!model.inputTypes) {
            return -1;
        }
        return model.inputTypes.findIndex((type) => type.name === inputType);
    }
    static getInputTypeByName(model, inputType) {
        if (!model.inputTypes) {
            return;
        }
        return model.inputTypes.find((type) => type.name === inputType);
    }
    static getInputTypeValueIndex(model, inputType, inputTypeValue) {
        const inputTypeIndex = this.getInputTypeIndex(model, inputType);
        if (!_has(model, `inputTypes[${inputTypeIndex}].values`)) {
            return -1;
        }
        return model.inputTypes[inputTypeIndex].values.findIndex((el) => el.value === inputTypeValue);
    }
    static getEntityTypeValueIndex(model, entityType, entityTypeValue) {
        if (_has(model, `entityTypes[${entityType}].values`)) {
            return model.entityTypes[entityType].values.findIndex((el) => {
                return typeof el === 'string' ? el === entityTypeValue : el.value === entityTypeValue;
            });
        }
        return -1;
    }
    static addEntityTypeValueSynonym(model, entityType, entityTypeValue, synonym, checkForDuplicates = true) {
        if (this.isJovoModelV3(model)) {
            const inputTypeIndex = this.getInputTypeIndex(model, entityType);
            const inputTypeValueIndex = this.getInputTypeValueIndex(model, entityType, entityTypeValue);
            if (_has(model, `inputTypes[${inputTypeIndex}].values[${inputTypeValueIndex}]`)) {
                if (!model.inputTypes[inputTypeIndex].values[inputTypeValueIndex].synonyms) {
                    model.inputTypes[inputTypeIndex].values[inputTypeValueIndex].synonyms = [];
                }
                if (checkForDuplicates) {
                    if (!model.inputTypes[inputTypeIndex].values[inputTypeValueIndex].synonyms.includes(synonym)) {
                        model.inputTypes[inputTypeIndex].values[inputTypeValueIndex].synonyms.push(synonym);
                    }
                }
                else {
                    model.inputTypes[inputTypeIndex].values[inputTypeValueIndex].synonyms.push(synonym);
                }
            }
        }
        else {
            const index = this.getEntityTypeValueIndex(model, entityType, entityTypeValue);
            if (_has(model, `entityTypes[${entityType}].values[${index}]`)) {
                const foundEntityTypeValue = model.entityTypes[entityType].values[index];
                if (typeof foundEntityTypeValue === 'string') {
                    return;
                }
                const entityTypeValueSynonyms = foundEntityTypeValue.synonyms || [];
                if (!checkForDuplicates || entityTypeValueSynonyms.includes(synonym)) {
                    entityTypeValueSynonyms.push(synonym);
                }
                foundEntityTypeValue.synonyms = entityTypeValueSynonyms;
            }
        }
    }
    static removeEntityTypeValueSynonym(model, entityType, entityTypeValue, synonym) {
        if (this.isJovoModelV3(model)) {
            const inputTypeIndex = this.getInputTypeIndex(model, entityType);
            const inputTypeValueIndex = this.getInputTypeValueIndex(model, entityType, entityTypeValue);
            if (_has(model, `inputTypes[${inputTypeIndex}].values[${inputTypeValueIndex}].synonyms`)) {
                const synonymIndex = model.inputTypes[inputTypeIndex].values[inputTypeValueIndex].synonyms.indexOf(synonym);
                if (synonymIndex >= 0) {
                    model.inputTypes[inputTypeIndex].values[inputTypeValueIndex].synonyms.splice(synonymIndex, 1);
                }
            }
        }
        else {
            const entityTypeValueIndex = this.getEntityTypeValueIndex(model, entityType, entityTypeValue);
            if (_has(model, `entityTypes[${entityType}].values[${entityTypeValueIndex}].synonyms`)) {
                const synonyms = model.entityTypes[entityType].values[entityTypeValueIndex].synonyms;
                const synonymIndex = synonyms.indexOf(synonym);
                if (synonymIndex >= 0) {
                    synonyms.splice(synonymIndex, 1);
                }
            }
        }
    }
    static updateEntityTypeValueSynonym(model, entityType, entityTypeValue, oldSynonym, newSynonym) {
        if (this.isJovoModelV3(model)) {
            const inputTypeIndex = this.getInputTypeIndex(model, entityType);
            const inputTypeValueIndex = this.getInputTypeValueIndex(model, entityType, entityTypeValue);
            if (_has(model, `inputTypes[${inputTypeIndex}].values[${inputTypeValueIndex}].synonyms`)) {
                const synonymIndex = model.inputTypes[inputTypeIndex].values[inputTypeValueIndex].synonyms.indexOf(oldSynonym);
                if (synonymIndex >= 0) {
                    const synonyms = model.inputTypes[inputTypeIndex].values[inputTypeValueIndex].synonyms.slice();
                    synonyms[synonymIndex] = newSynonym;
                    model.inputTypes[inputTypeIndex].values[inputTypeValueIndex].synonyms = synonyms;
                }
            }
        }
        else {
            const entityTypeValueIndex = this.getEntityTypeValueIndex(model, entityType, entityTypeValue);
            if (_has(model, `entityTypes[${entityType}].values[${entityTypeValueIndex}].synonyms`)) {
                const synonyms = model.entityTypes[entityType].values[entityTypeValueIndex].synonyms;
                const synonymIndex = synonyms.indexOf(oldSynonym);
                if (synonymIndex >= 0) {
                    synonyms[synonymIndex] = newSynonym;
                }
            }
        }
    }
}
exports.JovoModelHelper = JovoModelHelper;
//# sourceMappingURL=JovoModelHelper.js.map