import chalk from 'chalk';
import _mergeWith from 'lodash.mergewith';
import { getLogger, levels } from 'loglevel';
import { JovoError } from './JovoError';
var JovoLogger = /** @class */ (function () {
    function JovoLogger(nameOrConfig) {
        var defaultConfig = this.getDefaultConfig();
        // if a config is passed, merge the default config with either the passed config or name
        // otherwise just use the default config
        this.config = nameOrConfig
            ? _mergeWith(defaultConfig, typeof nameOrConfig === 'string' ? { name: nameOrConfig } : nameOrConfig, function (value, srcValue) {
                if (Array.isArray(value) && Array.isArray(srcValue)) {
                    return srcValue;
                }
            })
            : defaultConfig;
        // create the logger instance with the given name
        // if the name is used again, the same instance will be returned
        this.logger = getLogger(this.config.name);
        // set the level of the logger depending on the config
        this.logger.setLevel(this.config.level);
    }
    Object.defineProperty(JovoLogger.prototype, "level", {
        get: function () {
            return this.logger.getLevel();
        },
        set: function (level) {
            this.logger.setLevel(level);
        },
        enumerable: false,
        configurable: true
    });
    JovoLogger.prototype.getDefaultConfig = function () {
        return {
            name: 'JovoLogger',
            styling: true,
            level: process.env.JOVO_LOG_LEVEL || levels.TRACE,
            errorProperties: ['package', 'message', 'context', 'stack', 'hint', 'learnMore'],
        };
    };
    JovoLogger.prototype.trace = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.applyStyleIfEnabled(args, chalk.magenta);
        (_a = this.logger).trace.apply(_a, args);
    };
    JovoLogger.prototype.log = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.applyStyleIfEnabled(args, chalk.white);
        (_a = this.logger).log.apply(_a, args);
    };
    JovoLogger.prototype.debug = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.applyStyleIfEnabled(args, chalk.green);
        (_a = this.logger).debug.apply(_a, args);
    };
    JovoLogger.prototype.info = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.applyStyleIfEnabled(args, chalk.blue);
        (_a = this.logger).info.apply(_a, args);
    };
    JovoLogger.prototype.warn = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.applyStyleIfEnabled(args, chalk.yellow);
        (_a = this.logger).warn.apply(_a, args);
    };
    JovoLogger.prototype.error = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var logPart = function (part) {
            var _a;
            if (part.length) {
                _this.applyStyleIfEnabled(part, chalk.red);
                (_a = _this.logger).error.apply(_a, part);
            }
        };
        // just looping args and using this.logger.error there would lead to more line breaks than expected,
        // therefore the logic beneath only adds line breaks when a JovoError was found as arg
        var currentPart = [];
        args.forEach(function (value) {
            // if the value is a JovoError make sure to log the current part and reset it
            if (value instanceof JovoError) {
                logPart(currentPart);
                currentPart = [];
                // and also log the JovoError
                _this.jovoError(value);
            }
            else {
                // otherwise just add to the current part
                currentPart.push(value);
            }
        });
        // if there's anything left in the current part, log it as well
        logPart(currentPart);
    };
    JovoLogger.prototype.jovoError = function (error) {
        var _this = this;
        this.logger.error(this.style('\nJOVO ERROR', chalk.redBright), this.style(" " + error.name + " ", chalk.bgRedBright));
        // add empty line after error header
        this.logger.error();
        // function for logging a property of JovoError if it exists and is a string
        // an additional chalk method can be passed for customizing the value's text
        var logStringProperty = function (property, style) {
            if (style === void 0) { style = chalk.whiteBright; }
            var value = error[property];
            if (!value || typeof value !== 'string') {
                return;
            }
            // format property: uppercase letters to lower case and add space before
            // example: learnMore -> learn more; helloWorld -> hello world
            var formattedProperty = property.replace(/([A-Z])/g, function (text) { return ' ' + text.toLowerCase(); });
            _this.logger.error(_this.style(formattedProperty + ":", chalk.underline));
            _this.logger.error(_this.style(value, style));
        };
        // function for logging the context of JovoError
        var logContext = function () {
            _this.logger.error(_this.style('context:', chalk.underline));
            _this.logger.error(error.context);
        };
        // function for logging a property of JovoError
        var logProperty = function (property, style) {
            if (property === 'context') {
                logContext();
            }
            else {
                logStringProperty(property, style);
            }
            // add empty line after property block
            _this.logger.error();
        };
        // log each configured property
        this.config.errorProperties.forEach(function (property) {
            logProperty(property);
        });
    };
    // utility method that only applies the given chalk-function if styling is not disabled
    JovoLogger.prototype.style = function (text, chalkFn) {
        if (!this.config.styling) {
            return text;
        }
        return chalkFn(text);
    };
    // applies the given style to all strings in the given args if styling is not disabled
    JovoLogger.prototype.applyStyleIfEnabled = function (args, chalkFn) {
        if (!this.config.styling) {
            return;
        }
        args.forEach(function (arg, index) {
            // only style strings for now
            if (typeof arg === 'string') {
                args[index] = chalkFn(arg);
            }
        });
    };
    return JovoLogger;
}());
export { JovoLogger };
//# sourceMappingURL=JovoLogger.js.map