"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileBuilder = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const lodash_set_1 = __importDefault(require("lodash.set"));
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const utils_1 = require("./utils");
const Parser = __importStar(require("./parsers"));
class FileBuilder {
    /**
     * Builds files from a .json object.
     * @param obj - The object to build files from.
     * @param path - The root path where the files should be built in.
     */
    static buildDirectory(obj, path) {
        const normalizedObject = this.normalizeObject(obj);
        this.parseObjectToDirectory(normalizedObject, [path]);
    }
    /**
     * Reads files from a provided directory and creates a JSON object representation from it.
     * @param directory - The path to the directory.
     */
    static readDirectory(directory) {
        return this.parseDirectoryToObject([directory]);
    }
    /**
     * Normalizes an object of type FileObject. Checks for nested paths and nested properties and resolves them.
     * @param obj - The object to normalize.
     */
    static normalizeFileObject(obj) {
        return this.normalizeObject(obj);
    }
    static normalizeObject(obj, translated = {}) {
        for (const [key, val] of Object.entries(obj)) {
            const directories = key.split('/').filter((el) => !!el);
            // Key contains at least two directory entries.
            if (directories.length > 1 || key.endsWith('/')) {
                if (typeof val !== 'object' || Array.isArray(val)) {
                    throw new Error(`Directory ${key} must contain at least one file entry.`);
                }
                // Get first directory entry.
                const directory = directories.shift();
                const fileFormat = this.getFileFormat(directory);
                // If the directory has a file extension, aka is a file identifier with a nested path,
                // don't append a "/" to the object path.
                const path = fileFormat ? directory : `${directory}/`;
                // Create a nested object, that will be recursively translated.
                let nestedObj = val;
                // If there are still directory entries left, initiate this as a new object and
                // set the current value to the joined directory path.
                if (directories.length) {
                    // Set the remaining directories as the only key with
                    // the current value object as it's value.
                    nestedObj = { [`${path_1.join(...directories)}/`]: val };
                }
                // Recursively parse the nested object and set the now translated object
                // as the value to the current directory.
                const translatedNestedObj = this.normalizeObject(nestedObj, {});
                const merged = lodash_merge_1.default({}, translated[path], translatedNestedObj);
                translated[path] = merged;
            }
            else {
                // Key is either of format "file.json" or nested property, such as foo.bar.
                // Try to get file format.
                const fileFormat = this.getFileFormat(key);
                // If no file format can be found, set the property as is.
                // _set() will handle nested properties for us.
                if (!fileFormat) {
                    lodash_set_1.default(translated, key, val);
                    continue;
                }
                if (typeof val !== 'object' || Array.isArray(val)) {
                    translated[key] = val;
                }
                else {
                    // If the current value is an object, normalize that object first, before assigning it to the current key.
                    const translatedNestedObj = this.normalizeObject(val, {});
                    translated[key] = translatedNestedObj;
                }
            }
        }
        return translated;
    }
    static parseObjectToDirectory(obj, directory) {
        for (const [key, val] of Object.entries(obj)) {
            if (key.endsWith('/')) {
                // Key is directory, recursive building.
                this.parseObjectToDirectory(val, [...directory, key]);
                continue;
            }
            else {
                // Turn path into an absolute path.
                const absoluteDirectory = path_1.resolve(...directory);
                const fileFormat = this.getFileFormat(key);
                if (!fs_1.existsSync(absoluteDirectory)) {
                    fs_1.mkdirSync(absoluteDirectory, { recursive: true });
                }
                let file = val;
                const filePath = path_1.join(absoluteDirectory, key);
                if (fs_1.existsSync(filePath) && typeof file === 'object') {
                    try {
                        // Parse and merge with existing file.
                        const existingFileContent = fs_1.readFileSync(filePath, 'utf-8');
                        const existingFile = Parser.decode(existingFileContent, fileFormat);
                        lodash_merge_1.default(existingFile, val);
                        file = existingFile;
                    }
                    catch (err) {
                        throw new Error(`${err.message} for "${key}".`);
                    }
                }
                const fileContent = typeof file === 'object' ? Parser.encode(file, fileFormat) : file;
                fs_1.writeFileSync(filePath, fileContent);
            }
        }
    }
    static parseDirectoryToObject(directory, obj = {}) {
        const directoryPath = path_1.join(...directory);
        const files = fs_1.readdirSync(directoryPath);
        for (const file of files) {
            const filePath = path_1.join(directoryPath, file);
            if (fs_1.statSync(filePath).isDirectory()) {
                this.parseDirectoryToObject([...directory, file], obj);
                continue;
            }
            else {
                const fileFormat = this.getFileFormat(file);
                const fileContent = fs_1.readFileSync(filePath, 'utf-8');
                const parsedFileContent = Parser.decode(fileContent, fileFormat);
                // Extract root folder from path, since this was the parameter and should not be included in the resulting object.
                const [, ...key] = directory;
                // Append "/" to the end of every directory key ("folder" -> "folder/").
                const objectKey = key.map((el) => `${el}/`);
                lodash_set_1.default(obj, [...objectKey, file], parsedFileContent);
            }
        }
        return obj;
    }
    /**
     * Returns the extension for a given file identifier.
     * @param fileName - Name of the file to filter the extension from.
     */
    static getFileFormat(fileName) {
        const formatRegex = /\.([^.]+)$/;
        const match = formatRegex.exec(fileName);
        const fileFormat = match ? match[1] : null;
        // If file format is not supported, return null.
        return fileFormat && utils_1.SupportedFileFormats.includes(fileFormat) ? fileFormat : null;
    }
}
exports.FileBuilder = FileBuilder;
//# sourceMappingURL=FileBuilder.js.map