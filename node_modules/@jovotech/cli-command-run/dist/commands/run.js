"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var Run_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Run = void 0;
const cli_core_1 = require("@jovotech/cli-core");
const open_1 = __importDefault(require("open"));
const child_process_1 = require("child_process");
const utilities_1 = require("../utilities");
let Run = Run_1 = class Run extends cli_core_1.PluginCommand {
    install() {
        this.middlewareCollection = {
            'before.run': [this.checkForOutdatedPackages.bind(this)],
        };
    }
    async checkForOutdatedPackages() {
        // Update message should be displayed in case old packages get used
        const outdatedPackages = await cli_core_1.getOutdatedPackages(/@jovotech\//);
        if (utilities_1.shouldUpdatePackages(this.$cli.userConfig, outdatedPackages)) {
            cli_core_1.Log.info('Updates available for the following Jovo packages:');
            cli_core_1.Log.spacer();
            cli_core_1.Log.info(cli_core_1.printPackages(outdatedPackages));
            cli_core_1.Log.spacer();
            cli_core_1.Log.info("Use 'jovo update' to get the newest versions.");
            cli_core_1.Log.spacer();
        }
    }
    async run() {
        cli_core_1.Log.spacer();
        cli_core_1.Log.info(`jovo run: ${Run_1.description}`);
        cli_core_1.Log.info(cli_core_1.printSubHeadline('Learn more: https://jovo.tech/docs/run-command'));
        const { flags } = this.parse(Run_1);
        // Set plugin context
        this.$context.flags = flags;
        await this.$emitter.run('before.run');
        if (flags.port) {
            process.env.JOVO_PORT = flags.port;
        }
        const nodeProcess = child_process_1.spawn('npm', ['run', `start:${flags.stage || 'dev'}`], {
            shell: true,
            windowsVerbatimArguments: true,
            stdio: [process.stdin, process.stdout, process.stderr],
        });
        // Check if we can enable raw mode for input stream to capture raw keystrokes
        if (process.stdin.isTTY && process.stdin.setRawMode) {
            setTimeout(() => {
                // eslint-disable-next-line no-console
                console.log(`\nTo open Jovo Debugger in your browser, press the "." key.\n`);
            }, 500);
            // Capture unprocessed key input.
            process.stdin.setRawMode(true);
            // Explicitly resume emitting data from the stream.
            process.stdin.resume();
            // Capture readable input as opposed to binary.
            process.stdin.setEncoding('utf-8');
            // Collect input text from input stream.
            process.stdin.on('data', async (keyRaw) => {
                const key = keyRaw.toString();
                // When dot gets pressed, try to open the debugger in browser.
                if (key === '.') {
                    try {
                        await open_1.default(this.$cli.getJovoWebhookUrl());
                    }
                    catch (error) {
                        cli_core_1.Log.info(`Could not open browser. Please open debugger manually by visiting this url: ${this.$cli.getJovoWebhookUrl()}`);
                    }
                }
                else {
                    if (key.charCodeAt(0) === 3) {
                        // Ctrl+C has been pressed, kill process.
                        if (process.platform === 'win32') {
                            process.stdin.pause();
                            process.stdin.setRawMode(false);
                            console.log('Press Ctrl + C again to exit...');
                        }
                        else {
                            nodeProcess.kill();
                            process.exit();
                        }
                    }
                    else {
                        // Record input text and write it into terminal.
                        process.stdout.write(key);
                    }
                }
            });
        }
        await this.$emitter.run('run');
        // Ensure our child process is terminated upon exit. This is needed in the situation
        // where we're on Linux and are the child of another process (grandchild processes are orphaned in Linux).
        process.on('SIGTERM', () => {
            if (nodeProcess.pid) {
                process.kill(nodeProcess.pid, 'SIGTERM');
            }
            process.exit();
        });
    }
};
Run.id = 'run';
Run.description = 'Start the local development server and test your app using the Jovo Debugger';
Run.examples = ['jovo run', 'jovo run --port 8008'];
Run.flags = Object.assign({ port: cli_core_1.flags.string({
        char: 'p',
        description: 'The port to be used for the server',
        default: '3000',
    }), timeout: cli_core_1.flags.integer({
        description: 'Maximum amount of time in milliseconds before the server returns a timeout',
        default: 5000,
    }) }, cli_core_1.PluginCommand.flags);
Run = Run_1 = __decorate([
    cli_core_1.ProjectCommand()
], Run);
exports.Run = Run;
//# sourceMappingURL=run.js.map