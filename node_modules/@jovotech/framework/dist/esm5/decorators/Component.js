import { BuiltInHandler } from '../enums';
import { DuplicateChildComponentsError } from '../errors/DuplicateChildComponentsError';
import { ComponentMetadata } from '../metadata/ComponentMetadata';
import { HandlerMetadata } from '../metadata/HandlerMetadata';
import { HandlerOptionMetadata } from '../metadata/HandlerOptionMetadata';
import { MetadataStorage } from '../metadata/MetadataStorage';
import { getMethodKeys } from '../utilities';
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function Component(options) {
    return function (target) {
        if (options === null || options === void 0 ? void 0 : options.components) {
            var componentNameSet_1 = new Set();
            options.components.forEach(function (component) {
                var _a;
                var componentName = typeof component === 'function'
                    ? component.name
                    : ((_a = component.options) === null || _a === void 0 ? void 0 : _a.name) || component.component.name;
                if (componentNameSet_1.has(componentName)) {
                    throw new DuplicateChildComponentsError(componentName, target.name);
                }
                componentNameSet_1.add(componentName);
            });
        }
        var metadataStorage = MetadataStorage.getInstance();
        var keys = getMethodKeys(target.prototype);
        // iterate all keys of methods of the target
        keys.forEach(function (key) {
            var hasHandlerMetadata = metadataStorage.handlerMetadata.some(function (handlerMetadata) {
                return handlerMetadata.target === target && handlerMetadata.propertyKey === key;
            });
            var hasHandlerOptionMetadata = metadataStorage.handlerOptionMetadata.some(function (optionMetadata) { return optionMetadata.target === target && optionMetadata.propertyKey === key; });
            // if it is LAUNCH or END
            if (key === BuiltInHandler.Launch || key === BuiltInHandler.End) {
                // unshift to not overwrite any other explicitly set HandlerOptionMetadata when merging
                metadataStorage.handlerOptionMetadata.unshift(new HandlerOptionMetadata(target, key, {
                    global: true,
                    types: [key],
                }));
            }
            else if (!hasHandlerMetadata && !hasHandlerOptionMetadata) {
                metadataStorage.addHandlerMetadata(new HandlerMetadata(target, key));
            }
        });
        metadataStorage.addComponentMetadata(new ComponentMetadata(target, options));
        return;
    };
}
//# sourceMappingURL=Component.js.map