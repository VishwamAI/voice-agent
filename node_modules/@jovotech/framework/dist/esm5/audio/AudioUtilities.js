var AudioUtilities = /** @class */ (function () {
    function AudioUtilities() {
    }
    AudioUtilities.getSamplesFromBase64 = function (base64) {
        var binaryBuffer = Buffer.from(base64, 'base64').toString('binary');
        var length = binaryBuffer.length / Float32Array.BYTES_PER_ELEMENT;
        var view = new DataView(new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT));
        var samples = new Float32Array(length);
        for (var i = 0; i < length; i++) {
            var p = i * 4;
            view.setUint8(0, binaryBuffer.charCodeAt(p));
            view.setUint8(1, binaryBuffer.charCodeAt(p + 1));
            view.setUint8(2, binaryBuffer.charCodeAt(p + 2));
            view.setUint8(3, binaryBuffer.charCodeAt(p + 3));
            samples[i] = view.getFloat32(0, true);
        }
        return samples;
    };
    AudioUtilities.sampleDown = function (samples, currentSampleRate, newSampleRate) {
        if (newSampleRate >= currentSampleRate) {
            return samples;
        }
        var ratio = currentSampleRate / newSampleRate;
        var newLength = Math.round(samples.length / ratio);
        var result = new Float32Array(newLength);
        var offsetResult = 0;
        var offsetBuffer = 0;
        while (offsetResult < result.length) {
            var nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
            var accum = 0;
            var count = 0;
            for (var i = offsetBuffer; i < nextOffsetBuffer && i < samples.length; i++) {
                accum += samples[i];
                count++;
            }
            result[offsetResult] = accum / count;
            offsetResult++;
            offsetBuffer = nextOffsetBuffer;
        }
        return result;
    };
    AudioUtilities.encodeSamplesToWav = function (samples, sampleRate) {
        var buffer = new ArrayBuffer(44 + samples.length * 2);
        var view = new DataView(buffer);
        // RIFF chunk descriptor
        this.writeUTFBytes(view, 0, 'RIFF');
        view.setUint32(4, 32 + samples.length * 2, true);
        this.writeUTFBytes(view, 8, 'WAVE');
        // FMT sub-chunk
        this.writeUTFBytes(view, 12, 'fmt ');
        view.setUint32(16, 16, true); // chunkSize
        view.setUint16(20, 1, true); // wFormatTag
        view.setUint16(22, 1, true); // wChannels
        view.setUint32(24, sampleRate, true); // dwSamplesPerSec
        view.setUint32(28, sampleRate * 2, true); // dwAvgBytesPerSec
        view.setUint16(32, 2, true); // wBlockAlign
        view.setUint16(34, 16, true); // wBitsPerSample
        // data sub-chunk
        this.writeUTFBytes(view, 36, 'data');
        view.setUint32(40, samples.length * 2, true);
        this.floatTo16BitPCM(view, 44, samples);
        return Buffer.from(view.buffer);
    };
    AudioUtilities.floatTo16BitPCM = function (view, offset, val) {
        for (var i = 0; i < val.length; i++, offset += 2) {
            var s = Math.max(-1, Math.min(1, val[i]));
            view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
        }
    };
    AudioUtilities.writeUTFBytes = function (view, offset, val) {
        for (var i = 0; i < val.length; i++) {
            view.setUint8(offset + i, val.charCodeAt(i));
        }
    };
    AudioUtilities.getBase64Audio = function (stream) {
        return new Promise(function (resolve, reject) {
            var _buf = Array();
            stream.on('data', function (chunk) { return _buf.push(chunk); });
            stream.on('end', function () { return resolve(Buffer.concat(_buf).toString('base64')); });
            stream.on('error', function (err) { return reject("error converting stream - " + err); });
        });
    };
    AudioUtilities.buildBase64Uri = function (data, mimeType) {
        return "data:" + mimeType + ";base64," + data;
    };
    return AudioUtilities;
}());
export { AudioUtilities };
//# sourceMappingURL=AudioUtilities.js.map