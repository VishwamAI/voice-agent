var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { BuiltInHandler } from '../enums';
import { MatchingRouteNotFoundError } from '../errors/MatchingRouteNotFoundError';
import { MetadataStorage } from '../metadata/MetadataStorage';
import { RouteMatch } from './RouteMatch';
var RoutingExecutor = /** @class */ (function () {
    function RoutingExecutor(jovo) {
        this.jovo = jovo;
    }
    RoutingExecutor.prototype.execute = function () {
        return __awaiter(this, void 0, void 0, function () {
            var rankedRouteMatches, resolvedRouteMatch;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getRankedRouteMatches()];
                    case 1:
                        rankedRouteMatches = _a.sent();
                        if (!rankedRouteMatches.length) {
                            throw new MatchingRouteNotFoundError({
                                request: this.jovo.$request,
                                input: this.jovo.$input,
                                state: this.jovo.$state,
                            });
                        }
                        this.setSkipForRouteMatches(rankedRouteMatches);
                        return [4 /*yield*/, this.resolveRoute(rankedRouteMatches)];
                    case 2:
                        resolvedRouteMatch = _a.sent();
                        if (!resolvedRouteMatch) {
                            throw new MatchingRouteNotFoundError({
                                request: this.jovo.$request,
                                input: this.jovo.$input,
                                state: this.jovo.$state,
                                matches: rankedRouteMatches,
                            });
                        }
                        return [2 /*return*/, {
                                resolved: resolvedRouteMatch,
                                matches: rankedRouteMatches,
                            }];
                }
            });
        });
    };
    RoutingExecutor.prototype.getRankedRouteMatches = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var globalRouteMatches, localRouteMatches;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getRankedGlobalRouteMatches()];
                    case 1:
                        globalRouteMatches = _b.sent();
                        if (!((_a = this.jovo.$state) === null || _a === void 0 ? void 0 : _a.length)) {
                            return [2 /*return*/, globalRouteMatches];
                        }
                        return [4 /*yield*/, this.getRankedLocalRouteMatches()];
                    case 2:
                        localRouteMatches = _b.sent();
                        return [2 /*return*/, __spreadArray(__spreadArray([], localRouteMatches, true), globalRouteMatches, true)];
                }
            });
        });
    };
    RoutingExecutor.prototype.setSkipForRouteMatches = function (rankedRouteMatches) {
        var _a, _b;
        var intentName = this.jovo.$input.getIntentName();
        var isIntentToSkipUnhandled = intentName &&
            ((_b = (_a = this.jovo.$handleRequest.config.routing) === null || _a === void 0 ? void 0 : _a.intentsToSkipUnhandled) === null || _b === void 0 ? void 0 : _b.includes(intentName));
        // if the mapped intent is an intent that is supposed to skip UNHANDLED
        if (isIntentToSkipUnhandled) {
            // set skip: true for all UNHANDLED-matches
            rankedRouteMatches.forEach(function (match) {
                if (match.type === BuiltInHandler.Unhandled) {
                    match.skip = true;
                }
            });
        }
        // find the first RouteMatch that is UNHANDLED
        var firstRouteMatchIndexWithUnhandled = rankedRouteMatches.findIndex(function (match) { return match.type === BuiltInHandler.Unhandled; });
        // find index of the last RouteMatch that has prioritizedOverUnhandled in a reversed matches-array
        var lastReversedRouteMatchIndexWithPrioritizedOverUnhandled = rankedRouteMatches
            .slice()
            .reverse()
            .findIndex(function (match) { return !!match.prioritizedOverUnhandled; });
        // get the actual index in the non-reversed matches-array by subtracting the index from the length and 1 due to arrays starting with 0
        var lastRouteMatchIndexWithPrioritizedOverUnhandled = rankedRouteMatches.length - lastReversedRouteMatchIndexWithPrioritizedOverUnhandled - 1;
        // if no indexes were found or they're invalid, abort
        if (firstRouteMatchIndexWithUnhandled < 0 ||
            lastReversedRouteMatchIndexWithPrioritizedOverUnhandled < 0 ||
            lastRouteMatchIndexWithPrioritizedOverUnhandled < 0 ||
            lastRouteMatchIndexWithPrioritizedOverUnhandled < firstRouteMatchIndexWithUnhandled) {
            return;
        }
        // iterate all RouteMatches between indexes and set skip: true for them
        for (var i = firstRouteMatchIndexWithUnhandled; i < lastRouteMatchIndexWithPrioritizedOverUnhandled; i++) {
            if (rankedRouteMatches[i].type === BuiltInHandler.Unhandled ||
                !rankedRouteMatches[i].prioritizedOverUnhandled) {
                rankedRouteMatches[i].skip = true;
            }
        }
    };
    RoutingExecutor.prototype.resolveRoute = function (routeMatches) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // iterate all RouteMatches and return the first match that has no skip not set to true
                return [2 /*return*/, routeMatches.find(function (match) { return !match.skip; })];
            });
        });
    };
    RoutingExecutor.prototype.isMatchingHandler = function (metadata, intentNames) {
        var _a, _b;
        if (intentNames === void 0) { intentNames = metadata.intentNames; }
        // do type-matching
        if ((_b = (_a = metadata.options) === null || _a === void 0 ? void 0 : _a.types) === null || _b === void 0 ? void 0 : _b.includes(this.jovo.$input.type)) {
            return true;
        }
        // do intent-matching
        var intentName = this.jovo.$input.getIntentName();
        return ((intentName && intentNames.includes(intentName)) ||
            intentNames.includes(BuiltInHandler.Unhandled));
    };
    RoutingExecutor.prototype.getRankedGlobalRouteMatches = function () {
        return __awaiter(this, void 0, void 0, function () {
            var globalRouteMatches;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getGlobalRouteMatches()];
                    case 1:
                        globalRouteMatches = _a.sent();
                        return [2 /*return*/, globalRouteMatches.sort(this.compareRouteMatchRanking)];
                }
            });
        });
    };
    RoutingExecutor.prototype.isMatchingGlobalHandler = function (handlerMetadata, componentMetadata) {
        var isGlobal = handlerMetadata.options.global ||
            componentMetadata.isGlobal ||
            !!handlerMetadata.globalIntentNames.length;
        // if neither handler nor component nor any intent is global, abort
        if (!isGlobal) {
            return false;
        }
        // if the component is global, all intent names are global, otherwise only use global intent names
        // the reason is, that a handler can not be locally called anyways if the component is global
        var intentNames = componentMetadata.isGlobal
            ? handlerMetadata.intentNames
            : handlerMetadata.globalIntentNames;
        return this.isMatchingHandler(handlerMetadata, intentNames);
    };
    RoutingExecutor.prototype.getGlobalRouteMatches = function () {
        return __awaiter(this, void 0, void 0, function () {
            var routeMatches, componentNodes, _i, componentNodes_1, node, handlerMetadataToRouteMatchMapper, relatedHandlerMetadata, _a, relatedHandlerMetadata_1, metadata, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        routeMatches = [];
                        componentNodes = Array.from(this.jovo.$handleRequest.componentTree);
                        _i = 0, componentNodes_1 = componentNodes;
                        _c.label = 1;
                    case 1:
                        if (!(_i < componentNodes_1.length)) return [3 /*break*/, 7];
                        node = componentNodes_1[_i];
                        handlerMetadataToRouteMatchMapper = this.createHandlerMetadataToRouteMatchMapper(node.path);
                        if (node.metadata.options.isAvailable && !node.metadata.options.isAvailable(this.jovo)) {
                            return [3 /*break*/, 6];
                        }
                        relatedHandlerMetadata = MetadataStorage.getInstance().getMergedHandlerMetadataOfComponent(node.metadata.target);
                        _a = 0, relatedHandlerMetadata_1 = relatedHandlerMetadata;
                        _c.label = 2;
                    case 2:
                        if (!(_a < relatedHandlerMetadata_1.length)) return [3 /*break*/, 6];
                        metadata = relatedHandlerMetadata_1[_a];
                        _b = !this.isMatchingGlobalHandler(metadata, node.metadata);
                        if (_b) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.areHandlerConditionsFulfilled(metadata)];
                    case 3:
                        _b = !(_c.sent());
                        _c.label = 4;
                    case 4:
                        // if the conditions are no fulfilled, do not add the handler
                        if (_b) {
                            return [3 /*break*/, 5];
                        }
                        routeMatches.push(handlerMetadataToRouteMatchMapper(metadata));
                        _c.label = 5;
                    case 5:
                        _a++;
                        return [3 /*break*/, 2];
                    case 6:
                        _i++;
                        return [3 /*break*/, 1];
                    case 7: return [2 /*return*/, routeMatches];
                }
            });
        });
    };
    RoutingExecutor.prototype.getRankedLocalRouteMatches = function () {
        return __awaiter(this, void 0, void 0, function () {
            var routeMatches;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getLocalRouteMatches()];
                    case 1:
                        routeMatches = _a.sent();
                        return [2 /*return*/, routeMatches.sort(function (match, otherMatch) {
                                // if the path is different, ignore
                                if (match.path !== otherMatch.path) {
                                    return 0;
                                }
                                return _this.compareRouteMatchRanking(match, otherMatch);
                            })];
                }
            });
        });
    };
    RoutingExecutor.prototype.isMatchingLocalHandler = function (metadata, subState) {
        var _a, _b;
        // if a subState is passed, make sure the handler has exactly the same subState, otherwise make sure the handler has no subState
        return ((subState ? ((_a = metadata.options) === null || _a === void 0 ? void 0 : _a.subState) === subState : !((_b = metadata.options) === null || _b === void 0 ? void 0 : _b.subState)) &&
            this.isMatchingHandler(metadata));
    };
    RoutingExecutor.prototype.getLocalRouteMatches = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var routeMatches, stackIndex, stackItem, currentComponentPath, subState, node, handlerMetadataToRouteMatchMapper, relatedHandlerMetadata, _i, relatedHandlerMetadata_2, metadata, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!((_a = this.jovo.$state) === null || _a === void 0 ? void 0 : _a.length)) {
                            return [2 /*return*/, []];
                        }
                        routeMatches = [];
                        stackIndex = this.jovo.$state.length - 1;
                        _c.label = 1;
                    case 1:
                        if (!(stackIndex >= 0)) return [3 /*break*/, 9];
                        stackItem = this.jovo.$state[stackIndex];
                        currentComponentPath = stackItem.component.split('.');
                        subState = stackItem.subState;
                        node = this.jovo.$handleRequest.componentTree.getNodeAtOrFail(currentComponentPath);
                        _c.label = 2;
                    case 2:
                        if (!node) return [3 /*break*/, 8];
                        handlerMetadataToRouteMatchMapper = this.createHandlerMetadataToRouteMatchMapper(node.path);
                        if (!(!node.metadata.options.isAvailable || node.metadata.options.isAvailable(this.jovo))) return [3 /*break*/, 7];
                        relatedHandlerMetadata = MetadataStorage.getInstance().getMergedHandlerMetadataOfComponent(node.metadata.target);
                        _i = 0, relatedHandlerMetadata_2 = relatedHandlerMetadata;
                        _c.label = 3;
                    case 3:
                        if (!(_i < relatedHandlerMetadata_2.length)) return [3 /*break*/, 7];
                        metadata = relatedHandlerMetadata_2[_i];
                        _b = !this.isMatchingLocalHandler(metadata, subState);
                        if (_b) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.areHandlerConditionsFulfilled(metadata)];
                    case 4:
                        _b = !(_c.sent());
                        _c.label = 5;
                    case 5:
                        // if the conditions are no fulfilled, do not add the handler
                        if (_b) {
                            return [3 /*break*/, 6];
                        }
                        routeMatches.push(handlerMetadataToRouteMatchMapper(metadata, stackIndex));
                        _c.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 3];
                    case 7:
                        // if a subState is set, make sure to check the same node without subState before moving to the parent
                        if (subState) {
                            subState = undefined;
                        }
                        else {
                            node = node.parent;
                        }
                        return [3 /*break*/, 2];
                    case 8:
                        stackIndex--;
                        return [3 /*break*/, 1];
                    case 9: return [2 /*return*/, routeMatches];
                }
            });
        });
    };
    RoutingExecutor.prototype.areHandlerConditionsFulfilled = function (metadata) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function () {
            var isPlatformSupported, isConditionFulfilled, _h;
            return __generator(this, function (_j) {
                switch (_j.label) {
                    case 0:
                        isPlatformSupported = !((_b = (_a = metadata.options) === null || _a === void 0 ? void 0 : _a.platforms) === null || _b === void 0 ? void 0 : _b.length) ||
                            ((_d = (_c = metadata.options) === null || _c === void 0 ? void 0 : _c.platforms) === null || _d === void 0 ? void 0 : _d.includes(this.jovo.$platform.outputTemplateConverterStrategy.platformName));
                        _h = !((_e = metadata.options) === null || _e === void 0 ? void 0 : _e.if);
                        if (_h) return [3 /*break*/, 2];
                        return [4 /*yield*/, ((_g = (_f = metadata.options) === null || _f === void 0 ? void 0 : _f.if) === null || _g === void 0 ? void 0 : _g.call(_f, this.jovo))];
                    case 1:
                        _h = (_j.sent());
                        _j.label = 2;
                    case 2:
                        isConditionFulfilled = _h;
                        return [2 /*return*/, isPlatformSupported && isConditionFulfilled];
                }
            });
        });
    };
    RoutingExecutor.prototype.createHandlerMetadataToRouteMatchMapper = function (path) {
        return function (metadata, stackIndex) {
            return new RouteMatch(metadata, path, stackIndex);
        };
    };
    RoutingExecutor.prototype.compareRouteMatchRanking = function (match, otherMatch) {
        var matchIsUnhandled = match.metadata.intentNames.includes(BuiltInHandler.Unhandled);
        var otherMatchIsUnhandled = otherMatch.metadata.intentNames.includes(BuiltInHandler.Unhandled);
        if (match.stackIndex && otherMatch.stackIndex) {
            if (match.stackIndex < otherMatch.stackIndex) {
                // if otherMatch is higher in the stack, it will take precedence except when it is UNHANDLED and match is prioritizedOverUnhandled.
                if (otherMatchIsUnhandled && match.prioritizedOverUnhandled) {
                    return -1;
                }
                else {
                    return 1;
                }
            }
            else if (match.stackIndex > otherMatch.stackIndex) {
                // same thing in the other direction. If match is higher in the stack, it will take precedence.
                if (matchIsUnhandled && otherMatch.prioritizedOverUnhandled) {
                    return 1;
                }
                else {
                    return -1;
                }
            }
        }
        if (matchIsUnhandled && !otherMatchIsUnhandled) {
            return 1;
        }
        else if (!matchIsUnhandled && otherMatchIsUnhandled) {
            return -1;
        }
        return otherMatch.score - match.score;
    };
    return RoutingExecutor;
}());
export { RoutingExecutor };
//# sourceMappingURL=RoutingExecutor.js.map