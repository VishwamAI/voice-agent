import { JovoError } from '@jovotech/common';
import _get from 'lodash.get';
import _intersection from 'lodash.intersection';
import _set from 'lodash.set';
import _unset from 'lodash.unset';
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function forEachDeep(value, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
handler, path) {
    if (path === void 0) { path = ''; }
    if (path) {
        handler(value, path);
    }
    if (Array.isArray(value)) {
        value.forEach(function (val, index) {
            forEachDeep(val, handler, path + "[" + index + "]");
        });
    }
    else if (value && typeof value === 'object') {
        Object.keys(value).forEach(function (key) {
            forEachDeep(value[key], handler, path ? path + "." + key : key);
        });
    }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function getMethodKeys(prototype) {
    return Object.getOwnPropertyNames(prototype).filter(function (key) {
        if (key === 'constructor') {
            return false;
        }
        var descriptor = Object.getOwnPropertyDescriptor(prototype, key);
        return (typeof prototype[key] === 'function' &&
            typeof (descriptor === null || descriptor === void 0 ? void 0 : descriptor.value) === 'function');
    });
}
/**
 * Allows to mask certain properties of an object to hide sensitive data.
 * Alters the original object.
 * @param obj - Object which contains properties to mask
 * @param objectsToMask - Array of strings representing the properties to mask. Nested properties are supported, e.g. "foo.bar".
 * @param mask - Mask value to apply. If a function is provided, it will be executed and the result will be taken as the mask value.
 */
export function mask(obj, objectsToMask, mask) {
    objectsToMask.forEach(function (maskPath) {
        var value = _get(obj, maskPath);
        if (value) {
            var maskedValue = typeof mask === 'function' ? mask(value) : mask;
            _set(obj, maskPath, maskedValue);
        }
    });
}
/**
 * Copies an object and allows to suggest properties to include/exclude
 * @param source - Source object to copy
 * @param config - Copy configuration, allows to set properties to include/exclude when copying. Nested properties are supported, e.g. "foo.bar".
 */
export function copy(source, config) {
    var _a, _b;
    var intersection = _intersection(config === null || config === void 0 ? void 0 : config.include, config === null || config === void 0 ? void 0 : config.exclude);
    if (intersection.length) {
        throw new JovoError({
            message: "Collision detected during object construction, trying to include/exclude the same properties " + JSON.stringify(intersection),
            hint: 'Please disambiguate your configuration by specifying which properties to include/exclude',
        });
    }
    var result = {};
    if ((_a = config === null || config === void 0 ? void 0 : config.include) === null || _a === void 0 ? void 0 : _a.length) {
        config.include.forEach(function (includePath) {
            _set(result, includePath, _get(source, includePath));
        });
    }
    else {
        result = JSON.parse(JSON.stringify(source));
    }
    if ((_b = config === null || config === void 0 ? void 0 : config.exclude) === null || _b === void 0 ? void 0 : _b.length) {
        config.exclude.forEach(function (excludePath) {
            _unset(result, excludePath);
        });
    }
    return result;
}
/**
 * Checks, whether two Providers have the same `provide` value.
 * @param a - First Provider to compare
 * @param b - Second Provider to compare
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function isSameProvide(a, b) {
    if (typeof a === 'function' && typeof b === 'function') {
        return a === b;
    }
    else if (typeof a === 'function' && typeof b !== 'function') {
        return a === b.provide;
    }
    else if (typeof a !== 'function' && typeof b === 'function') {
        return a.provide === b;
    }
    else if (typeof a !== 'function' && typeof b !== 'function') {
        return a.provide === b.provide;
    }
    else {
        return false;
    }
}
//# sourceMappingURL=utilities.js.map