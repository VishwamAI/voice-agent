import _cloneDeep from 'lodash.clonedeep';
import { ComponentMetadata } from './ComponentMetadata';
import { HandlerMetadata } from './HandlerMetadata';
import { OutputMetadata } from './OutputMetadata';
export class MetadataStorage {
    constructor() {
        this.componentMetadata = [];
        this.componentOptionMetadata = [];
        this.handlerMetadata = [];
        this.handlerOptionMetadata = [];
        this.outputMetadata = [];
        this.injectableMetadata = [];
        this.injectMetadata = [];
    }
    static getInstance() {
        if (!MetadataStorage.instance) {
            MetadataStorage.instance = new MetadataStorage();
        }
        return MetadataStorage.instance;
    }
    addComponentMetadata(metadata) {
        // TODO: determine what to do if a component like that already exists
        // for now, just skip (first only counts)
        if (this.getComponentMetadata(metadata.target)) {
            return;
        }
        this.componentMetadata.push(metadata);
    }
    getComponentMetadata(
    // eslint-disable-next-line @typescript-eslint/ban-types
    target) {
        return this.componentMetadata.find((metadata) => metadata.target === target);
    }
    getMergedComponentMetadata(
    // eslint-disable-next-line @typescript-eslint/ban-types
    target) {
        const componentMetadata = this.getComponentMetadata(target);
        const componentOptionMetadata = this.getComponentOptionMetadata(target);
        if (!componentMetadata && !componentOptionMetadata.length) {
            return;
        }
        const mergedComponentMetadata = componentMetadata
            ? _cloneDeep(componentMetadata)
            : new ComponentMetadata(target);
        componentOptionMetadata.forEach((optionMetadata) => mergedComponentMetadata.mergeWith(optionMetadata));
        return mergedComponentMetadata;
    }
    addComponentOptionMetadata(metadata) {
        this.componentOptionMetadata.push(metadata);
    }
    getComponentOptionMetadata(
    // eslint-disable-next-line @typescript-eslint/ban-types
    target) {
        return this.componentOptionMetadata.filter((metadata) => metadata.target === target);
    }
    addOutputMetadata(target, name) {
        const existingMetadata = this.getOutputMetadataByName(name);
        if (existingMetadata) {
            // make sure the name of an Output is unique
            const similarExistingMetadata = this.outputMetadata.filter((metadata) => metadata.name.startsWith(name));
            const getEndingNumberRegex = /(\d+)$/;
            let highestNumber = -1;
            similarExistingMetadata.forEach((metadata) => {
                const endingNumberMatch = getEndingNumberRegex.exec(metadata.name);
                const endingNumber = +((endingNumberMatch === null || endingNumberMatch === void 0 ? void 0 : endingNumberMatch[1]) || -1);
                if (endingNumber > highestNumber) {
                    highestNumber = endingNumber;
                }
            });
            highestNumber++;
            if (getEndingNumberRegex.test(name)) {
                name = name.replace(getEndingNumberRegex, highestNumber.toString());
            }
            else {
                name += highestNumber;
            }
        }
        this.outputMetadata.push(new OutputMetadata(target, name));
    }
    getOutputMetadata(
    // eslint-disable-next-line @typescript-eslint/ban-types
    target) {
        return this.outputMetadata.find((metadata) => metadata.target === target);
    }
    getOutputMetadataByName(name) {
        return this.outputMetadata.find((metadata) => metadata.name === name);
    }
    addHandlerMetadata(metadata) {
        this.handlerMetadata.push(metadata);
    }
    getHandlerMetadataOfComponent(
    // eslint-disable-next-line @typescript-eslint/ban-types
    target) {
        return this.handlerMetadata.filter((metadata) => metadata.target === target);
    }
    getMergedHandlerMetadataOfComponent(
    // eslint-disable-next-line @typescript-eslint/ban-types
    target) {
        const mergedComponentMetadata = this.getMergedComponentMetadata(target);
        const componentHandlerMetadata = this.getHandlerMetadataOfComponent(target);
        const mergedMetadata = componentHandlerMetadata.map((handlerMetadata) => {
            const mergedHandlerMetadata = _cloneDeep(handlerMetadata);
            const relatedHandlerOptionMetadata = this.handlerOptionMetadata.filter((optionMetadata) => optionMetadata.hasSameTargetAs(mergedHandlerMetadata));
            relatedHandlerOptionMetadata.forEach((optionMetadata) => mergedHandlerMetadata.mergeWith(optionMetadata));
            if (mergedComponentMetadata === null || mergedComponentMetadata === void 0 ? void 0 : mergedComponentMetadata.isGlobal) {
                mergedHandlerMetadata.options.global = true;
            }
            return mergedHandlerMetadata;
        });
        const handlerOptionMetadataWithoutHandler = this.handlerOptionMetadata.filter((optionMetadata) => optionMetadata.target === target &&
            !componentHandlerMetadata.some((handlerMetadata) => handlerMetadata.hasSameTargetAs(optionMetadata)));
        handlerOptionMetadataWithoutHandler.forEach((optionMetadata) => {
            const relatedHandlerMetadata = mergedMetadata.find((handlerMetadata) => handlerMetadata.hasSameTargetAs(optionMetadata));
            if (!relatedHandlerMetadata) {
                mergedMetadata.push(new HandlerMetadata(optionMetadata.target, optionMetadata.propertyKey, Object.assign(Object.assign({}, optionMetadata.options), { global: (mergedComponentMetadata === null || mergedComponentMetadata === void 0 ? void 0 : mergedComponentMetadata.isGlobal) || optionMetadata.options.global })));
            }
            else {
                relatedHandlerMetadata.mergeWith(optionMetadata);
            }
        });
        const prototype = Object.getPrototypeOf(target);
        // Object.getPrototypeOf of the topmost class in the superclass chain is {} (empty object)
        // and Object.getPrototypeOf({}) is Object.prototype.
        if (prototype && Object.getPrototypeOf(prototype) !== Object.prototype) {
            const parentMergedMetadata = this.getMergedHandlerMetadataOfComponent(prototype);
            return this.mergeHandlerMetadataWithParent(mergedMetadata, parentMergedMetadata);
        }
        return mergedMetadata;
    }
    /**
     * Merges the handler metadata of a component with the handler metadata of its superclass.
     * When a child class declares a handler with the same name as a handler of its superclass,
     * the child class handler overrides the superclass handler and replaces all of its annotations.
     *
     * @param handlerMetadata
     * @param parentMetadata
     * @private
     */
    mergeHandlerMetadataWithParent(handlerMetadata, parentMetadata) {
        const mergedMetadata = [...handlerMetadata];
        for (const parentHandler of parentMetadata) {
            const isOverride = handlerMetadata.findIndex((meta) => {
                if (meta.propertyKey !== parentHandler.propertyKey) {
                    return false;
                }
                return (meta.target === parentHandler.target ||
                    Object.getPrototypeOf(meta.target) === parentHandler.target);
            }) >= 0;
            if (!isOverride) {
                mergedMetadata.push(parentHandler);
            }
        }
        return mergedMetadata;
    }
    addHandlerOptionMetadata(metadata) {
        this.handlerOptionMetadata.push(metadata);
    }
    getHandlerOptionMetadataOfComponent(
    // eslint-disable-next-line @typescript-eslint/ban-types
    target) {
        return this.handlerOptionMetadata.filter((metadata) => metadata.target === target);
    }
    addInjectableMetadata(metadata) {
        if (this.getInjectableMetadata(metadata.target)) {
            // for now, just skip (first only counts)
            return;
        }
        this.injectableMetadata.push(metadata);
    }
    getInjectableMetadata(
    // eslint-disable-next-line @typescript-eslint/ban-types
    target) {
        return this.injectableMetadata.find((metadata) => metadata.target === target);
    }
    addInjectMetadata(metadata) {
        if (this.getInjectMetadataAtIndex(metadata.target, metadata.index)) {
            // for now, just skip (first only counts)
            return;
        }
        this.injectMetadata.push(metadata);
    }
    getMergedInjectMetadata(
    // eslint-disable-next-line @typescript-eslint/ban-types
    target) {
        return this.injectMetadata.filter((metadata) => metadata.target === target);
    }
    getInjectMetadataAtIndex(
    // eslint-disable-next-line @typescript-eslint/ban-types
    target, index) {
        return this.injectMetadata.find((metadata) => metadata.target === target && metadata.index === index);
    }
    clearAll() {
        this.componentMetadata.length = 0;
        this.handlerMetadata.length = 0;
        this.handlerOptionMetadata.length = 0;
        this.outputMetadata.length = 0;
        this.injectableMetadata.length = 0;
        this.injectMetadata.length = 0;
    }
}
//# sourceMappingURL=MetadataStorage.js.map