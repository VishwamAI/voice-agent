import { BuiltInHandler } from '../enums';
import { DuplicateChildComponentsError } from '../errors/DuplicateChildComponentsError';
import { ComponentMetadata } from '../metadata/ComponentMetadata';
import { HandlerMetadata } from '../metadata/HandlerMetadata';
import { HandlerOptionMetadata } from '../metadata/HandlerOptionMetadata';
import { MetadataStorage } from '../metadata/MetadataStorage';
import { getMethodKeys } from '../utilities';
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function Component(options) {
    return function (target) {
        if (options === null || options === void 0 ? void 0 : options.components) {
            const componentNameSet = new Set();
            options.components.forEach((component) => {
                var _a;
                const componentName = typeof component === 'function'
                    ? component.name
                    : ((_a = component.options) === null || _a === void 0 ? void 0 : _a.name) || component.component.name;
                if (componentNameSet.has(componentName)) {
                    throw new DuplicateChildComponentsError(componentName, target.name);
                }
                componentNameSet.add(componentName);
            });
        }
        const metadataStorage = MetadataStorage.getInstance();
        const keys = getMethodKeys(target.prototype);
        // iterate all keys of methods of the target
        keys.forEach((key) => {
            const hasHandlerMetadata = metadataStorage.handlerMetadata.some((handlerMetadata) => handlerMetadata.target === target && handlerMetadata.propertyKey === key);
            const hasHandlerOptionMetadata = metadataStorage.handlerOptionMetadata.some((optionMetadata) => optionMetadata.target === target && optionMetadata.propertyKey === key);
            // if it is LAUNCH or END
            if (key === BuiltInHandler.Launch || key === BuiltInHandler.End) {
                // unshift to not overwrite any other explicitly set HandlerOptionMetadata when merging
                metadataStorage.handlerOptionMetadata.unshift(new HandlerOptionMetadata(target, key, {
                    global: true,
                    types: [key],
                }));
            }
            else if (!hasHandlerMetadata && !hasHandlerOptionMetadata) {
                metadataStorage.addHandlerMetadata(new HandlerMetadata(target, key));
            }
        });
        metadataStorage.addComponentMetadata(new ComponentMetadata(target, options));
        return;
    };
}
//# sourceMappingURL=Component.js.map