import { InputType, JovoError } from '@jovotech/common';
import { existsSync } from 'fs';
import _cloneDeep from 'lodash.clonedeep';
import _merge from 'lodash.merge';
import { join as joinPaths } from 'path';
import { v4 as uuidv4 } from 'uuid';
import { JovoRequest, JovoSession, Plugin, } from '..';
import { HandleRequest } from '../HandleRequest';
import { JovoInput } from '../JovoInput';
import { TestPlatform } from './TestPlatform';
import { TestServer } from './TestServer';
export class TestSuite extends Plugin {
    constructor(config) {
        super(config);
        // Load app from configured stage and register testplugins
        this.app = this.config.app || this.loadApp();
        this.app.use(this, new TestPlatform());
        const platform = new this.config.platform();
        this.requestBuilder = new platform.requestBuilder();
        const request = platform.createRequestInstance(this.requestBuilder.launch());
        const server = new TestServer(request);
        const handleRequest = new HandleRequest(this.app, server);
        Object.assign(this, new platform.jovoClass(this.app, handleRequest, platform));
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const { afterEach, afterAll } = require('@jest/globals');
        if (this.config.data.deleteAfterEach) {
            afterEach(this.clearData.bind(this));
        }
        if (this.config.data.deleteAfterAll) {
            afterAll(this.clearData.bind(this));
        }
    }
    getDefaultConfig() {
        return {
            data: {
                deleteAfterEach: true,
                deleteAfterAll: true,
            },
            userId: uuidv4(),
            platform: TestPlatform,
            stage: 'dev',
            locale: 'en',
        };
    }
    install(app) {
        app.middlewareCollection.use('before.request.start', this.prepareRequest.bind(this));
        app.middlewareCollection.use('after.response.end', this.postProcess.bind(this));
    }
    async run(requestOrInput) {
        const requests = Array.isArray(requestOrInput) ? requestOrInput : [requestOrInput];
        for (const requestLike of requests) {
            const isInputInstance = (input) => input instanceof JovoInput;
            const isInputObject = (input) => !isInputInstance(input) &&
                Object.keys(input).some((key) => ['type', 'asr', 'nlu', 'intent', 'entities', 'text', 'audio'].includes(key));
            const isRequestObject = (request) => {
                return (!(request instanceof JovoRequest) && !isInputInstance(request) && !isInputObject(request));
            };
            // If requestOrInput is a plain object, generate a corresponding
            // instance from it
            this.requestOrInput = isInputObject(requestLike)
                ? new JovoInput(requestLike)
                : isRequestObject(requestLike)
                    ? this.$platform.createRequestInstance(requestLike)
                    : requestLike;
            await this.app.initialize();
            const request = this.isRequest(this.requestOrInput)
                ? this.requestOrInput
                : this.requestOrInput.type === InputType.Launch
                    ? this.requestBuilder.launch()
                    : this.requestBuilder.intent();
            await this.app.handle(new TestServer(request));
        }
        return {
            response: this.$response,
            output: this.$output,
        };
    }
    clearData() {
        this.$user = this.$platform.createUserInstance(this);
        this.$session = new JovoSession();
        this.$request = this.$platform.createRequestInstance({});
        this.$app.data = {};
    }
    prepareRequest(jovo) {
        // Reset session data if a new session is incoming
        if (jovo.$request.isNewSession() || jovo.$input.type === InputType.Launch) {
            this.$session = new JovoSession();
        }
        if (!this.isRequest(this.requestOrInput)) {
            jovo.$input = this.requestOrInput;
            jovo.$entities = jovo.getEntityMap();
        }
        jovo.$user.isNew = this.$user.isNew;
        _merge(jovo.$user.data, this.$user.data);
        _merge(jovo.$session, this.$session);
        _merge(jovo.$request, this.$request);
        _merge(jovo.$data, this.$data);
        _merge(jovo.$app.data, this.$app.data);
        jovo.$request.setUserId(this.config.userId);
        jovo.$request.setLocale(this.config.locale);
    }
    postProcess(jovo) {
        // Set session data
        jovo.$session.isNew = false;
        this.$user.data = jovo.$user.data;
        this.$session = jovo.$session;
        this.$response = jovo.$response;
        this.$output = jovo.$output;
        this.$data = {}; // Request data is only available for one request, @see https://www.jovo.tech/docs/data#request-data
    }
    loadApp() {
        const appDirectory = [process.cwd(), 'src'];
        const { stage } = this.config;
        const appFileNames = [`app.${stage}.ts`, `app.${stage}.js`, 'app.ts', 'app.js'];
        for (const appFileName of appFileNames) {
            const appFilePath = joinPaths(...appDirectory, appFileName);
            if (existsSync(appFilePath)) {
                try {
                    // eslint-disable-next-line @typescript-eslint/no-var-requires
                    const { app } = require(appFilePath);
                    if (!app) {
                        continue;
                    }
                    // TODO: Instead of cloning the entire app, it'd be sufficient to
                    // implement app.middlewareCollection.once() to run handlers once per lifecycle
                    return _cloneDeep(app);
                }
                catch (error) {
                    throw new JovoError({ message: `Failed to load app: ${error.message}` });
                }
            }
        }
        throw new JovoError({
            message: 'App not found.',
            hint: 'Try running your tests in the root directory of your project',
        });
    }
    isRequest(request) {
        return request instanceof JovoRequest;
    }
}
//# sourceMappingURL=TestSuite.js.map