import _merge from 'lodash.merge';
import { ComponentTree, isSameProvide, Jovo, Logger, Plugin, } from '.';
import { MatchingPlatformNotFoundError } from './errors/MatchingPlatformNotFoundError';
import { Extensible } from './Extensible';
import { HandleRequest } from './HandleRequest';
import { I18Next } from './I18Next';
import { MiddlewareCollection } from './MiddlewareCollection';
import { Platform } from './Platform';
import { BasicLogging } from './plugins/BasicLogging';
import { HandlerPlugin } from './plugins/HandlerPlugin';
import { OutputPlugin } from './plugins/OutputPlugin';
import { RouterPlugin } from './plugins/RouterPlugin';
export const APP_MIDDLEWARES = [
    'request.start',
    'request',
    'request.end',
    'interpretation.start',
    'interpretation.asr',
    'interpretation.nlu',
    'interpretation.end',
    'dialogue.start',
    'dialogue.router',
    'dialogue.logic',
    'dialogue.end',
    'response.start',
    'response.output',
    'response.tts',
    'response.end',
];
export class App extends Extensible {
    constructor(config) {
        super(config ? Object.assign(Object.assign({}, config), { components: undefined, providers: undefined }) : config);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.systemProviders = [];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.providers = [];
        this.initialized = false;
        this.errorListeners = [];
        // @see https://www.jovo.tech/docs/data#app-data
        this.data = {};
        // @see https://www.jovo.tech/docs/cms
        this.cms = {};
        if (typeof this.config.logging === 'object' && this.config.logging.logger) {
            _merge(Logger.config, this.config.logging.logger);
        }
        this.onError((error) => {
            Logger.error(error);
        });
        this.use(new RouterPlugin(), new HandlerPlugin(), new OutputPlugin());
        this.componentTree = new ComponentTree(...((config === null || config === void 0 ? void 0 : config.components) || []));
        this.i18n = new I18Next(this.config.i18n);
        this.providers = (config === null || config === void 0 ? void 0 : config.providers) || [];
        this.systemProviders = [
            {
                provide: Jovo,
                useFactory: (jovo) => jovo,
            },
        ];
    }
    get isInitialized() {
        return this.initialized;
    }
    get platforms() {
        return Object.values(this.plugins).filter((plugin) => plugin instanceof Platform);
    }
    configure(config) {
        _merge(this.config, Object.assign(Object.assign({}, config), { components: undefined, plugins: undefined }));
        const usables = [...((config === null || config === void 0 ? void 0 : config.plugins) || []), ...((config === null || config === void 0 ? void 0 : config.components) || [])];
        this.use(...usables);
        if (config.providers) {
            const mergedProviders = [...config.providers];
            for (const provider of this.providers) {
                if (!mergedProviders.find((p) => isSameProvide(p, provider))) {
                    mergedProviders.push(provider);
                }
            }
            this.providers.length = 0;
            this.providers.push(...mergedProviders);
        }
    }
    onError(listener) {
        if (this.errorListeners.includes(listener)) {
            return;
        }
        this.errorListeners.push(listener);
    }
    addErrorListener(listener) {
        return this.onError(listener);
    }
    removeErrorListener(listener) {
        const index = this.errorListeners.indexOf(listener);
        if (index >= 0) {
            this.errorListeners.splice(index, 1);
        }
    }
    initializeMiddlewareCollection() {
        return new MiddlewareCollection(...APP_MIDDLEWARES);
    }
    middleware(name) {
        return this.middlewareCollection.get(name);
    }
    hook(name, fn) {
        this.middlewareCollection.use(name, fn);
    }
    getDefaultConfig() {
        return {
            logging: true,
        };
    }
    async initialize() {
        if (this.initialized) {
            return;
        }
        if (typeof this.config.logging === 'boolean' && this.config.logging) {
            this.use(new BasicLogging({ request: true, response: true }));
        }
        else if (typeof this.config.logging === 'object') {
            if (this.config.logging.logger) {
                _merge(Logger.config, this.config.logging.logger);
            }
            this.use(new BasicLogging(this.config.logging));
        }
        try {
            await this.componentTree.initialize();
            await this.i18n.initialize();
            await this.initializePlugins();
            this.initialized = true;
        }
        catch (e) {
            return this.handleError(e);
        }
    }
    use(...usables) {
        const plugins = usables.filter((usable) => {
            if (!(usable instanceof Plugin)) {
                return false;
            }
            if ((process.env.NODE_ENV === 'test' || process.env.JEST_WORKER_ID) &&
                usable.config.skipTests) {
                return false;
            }
            return true;
        });
        if (plugins.length) {
            super.use(...plugins);
        }
        const components = usables.filter((usable) => !(usable instanceof Plugin));
        if (components.length) {
            this.componentTree.add(...components);
        }
        return this;
    }
    async handle(server) {
        try {
            const handleRequest = new HandleRequest(this, server);
            await handleRequest.mount();
            const relatedPlatform = handleRequest.platforms.find((platform) => platform.isRequestRelated(server.getRequestObject()));
            if (!relatedPlatform) {
                throw new MatchingPlatformNotFoundError(server.getRequestObject());
            }
            handleRequest.platform = relatedPlatform;
            const jovo = relatedPlatform.createJovoInstance(this, handleRequest);
            // RIDR-pipeline
            await handleRequest.middlewareCollection.run(APP_MIDDLEWARES.slice(), jovo);
            await handleRequest.dismount();
            // TODO determine what to do if there is not response
            if (!jovo.$response) {
                return;
            }
            // use handleRequest.server instead of server in order to allow a request-related server instance to be used
            await handleRequest.server.setResponse(jovo.$response);
        }
        catch (e) {
            await this.handleError(e);
            return server.fail(e);
        }
    }
    async handleError(error, jovo) {
        var _a;
        const errorInstance = error instanceof Error ? error : new Error(error);
        if (!((_a = this.errorListeners) === null || _a === void 0 ? void 0 : _a.length)) {
            throw error;
        }
        for (const listener of this.errorListeners) {
            await listener(errorInstance, jovo);
        }
    }
}
//# sourceMappingURL=App.js.map