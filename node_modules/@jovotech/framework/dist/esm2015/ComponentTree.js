import _get from 'lodash.get';
import _merge from 'lodash.merge';
import { ComponentTreeNode } from './ComponentTreeNode';
import { ComponentNotFoundError } from './errors/ComponentNotFoundError';
import { DuplicateChildComponentsError } from './errors/DuplicateChildComponentsError';
import { InvalidComponentTreeBuiltError } from './errors/InvalidComponentTreeBuiltError';
import { ComponentMetadata } from './metadata/ComponentMetadata';
import { MetadataStorage } from './metadata/MetadataStorage';
/**
 * @example Structure of ComponentTree
 * {
 * "tree": {
 *   "GlobalComponent": {
 *     "path": [
 *       "GlobalComponent"
 *     ],
 *     "metadata": {
 *       "options": {
 *         "global": true
 *       }
 *     }
 *   },
 *   "RootComponent": {
 *     "path": [
 *       "RootComponent"
 *     ],
 *     "metadata": {
 *       "options": {
 *         "components": [
 *           "NestedComponent"
 *         ]
 *       }
 *     },
 *     "children": {
 *       "NestedComponent": {
 *         "path": [
 *           "RootComponent",
 *           "NestedComponent"
 *         ],
 *         "metadata": {
 *           "options": {}
 *         },
 *         "parent": "RootComponent"
 *       }
 *     }
 *   }
 * }
 *}
 */
export class ComponentTree {
    constructor(...components) {
        this.initialBuildErrors = [];
        this.tree = this.buildTreeForComponents(...components);
    }
    // returns a map-callback that will create a ComponentTreeNode for the given component (constructor or declaration)
    static createComponentToNodeMapper(componentTree, parent) {
        return (component) => {
            var _a;
            const componentConstructor = typeof component === 'function' ? component : component.component;
            // get the metadata of the component
            const componentMetadata = MetadataStorage.getInstance().getMergedComponentMetadata(componentConstructor);
            // merge the options of the related metadata with the options of the given options (only set when passing a declaration)
            const mergedComponentOptions = _merge({}, (componentMetadata === null || componentMetadata === void 0 ? void 0 : componentMetadata.options) || {}, typeof component === 'function' ? {} : component.options || {});
            const componentName = ((_a = componentMetadata === null || componentMetadata === void 0 ? void 0 : componentMetadata.options) === null || _a === void 0 ? void 0 : _a.name) || componentConstructor.name;
            // return a new node with metadata, that is constructed from the constructor and the merged component options, as well as additional data
            return new ComponentTreeNode(componentTree, {
                metadata: new ComponentMetadata(componentConstructor, mergedComponentOptions),
                parent,
                children: mergedComponentOptions.components,
                path: (parent === null || parent === void 0 ? void 0 : parent.path) ? [...parent.path, componentName] : [componentName],
            });
        };
    }
    // returns a reduce-callback that will create a Tree from the components it's called on
    static createComponentsToTreeReducer(componentTree, parent) {
        return (tree, component) => {
            const node = ComponentTree.createComponentToNodeMapper(componentTree, parent)(component);
            if (!tree[node.name]) {
                tree[node.name] = node;
            }
            else {
                componentTree.initialBuildErrors.push(new DuplicateChildComponentsError(node.name, (parent === null || parent === void 0 ? void 0 : parent.name) || 'Root'));
            }
            return tree;
        };
    }
    [Symbol.iterator]() {
        let index = -1;
        const nodes = [];
        this.iterateNodes(Object.values(this.tree), (node) => {
            nodes.push(node);
        });
        return {
            next: () => ({ value: nodes[++index], done: !(index in nodes) }),
        };
    }
    async initialize() {
        if (this.initialBuildErrors.length) {
            throw new InvalidComponentTreeBuiltError(this.initialBuildErrors);
        }
    }
    add(...components) {
        const tree = this.buildTreeForComponents(...components);
        for (const key in tree) {
            if (tree.hasOwnProperty(key)) {
                if (this.tree[key]) {
                    throw new DuplicateChildComponentsError(key, 'Root');
                }
                this.tree[key] = tree[key];
            }
        }
    }
    getNodeAt(path) {
        return _get(this.tree, path.join('.children.'));
    }
    getNodeAtOrFail(path) {
        const node = this.getNodeAt(path);
        if (!node) {
            throw new ComponentNotFoundError(path);
        }
        return node;
    }
    /**
     * Find a node that matches the componentName relative to the node at relativeTo
     */
    getNodeRelativeTo(componentName, relativeTo = []) {
        var _a;
        const currentComponentNode = this.getNodeAt(relativeTo);
        const rootComponentNode = this.tree[componentName];
        const childComponentNode = (_a = currentComponentNode === null || currentComponentNode === void 0 ? void 0 : currentComponentNode.children) === null || _a === void 0 ? void 0 : _a[componentName];
        return childComponentNode || rootComponentNode;
    }
    getNodeRelativeToOrFail(componentName, relativeTo = []) {
        const componentNode = this.getNodeRelativeTo(componentName, relativeTo);
        if (!componentNode) {
            throw new ComponentNotFoundError([...relativeTo, componentName]);
        }
        return componentNode;
    }
    forEach(callback) {
        this.iterateNodes(Object.values(this.tree), callback);
    }
    iterateNodes(nodes, callback) {
        nodes.forEach((node) => {
            callback(node);
            const childNodes = Object.values(node.children || {});
            if (childNodes.length) {
                this.iterateNodes(childNodes, callback);
            }
        });
    }
    buildTreeForComponents(...components) {
        return components.reduce(ComponentTree.createComponentsToTreeReducer(this), {});
    }
}
//# sourceMappingURL=ComponentTree.js.map