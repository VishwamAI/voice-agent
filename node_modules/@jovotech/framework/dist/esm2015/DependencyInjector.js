import { MetadataStorage } from './metadata/MetadataStorage';
import { CircularDependencyError } from './errors/CircularDependencyError';
import { UnresolvableDependencyError } from './errors/UnresolvableDependencyError';
import { InvalidDependencyError } from './errors/InvalidDependencyError';
const INSTANTIATE_DEPENDENCY_MIDDLEWARE = 'event.DependencyInjector.instantiateDependency';
export class DependencyInjector {
    static resolveInjectionToken(jovo, token, dependencyPath) {
        var _a;
        if (dependencyPath.includes(token)) {
            throw new CircularDependencyError(dependencyPath);
        }
        const providers = [...jovo.$app.providers, ...jovo.$app.systemProviders];
        const updatedPath = [...dependencyPath, token];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const injection = providers.find((injection) => {
            if (typeof injection === 'function') {
                return injection === token;
            }
            else {
                return injection.provide === token;
            }
        });
        if (!injection) {
            return undefined;
        }
        if (typeof injection === 'function') {
            return DependencyInjector.instantiateClassWithTracing(jovo, injection, updatedPath);
        }
        else if ('useValue' in injection) {
            return {
                token,
                resolvedValue: injection.useValue,
                children: [],
            };
        }
        else if ('useFactory' in injection) {
            const value = injection.useFactory(jovo);
            return {
                token,
                resolvedValue: value,
                children: [],
            };
        }
        else if ('useClass' in injection) {
            const tree = DependencyInjector.instantiateClassWithTracing(jovo, injection.useClass, updatedPath);
            // insert proper token
            return Object.assign(Object.assign({}, tree), { token });
        }
        else if ('useExisting' in injection) {
            const tree = DependencyInjector.resolveInjectionToken(jovo, injection.useExisting, updatedPath);
            return {
                token,
                resolvedValue: tree === null || tree === void 0 ? void 0 : tree.resolvedValue,
                children: (_a = tree === null || tree === void 0 ? void 0 : tree.children) !== null && _a !== void 0 ? _a : [],
            };
        }
        else {
            return undefined;
        }
    }
    static instantiateClassWithTracing(jovo, clazz, dependencyPath, ...predefinedArgs) {
        var _a;
        const injectedArgs = [...predefinedArgs];
        const storage = MetadataStorage.getInstance();
        const injectMetadata = storage.getMergedInjectMetadata(clazz);
        const argTypes = (_a = Reflect.getMetadata('design:paramtypes', clazz)) !== null && _a !== void 0 ? _a : [];
        const children = [];
        for (let argumentIndex = predefinedArgs.length; argumentIndex < argTypes.length; argumentIndex++) {
            const injectMetadataForArg = injectMetadata.find((metadata) => metadata.index === argumentIndex);
            let injectionToken;
            if (injectMetadataForArg === null || injectMetadataForArg === void 0 ? void 0 : injectMetadataForArg.token) {
                injectionToken = injectMetadataForArg.token;
            }
            else {
                injectionToken = argTypes[argumentIndex];
            }
            if (!injectionToken) {
                // the argType will usually never be undefined. Even for interfaces or unknown, it will be the Object type.
                // Only when there is a circular import, the argType will be undefined.
                throw new InvalidDependencyError(clazz, argumentIndex);
            }
            const childNode = DependencyInjector.resolveInjectionToken(jovo, injectionToken, dependencyPath);
            if (!childNode) {
                throw new UnresolvableDependencyError(clazz, injectionToken, argumentIndex);
            }
            injectedArgs.push(childNode.resolvedValue);
            children.push(childNode);
        }
        const instance = new clazz(...injectedArgs);
        return {
            token: clazz,
            resolvedValue: instance,
            children,
        };
    }
    static async instantiateClass(jovo, clazz, ...predefinedArgs) {
        const tree = this.instantiateClassWithTracing(jovo, clazz, [], ...predefinedArgs);
        await jovo.$handleRequest.middlewareCollection.run(INSTANTIATE_DEPENDENCY_MIDDLEWARE, jovo, tree);
        return tree.resolvedValue;
    }
}
//# sourceMappingURL=DependencyInjector.js.map