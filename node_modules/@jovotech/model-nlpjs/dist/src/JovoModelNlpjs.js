"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JovoModelNlpjs = void 0;
const model_1 = require("@jovotech/model");
const REGEX_PREFIX = 'regex:';
class JovoModelNlpjs extends model_1.JovoModel {
    static toJovoModel(inputFiles) {
        const inputData = inputFiles[0].content;
        const jovoModel = {
            version: '4.0',
            invocation: '',
            intents: {},
            entityTypes: {},
        };
        if (inputData.data) {
            inputData.data.forEach((data) => {
                jovoModel.intents[data.intent] = {
                    phrases: data.utterances,
                };
            });
        }
        return jovoModel;
    }
    static fromJovoModel(model, locale) {
        var _a;
        const returnData = {
            data: [],
            name: '',
            locale,
        };
        const entitiesMap = {};
        if (model_1.JovoModelHelper.hasIntents(model)) {
            const intents = model_1.JovoModelHelper.getIntents(model);
            for (const [intentKey, intentData] of Object.entries(intents)) {
                const intentObj = {
                    intent: intentKey,
                    utterances: [],
                };
                if (model_1.JovoModelHelper.hasEntities(model, intentKey)) {
                    const entities = model_1.JovoModelHelper.getEntities(model, intentKey);
                    returnData.entities = {};
                    for (const [entityKey, entityData] of Object.entries(entities)) {
                        if (entityData.type && typeof entityData.type === 'string') {
                            entitiesMap[entityKey] = entityData.type;
                        }
                        else if (entityData.type &&
                            typeof entityData.type === 'object' &&
                            entityData.type.nlpjs) {
                            entitiesMap[entityKey] = entityData.type.nlpjs;
                        }
                    }
                }
                if (intentData.phrases) {
                    intentData.phrases.forEach((phrase) => {
                        const matches = phrase.match(/\{([^}]+)\}/g);
                        if (matches) {
                            matches.forEach((match) => {
                                const matchValue = match.replace('{', '').replace('}', '');
                                phrase = phrase.replace(match, `@${matchValue}`);
                            });
                        }
                        intentObj.utterances.push(phrase);
                    });
                }
                returnData.data.push(intentObj);
            }
        }
        if (model_1.JovoModelHelper.hasEntityTypes(model)) {
            returnData.entities = {};
            for (const [entityKey, entityTypeName] of Object.entries(entitiesMap)) {
                if (entityTypeName.startsWith(REGEX_PREFIX)) {
                    returnData.entities[entityKey] = entityTypeName.slice(REGEX_PREFIX.length);
                    continue;
                }
                const relatedEntityType = model_1.JovoModelHelper.getEntityTypeByName(model, entityTypeName);
                if (!((_a = relatedEntityType === null || relatedEntityType === void 0 ? void 0 : relatedEntityType.values) === null || _a === void 0 ? void 0 : _a.length)) {
                    continue;
                }
                const options = {};
                relatedEntityType.values.forEach((entityTypeValue) => {
                    if (typeof entityTypeValue === 'string') {
                        options[entityTypeValue] = [entityTypeValue];
                    }
                    else {
                        const key = entityTypeValue.value;
                        options[key] = [entityTypeValue.value];
                        if (entityTypeValue.synonyms) {
                            options[key] = options[key].concat(entityTypeValue.synonyms);
                        }
                    }
                });
                returnData.entities[entityKey] = {
                    options,
                };
            }
        }
        return [
            {
                path: [`${locale}.json`],
                content: returnData,
            },
        ];
    }
    static getValidator(model) {
        return super.getValidator(model);
    }
}
exports.JovoModelNlpjs = JovoModelNlpjs;
JovoModelNlpjs.MODEL_KEY = 'nlpjs';
//# sourceMappingURL=JovoModelNlpjs.js.map