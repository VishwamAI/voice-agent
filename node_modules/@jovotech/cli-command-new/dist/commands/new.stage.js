"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var NewStage_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.NewStage = void 0;
const cli_core_1 = require("@jovotech/cli-core");
const fs_1 = require("fs");
const latest_version_1 = __importDefault(require("latest-version"));
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const path_1 = require("path");
const prompts_1 = require("../prompts");
const utilities_1 = require("../utilities");
let NewStage = NewStage_1 = class NewStage extends cli_core_1.PluginCommand {
    install() {
        this.middlewareCollection = {
            'before.new:stage': [this.checkForExistingStage.bind(this)],
            'new:stage': [this.createNewStage.bind(this)],
        };
    }
    /**
     * Checks if a stage exists already.
     */
    async checkForExistingStage() {
        const appFileName = `app.${this.$context.args.stage}.ts`;
        if (fs_1.existsSync(path_1.join('src', appFileName))) {
            const { overwrite } = await cli_core_1.promptOverwrite(`Stage ${cli_core_1.printHighlight(this.$context.args.stage)} already exists. Do you want to overwrite it's files?`);
            if (overwrite === cli_core_1.ANSWER_CANCEL) {
                process.exit();
            }
        }
    }
    /**
     * Creates a new stage. Installs selected plugins and writes corresponding files.
     */
    async createNewStage() {
        const marketPlacePlugins = utilities_1.fetchMarketPlace();
        // Let the user choose between available server integrations.
        const servers = marketPlacePlugins
            .filter((plugin) => plugin.tags.includes('server'))
            .map((plugin) => ({
            title: cli_core_1.printUserInput(plugin.name),
            value: plugin,
            description: plugin.description,
        }));
        const { server } = await prompts_1.promptServer(servers);
        const serverFileName = server
            ? `server.${server.module.toLowerCase()}`
            : undefined;
        // Offer the user a range of plugins consisting of database and analytics plugins.
        const availableAppPlugins = marketPlacePlugins
            .filter((plugin) => plugin.tags.includes('databases') || plugin.tags.includes('analytics'))
            .map((plugin) => {
            return {
                title: cli_core_1.printUserInput(plugin.name),
                value: plugin,
                description: plugin.description,
            };
        });
        const { plugins: appPlugins } = await prompts_1.promptPlugins('Which framework plugins do you want to use?', availableAppPlugins);
        cli_core_1.Log.spacer();
        const stageTask = new cli_core_1.Task(`${cli_core_1.WRENCH} Creating new stage`);
        const installTask = new cli_core_1.Task('Installing plugins', async () => {
            const packageJson = require(path_1.resolve('package.json'));
            // Add plugins to package.json
            for (const plugin of appPlugins) {
                packageJson.dependencies[plugin.package] = await latest_version_1.default(plugin.package);
            }
            // Add selected server dependency to package.json
            if (server) {
                packageJson.dependencies[server.package] = await latest_version_1.default(server.package);
            }
            // Create new npm scripts
            const appPath = this.$cli.project.isTypeScriptProject()
                ? path_1.join('src', `app.${this.$context.args.stage}.ts`)
                : path_1.join('dist', `app.${this.$context.args.stage}.js`);
            if (this.$cli.project.isTypeScriptProject()) {
                packageJson.scripts[`start:${this.$context.args.stage}`] = `tsc-watch --onSuccess \"node ${appPath} --jovo-webhook\" --noClear`;
            }
            else {
                packageJson.scripts[`start:${this.$context.args.stage}`] = `nodemon --watch src --exec \"babel src --out-dir dist && node ${appPath} --jovo-webhook\"`;
            }
            packageJson.scripts[`bundle:${this.$context.args.stage}`] = `npm run bundle -- ${appPath}`;
            fs_1.writeFileSync('package.json', JSON.stringify(packageJson, null, 2));
            await utilities_1.runNpmInstall('./');
        });
        stageTask.add(installTask);
        // Create app.{stage}.ts.
        const appTask = new cli_core_1.Task(`Generating app.${this.$context.args.stage}.ts`, async () => {
            let stagedApp = fs_1.readFileSync(path_1.join('node_modules', '@jovotech', 'framework', 'boilerplate', 'app.stage.ts'), 'utf-8');
            const pluginsComment = '// Add Jovo plugins here';
            for (const plugin of appPlugins) {
                const loadedPlugin = utilities_1.loadPlugin(this.$cli.projectPath, plugin.package, plugin.module);
                const initConfig = await utilities_1.getFormattedPluginInitConfig(loadedPlugin);
                stagedApp = utilities_1.insert(`import { ${plugin.module} } from '${plugin.package}'\n`, stagedApp, 0);
                stagedApp = utilities_1.insert(`\n\t\tnew ${plugin.module}(${initConfig}),`, stagedApp, stagedApp.indexOf(pluginsComment) + pluginsComment.length);
            }
            stagedApp = utilities_1.insert(`\nexport * from './${serverFileName}';\n`, stagedApp, stagedApp.length);
            fs_1.writeFileSync(path_1.join('src', `app.${this.$context.args.stage}.ts`), stagedApp);
            await cli_core_1.wait(500);
        });
        stageTask.add(appTask);
        await stageTask.run();
        const serverFilePath = server
            ? path_1.join('src', `${serverFileName}.ts`)
            : undefined;
        cli_core_1.Log.verbose(serverFilePath);
        if (serverFilePath) {
            if (fs_1.existsSync(serverFilePath)) {
                cli_core_1.Log.spacer();
                const { overwrite } = await cli_core_1.promptOverwrite(`${serverFilePath} already exists. Do you want to overwrite it?`);
                if (overwrite === cli_core_1.ANSWER_CANCEL) {
                    return;
                }
            }
            fs_1.copyFileSync(path_1.join('node_modules', server.package, 'boilerplate', `${serverFileName}.ts`), serverFilePath);
        }
    }
    async run() {
        cli_core_1.Log.spacer();
        cli_core_1.Log.info(`jovo new:stage: ${NewStage_1.description}`);
        cli_core_1.Log.info(cli_core_1.printSubHeadline('Learn more: https://jovo.tech/docs/new-command#new-stage'));
        cli_core_1.Log.spacer();
        const { args, flags } = this.parse(NewStage_1);
        lodash_merge_1.default(this.$context, { args, flags });
        await this.$emitter.run('before.new:stage');
        await this.$emitter.run('new:stage');
        await this.$emitter.run('after.new:stage');
        cli_core_1.Log.spacer();
        cli_core_1.Log.info(`${cli_core_1.TADA} Successfully created a new stage.`);
        cli_core_1.Log.spacer();
    }
};
NewStage.id = 'new:stage';
NewStage.description = 'Create a new stage';
NewStage.examples = [];
// Defines arguments that can be passed to the command.
NewStage.args = [
    {
        name: 'stage',
        description: 'Name of the stage.',
        required: true,
    },
];
NewStage = NewStage_1 = __decorate([
    cli_core_1.ProjectCommand()
], NewStage);
exports.NewStage = NewStage;
//# sourceMappingURL=new.stage.js.map