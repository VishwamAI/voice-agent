"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var New_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.New = void 0;
const cli_core_1 = require("@jovotech/cli-core");
const fs_1 = require("fs");
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const lodash_pick_1 = __importDefault(require("lodash.pick"));
const path_1 = require("path");
const prompts_1 = require("../prompts");
const TemplateBuilder = __importStar(require("../TemplateBuilder"));
const utilities_1 = require("../utilities");
let New = New_1 = class New extends cli_core_1.PluginCommand {
    static install(cli, plugin, emitter) {
        // Override PluginCommand.install() to fill options for --platform.
        this.availablePresets.push(...cli.userConfig.getPresets().map((preset) => preset.name));
        super.install(cli, plugin, emitter);
    }
    async run() {
        const { args, flags } = this.parse(New_1);
        cli_core_1.Log.spacer();
        cli_core_1.Log.info(`jovo new: ${New_1.description}`);
        cli_core_1.Log.info(cli_core_1.printSubHeadline('Learn more: https://jovo.tech/docs/new-command'));
        cli_core_1.Log.spacer();
        let preset;
        if (!flags['preset']) {
            cli_core_1.Log.info(`${cli_core_1.CRYSTAL_BALL} Welcome to the Jovo CLI Wizard`);
            cli_core_1.Log.spacer();
            try {
                const { selectedPreset } = await prompts_1.promptPreset(this.$cli.userConfig.getPresets());
                if (selectedPreset === 'manual') {
                    // Manually select project properties.
                    const options = await prompts_1.promptProjectProperties(args, flags);
                    preset = Object.assign({ name: '' }, options);
                    const { savePreset } = await prompts_1.promptSavePreset();
                    if (savePreset) {
                        const { presetName } = await prompts_1.promptPresetName();
                        preset.name = presetName;
                        await this.$cli.userConfig.savePreset(preset);
                    }
                }
                else {
                    preset = this.$cli.userConfig.getPreset(selectedPreset);
                }
            }
            catch (error) {
                if (!cli_core_1.isJovoCliError(error)) {
                    throw new cli_core_1.JovoCliError({
                        message: error.message,
                        module: this.$plugin.constructor.name,
                    });
                }
                throw error;
            }
        }
        else if (flags.preset) {
            preset = this.$cli.userConfig.getPreset(flags.preset);
        }
        lodash_merge_1.default(this.$context, {
            args,
            flags,
            projectName: '',
            language: flags.language || 'typescript',
            linter: false,
            unitTesting: false,
            locales: flags.locale || ['en'],
            platforms: [],
        });
        // Merge preset's project properties with context object.
        if (preset) {
            const contextPreset = lodash_pick_1.default(preset, Object.keys(this.$context));
            lodash_merge_1.default(this.$context, contextPreset);
        }
        // If project name is explicitly provided, overwrite it
        if (args.directory) {
            this.$context.projectName = args.directory;
        }
        // Directory is mandatory, so throw an error if omitted.
        if (!this.$context.projectName) {
            throw new cli_core_1.JovoCliError({
                message: 'Please provide a directory.',
                module: this.$plugin.constructor.name,
                learnMore: 'For more information, run "jovo new --help".',
            });
        }
        // Check if provided directory already exists, if so, prompt for overwrite.
        if (this.$cli.hasExistingProject(this.$context.projectName)) {
            if (!flags.clean) {
                const { overwrite } = await cli_core_1.promptOverwrite(`The directory ${cli_core_1.printHighlight(this.$context.projectName)} already exists. What would you like to do?`);
                if (overwrite === cli_core_1.ANSWER_CANCEL) {
                    process.exit();
                }
            }
            cli_core_1.deleteFolderRecursive(path_1.join(process.cwd(), this.$context.projectName));
        }
        cli_core_1.Log.spacer();
        cli_core_1.Log.info(`${cli_core_1.WRENCH} Setting everything up`);
        cli_core_1.Log.spacer();
        const newTask = new cli_core_1.Task(`Creating new directory ${cli_core_1.printHighlight(this.$context.projectName)}/`, () => {
            if (!fs_1.existsSync(this.$context.projectName)) {
                fs_1.mkdirSync(this.$context.projectName);
            }
            return path_1.join(this.$cli.projectPath, this.$context.projectName);
        });
        await newTask.run();
        const downloadTask = new cli_core_1.Task('Downloading and extracting template', async () => {
            try {
                await utilities_1.downloadTemplate(this.$context.projectName, this.$context.language);
            }
            catch (error) {
                throw new cli_core_1.JovoCliError({
                    message: 'Could not download template.',
                    module: this.$plugin.constructor.name,
                });
            }
        });
        await downloadTask.run();
        // Modify package.json to include plugins and omit not needed packages, depending on configuration.
        const generatePackageJsonTask = new cli_core_1.Task('Generating package.json', async () => {
            await TemplateBuilder.modifyDependencies(this.$context);
        });
        await generatePackageJsonTask.run();
        // Install npm dependencies
        const installNpmTask = new cli_core_1.Task('Installing npm dependencies', async () => await utilities_1.runNpmInstall(path_1.join(this.$cli.projectPath, this.$context.projectName)));
        await installNpmTask.run();
        // For each selected CLI plugin, load the plugin from node_modules/ to let it potentially hook into the EventEmitter.
        // This allows the plugin to do some configuration on creating a new project, such as generating an initial config
        // based on the current context.
        for (const platform of this.$context.platforms) {
            if (!platform.cliModule) {
                continue;
            }
            // Load and instantiate the respective CLI plugin.
            const plugin = utilities_1.loadPlugin(this.$context.projectName, platform.package, platform.cliModule);
            plugin.install(this.$cli, this.$emitter, this.$context);
            platform.cliPlugin = plugin;
        }
        await this.$emitter.run('new');
        TemplateBuilder.copyModels(this.$context);
        const generateAppConfigTask = new cli_core_1.Task('Building configuration', async () => {
            await TemplateBuilder.generateProjectConfiguration(this.$context);
            await TemplateBuilder.generateAppConfiguration(this.$context);
        });
        await generateAppConfigTask.run();
        cli_core_1.Log.spacer();
        cli_core_1.Log.info(`${cli_core_1.TADA} Successfully created your project!`);
        cli_core_1.Log.spacer();
        if (!this.$cli.userConfig.cli.omitHints) {
            cli_core_1.Log.info(`${cli_core_1.BULB} To run your Jovo project, use the following commands:`);
            cli_core_1.Log.info(cli_core_1.chalk.dim(`$ cd ${this.$context.projectName}`), { indent: 3 });
            cli_core_1.Log.info(cli_core_1.chalk.dim('$ jovo run'), { indent: 3 });
            cli_core_1.Log.spacer();
        }
    }
};
New.id = 'new';
New.description = 'Create a new Jovo project';
New.examples = ['jovo new helloworld', 'jovo new --preset default'];
New.availablePresets = [];
New.flags = Object.assign({ locale: cli_core_1.flags.string({
        char: 'l',
        description: 'The locales to be created',
        multiple: true,
    }), language: cli_core_1.flags.string({
        description: 'Specifies the code language of your project',
        options: cli_core_1.SUPPORTED_LANGUAGES,
    }), preset: cli_core_1.flags.string({
        description: 'Selects a preconfigured preset from the wizard without going through the selection process',
        options: New_1.availablePresets,
    }), clean: cli_core_1.flags.boolean({
        description: 'Forces overwriting an existing project',
    }) }, cli_core_1.PluginCommand.flags);
// Defines arguments that can be passed to the command.
New.args = [
    {
        name: 'directory',
        description: 'Project directory',
        parse(directory) {
            if (directory && !/^[0-9a-zA-Z-_]+$/.test(directory)) {
                cli_core_1.Log.info('Please use a valid directory name.');
                process.exit();
            }
            return directory;
        },
    },
];
New = New_1 = __decorate([
    cli_core_1.GlobalCommand()
], New);
exports.New = New;
//# sourceMappingURL=new.js.map