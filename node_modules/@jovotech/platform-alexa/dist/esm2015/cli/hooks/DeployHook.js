import { bundleProject, loadProject, loadProjectConfig, validateProject, } from '@alexa/acdl';
import { chalk, flags, isJovoCliError, JovoCliError, Log, printStage, ROCKET, Task, wait, } from '@jovotech/cli-core';
import { axios } from '@jovotech/framework';
import AdmZip from 'adm-zip';
import { existsSync } from 'fs';
import _get from 'lodash.get';
import { join as joinPaths } from 'path';
import * as smapi from '../smapi';
import { checkForAskCli, getACValidationErrorHint } from '../utilities';
import { AlexaHook } from './AlexaHook';
export class DeployHook extends AlexaHook {
    install() {
        this.middlewareCollection = {
            'install': [this.addCliOptions.bind(this)],
            'before.deploy:platform': [
                this.checkForPlatform.bind(this),
                checkForAskCli,
                this.updatePluginContext.bind(this),
                this.checkForPlatformsFolder.bind(this),
                this.updatePluginContext.bind(this),
            ],
            'deploy:platform': [this.deploy.bind(this)],
        };
    }
    /**
     * Add platform-specific CLI options, including flags and args.
     * @param context - Context providing an access point to command flags and args.
     */
    addCliOptions(context) {
        if (context.command !== 'deploy:platform') {
            return;
        }
        context.flags['ask-profile'] = flags.string({
            description: 'Name of used ASK profile',
        });
        context.flags['skill-id'] = flags.string({ char: 's', description: 'Alexa skill ID' });
        context.flags.async = flags.boolean({ description: 'Deploys Alexa skill asynchronously' });
        context.flags['skip-validation'] = flags.boolean({
            description: 'Skips validation of Alexa Conversations files',
        });
    }
    /**
     * Checks if the currently selected platform matches this CLI plugin.
     */
    checkForPlatform() {
        // Check if this plugin should be used or not.
        if (!this.$context.platforms.includes(this.$plugin.id)) {
            this.uninstall();
        }
    }
    /**
     * Updates the current plugin context with platform-specific values.
     */
    async updatePluginContext() {
        var _a;
        super.updatePluginContext();
        this.$context.alexa.askProfile =
            this.$context.flags['ask-profile'] ||
                this.$plugin.config.askProfile ||
                (await this.getAskProfile()) ||
                'default';
        this.$context.alexa.skillId = this.$context.flags['skill-id'] || this.getSkillId();
        // TODO: this.$plugin.config.convertsations.enabled enough?
        this.$context.alexa.isACSkill =
            ((_a = this.$plugin.config.conversations) === null || _a === void 0 ? void 0 : _a.enabled) && existsSync(this.$plugin.conversationsDirectory);
    }
    /**
     * Checks if the platform folder for the current plugin exists.
     */
    checkForPlatformsFolder() {
        if (!existsSync(this.$plugin.platformPath)) {
            throw new JovoCliError({
                message: `Couldn't find the platform folder "${this.$plugin.platformDirectory}/".`,
                module: this.$plugin.name,
                hint: `Please use "jovo build" to create platform-specific files.`,
            });
        }
    }
    /**
     * Deploys platform-specific models to the Alexa Skills Console.
     */
    async deploy() {
        var _a;
        const deployTask = new Task(`${ROCKET} Deploying Alexa Skill ${printStage(this.$cli.project.stage)}`);
        if (this.$context.alexa.isACSkill) {
            const projectConfig = await loadProjectConfig(this.$plugin.platformPath, this.$context.alexa.askProfile);
            const project = await loadProject(projectConfig);
            if (!this.$context.flags['skip-validation'] &&
                !((_a = this.$plugin.config.conversations) === null || _a === void 0 ? void 0 : _a.skipValidation)) {
                const validationTask = new Task('Validating ACDL files', async () => {
                    const errors = validateProject(project, true);
                    if (errors.length) {
                        throw new JovoCliError({
                            message: 'Validation failed for Alexa Conversations',
                            module: this.$plugin.name,
                            hint: getACValidationErrorHint(errors),
                        });
                    }
                    await wait(500);
                });
                deployTask.add(validationTask);
            }
            const compileTask = new Task('Compiling ACDL files', async () => {
                await bundleProject(project, { outDir: joinPaths(this.$plugin.skillPackagePath, 'build') });
                await wait(1000);
            });
            deployTask.add(compileTask);
        }
        const uploadTask = new Task('Uploading skill package', async () => {
            // Deployment is done by compressing the skill-package and importing it into the developer console.
            // Depending on whether the current skill uses Alexa Conversations or not, the location of the
            // skill package changes.
            const zipPath = this.$context.alexa.isACSkill
                ? joinPaths(this.$plugin.skillPackagePath, 'build', 'skill-package')
                : this.$plugin.skillPackagePath;
            // Compress skill package
            const zip = new AdmZip();
            zip.addLocalFolder(zipPath);
            const uploadUrl = await smapi.createNewUploadUrl(this.$context.alexa.askProfile);
            await axios({ url: uploadUrl, method: 'PUT', data: zip.toBuffer() });
            const importId = this.$context.alexa.skillId
                ? await smapi.importSkillPackage(uploadUrl, this.$context.alexa.skillId, this.$context.alexa.askProfile)
                : await smapi.createSkillPackage(uploadUrl, this.$context.alexa.askProfile);
            if (!importId) {
                throw new JovoCliError({
                    message: 'Something went wrong while importing your skill package',
                    // TODO: Command!
                    hint: 'Try importing your skill package manually using the ASK CLI and copy the resulting skill ID into your project configuration',
                });
            }
            this.$context.alexa.importId = importId;
            // requesting import status right away sometimes leads to no skill info being returned
            if (this.$context.flags.async)
                await wait(3000);
            // Check import status
            const status = await smapi.getImportStatus(importId, this.$context.alexa.askProfile, this.$context.flags.async);
            const skillId = status.skill.skillId;
            this.$context.alexa.skillId = skillId;
            this.setSkillId(skillId);
            return `Skill ID: ${skillId}`;
        });
        deployTask.add(uploadTask);
        if (!this.$context.flags.async) {
            const validateUploadTask = new Task('Validating upload', async () => {
                await smapi.getSkillStatus(this.$context.alexa.skillId, this.$context.alexa.askProfile);
                await smapi.enableSkill(this.$context.alexa.skillId, 'development', this.$context.alexa.askProfile);
            });
            deployTask.add(validateUploadTask);
        }
        await deployTask.run();
        if (this.$context.flags.async) {
            Log.spacer();
            Log.warning('This is an asynchronous process. You can check the status of your skill package import using the following command:');
            Log.info(chalk.dim(`$ ask smapi get-import-status --import-id ${this.$context.alexa.importId}`), {
                indent: 2,
            });
        }
    }
    /**
     * Returns Alexa Skill ID from .ask/config.
     */
    getSkillId() {
        try {
            const askConfig = this.getAskConfig();
            const askProfile = this.$context.alexa.askProfile || 'default';
            const skillId = _get(askConfig, `profiles.${askProfile}.skillId`, '');
            if (skillId && skillId.length > 0) {
                return skillId;
            }
        }
        catch (error) {
            if (!isJovoCliError(error)) {
                throw new JovoCliError({ message: error.message, module: this.$plugin.name });
            }
            throw error;
        }
    }
    /**
     * Returns skill information.
     */
    getSkillInformation() {
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const skillJson = require(this.$plugin.skillJsonPath);
            const info = {
                name: '',
                skillId: this.getSkillId(),
            };
            const locales = _get(skillJson, 'manifest.publishingInformation.locales', []);
            for (const locale of Object.keys(locales)) {
                info.name += locales[locale].name + ' (' + locale + ') ';
            }
            return info;
        }
        catch (err) {
            throw new JovoCliError({ message: err.message, module: this.$plugin.name });
        }
    }
    /**
     * Returns the skill's invocation name.
     * @param locale - The locale for which to get the invocation name.
     */
    getInvocationName(locale) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const alexaModel = require(this.$plugin.getModelPath(locale));
        return _get(alexaModel, 'interactionModel.languageModel.invocationName');
    }
}
//# sourceMappingURL=DeployHook.js.map