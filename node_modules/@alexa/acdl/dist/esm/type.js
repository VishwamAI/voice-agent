var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Type_environment, _Type_extensions, _Type_properties, _Type_propertiesIndex, _Type_locales;
import * as ask from "./ast";
import { Apply } from "./apply";
import { ActionTypeName, AlexaConversations, AlexaConversationsNamespace, AlexaSchema, AlexaSchemaNamespace, BuiltinsNamespace, DialogTypeName, SlotTypesNamespace, } from "./ast";
import { getName, getNamespace } from "./util";
import { ActionThing, AnyThing, ArgumentsThing, ArgumentThing, BooleanThing, DialogThing, FunctionThing, ListThing, NothingThing, NumberThing, ObjectThing, StringThing, VoidThing, } from "./thing";
import { visitEachChildType } from "./visit";
export function isType(obj) {
    return (obj === null || obj === void 0 ? void 0 : obj.kind) === "Type";
}
/**
 * A Type represents an instantiated Type in some context.
 *
 * Any `genericArguments` are either explicitly substituted or inferred from the surrounding context.
 *
 * This class provides a lazily-evaluated API for querying properties of the type.
 */
export class Type {
    constructor(checker, 
    /**
     * Declaration of the instantiated type.
     */
    declaration, 
    /**
     * Instantiated type arguments.
     */
    genericArguments, 
    /**
     * Source node of this Type.
     */
    // readonly source?: ask.Node,
    functionArgumentNames, 
    /**
     * Name of the function (if this is an abstract function signature)
     */
    functionName) {
        Object.defineProperty(this, "checker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: checker
        });
        Object.defineProperty(this, "declaration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: declaration
        });
        Object.defineProperty(this, "genericArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: genericArguments
        });
        Object.defineProperty(this, "functionArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: functionArgumentNames
        });
        Object.defineProperty(this, "functionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: functionName
        });
        Object.defineProperty(this, "kind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Type"
        });
        // cache lazily evaluated environment - use `null` to indicate "cached, but empty".
        _Type_environment.set(this, void 0);
        // cache lazily evaluated list of base types - use `null` to indicate "cached, but empty".
        _Type_extensions.set(this, void 0);
        // cache lazily evaluated properties - use `null` to indicate "cached, but empty".
        _Type_properties.set(this, void 0);
        // cache lazily evaluated property index - use `null` to indicate "cached, but empty".
        _Type_propertiesIndex.set(this, void 0);
        // cache lazily evaluated properties - use `null` to indicate "cached, but empty".
        _Type_locales.set(this, void 0);
    }
    /**
     * String representation of this Type.
     */
    toString(context) {
        var _a, _b, _c, _d;
        const inScope = context ? this.checker.lookupName(context, this.shortName) : undefined;
        const name = (inScope === null || inScope === void 0 ? void 0 : inScope.kind) === "TypeDeclaration" && ((_a = inScope.name) === null || _a === void 0 ? void 0 : _a.name) && inScope.name.name === ((_b = this.name) === null || _b === void 0 ? void 0 : _b.name) ? this.shortName : (_c = this.name) === null || _c === void 0 ? void 0 : _c.name;
        if (this.isFunctionN() && this.functionArgumentNames !== undefined) {
            const prefix = this.isAction() ? "action" : this.isDialog() ? "dialog" : "function";
            return `${prefix} ${(_d = this.getFunctionReturnType()) === null || _d === void 0 ? void 0 : _d.toString()}${this.functionName ? ` ${this.functionName}` : ""}(${this.functionArgumentNames
                .map((name, i) => {
                let argType = this.getFunctionArgumentType(i);
                const isOptional = (argType === null || argType === void 0 ? void 0 : argType.isOptional()) === true;
                if (argType === null || argType === void 0 ? void 0 : argType.isOptional()) {
                    while (argType === null || argType === void 0 ? void 0 : argType.isOptional()) {
                        argType = argType.getOptionalType();
                    }
                }
                return `${isOptional ? "optional " : ""}${argType === null || argType === void 0 ? void 0 : argType.toString()} ${name}`;
            })
                .join(", ")})`;
        }
        return `${name}${this.genericArguments ? `<${this.genericArguments.map((a) => a === null || a === void 0 ? void 0 : a.toString(context)).join(", ")}>` : ""}`;
    }
    toTypeReference(context) {
        var _a;
        const ref = new ask.TypeReference(this.name, (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a.map((arg) => arg === null || arg === void 0 ? void 0 : arg.toTypeReference()), undefined, undefined);
        if (context) {
            ref.context = context;
        }
        return ref;
    }
    get shortName() {
        var _a, _b, _c;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) ? getName((_c = this.declaration.name) === null || _c === void 0 ? void 0 : _c.name) : undefined;
    }
    /**
     * Name of this Type.
     */
    get name() {
        var _a;
        return (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name;
    }
    get namespace() {
        var _a, _b;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) ? getNamespace((_b = this.name) === null || _b === void 0 ? void 0 : _b.name) : undefined;
    }
    /**
     * The type environment of this Type.
     *
     * Maps type aliases for Type Parameters to instantiated Types.
     */
    get environment() {
        var _a, _b;
        if (__classPrivateFieldGet(this, _Type_environment, "f") === undefined) {
            if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeDeclaration") {
                const genericArguments = this.declaration.genericArguments || [];
                __classPrivateFieldSet(this, _Type_environment, ((_b = this.genericArguments) === null || _b === void 0 ? void 0 : _b.map((arg, i) => {
                    var _a, _b;
                    const name = (_b = (_a = genericArguments === null || genericArguments === void 0 ? void 0 : genericArguments[i]) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name;
                    return name === undefined
                        ? {}
                        : {
                            [name]: arg,
                        };
                }).reduce((a, b) => ({ ...a, ...b }), {})) || null, "f");
            }
        }
        return __classPrivateFieldGet(this, _Type_environment, "f") || undefined;
    }
    /**
     * Ordered list of this Type's base types (the types it "extends").
     */
    get extensions() {
        var _a, _b;
        if (__classPrivateFieldGet(this, _Type_extensions, "f") === undefined) {
            __classPrivateFieldSet(this, _Type_extensions, (_a = this.resolveExtensions()) !== null && _a !== void 0 ? _a : null, "f");
        }
        return (_b = __classPrivateFieldGet(this, _Type_extensions, "f")) !== null && _b !== void 0 ? _b : undefined;
    }
    resolveExtensions() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        // instantiate the base types
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "SlotType") {
            // Beta 1 loads Slot Types from the interaction model - they always extend string.
            return [this.checker.string];
        }
        if (((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" || ((_c = this.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "DialogDeclaration") {
            const actionArity = (_e = (_d = this.declaration.arguments) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0;
            const typeArgs = [
                ...((_g = (_f = this.declaration.arguments) === null || _f === void 0 ? void 0 : _f.map((arg) => this.checker.getType(arg.type))) !== null && _g !== void 0 ? _g : []),
                this.checker.getType(this.declaration.returnType),
            ];
            const actionType = this.checker.instantiateTypeDeclaration(this.checker.lookupTypeDeclaration(((_h = this.declaration) === null || _h === void 0 ? void 0 : _h.kind) === "ActionDeclaration" ? ActionTypeName(actionArity) : DialogTypeName(actionArity)), typeArgs);
            if (actionType) {
                return [actionType];
            }
            return [this.checker.nothing];
        }
        if (((_j = this.declaration) === null || _j === void 0 ? void 0 : _j.kind) === "EnumDeclaration") {
            return [this.checker.enumeration()];
        }
        if (((_k = this.declaration) === null || _k === void 0 ? void 0 : _k.kind) === "EnumItemDeclaration") {
            const enumType = this.checker.getType(this.declaration.context);
            if (enumType) {
                return [enumType];
            }
        }
        else if (((_l = this.declaration) === null || _l === void 0 ? void 0 : _l.kind) === "TypeDeclaration" || ((_m = this.declaration) === null || _m === void 0 ? void 0 : _m.kind) === "TypeParameter") {
            const extensions = this.declaration.kind === "TypeDeclaration"
                ? this.declaration.extensions
                : this.declaration.kind === "TypeParameter"
                    ? this.declaration.constraints
                    : undefined;
            if (extensions) {
                return extensions.map((extension) => {
                    var _a;
                    // map the input typeArgs to the base-type's arguments
                    const extEnv = ((_a = extension.arguments) === null || _a === void 0 ? void 0 : _a.map((arg) => {
                        var _a;
                        return ({
                            [(_a = arg === null || arg === void 0 ? void 0 : arg.name) === null || _a === void 0 ? void 0 : _a.name]: this.checker.instantiateTypeReference(arg, this.environment),
                        });
                    }).reduce((a, b) => ({ ...a, ...b }), {})) || undefined;
                    return this.checker.instantiateTypeReference(extension, extEnv);
                });
            }
            if (((_o = this.declaration.name) === null || _o === void 0 ? void 0 : _o.name) !== AlexaSchema.Nothing && ((_p = this.declaration.name) === null || _p === void 0 ? void 0 : _p.name) !== AlexaSchema.Thing) {
                return [this.checker.thing];
            }
        }
        else {
            return [this.checker.nothing];
        }
        return undefined;
    }
    /**
     * Ordered list of all Properties in this Type.
     *
     * @returns list of properties if any, `null` otherwise.
     */
    get properties() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
        if (__classPrivateFieldGet(this, _Type_properties, "f") !== undefined) {
            return __classPrivateFieldGet(this, _Type_properties, "f");
        }
        const properties = [];
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "EnumItemDeclaration") {
            // enum item has no properties, this will change when we support values https://github.com/alexa/ask-ac/issues/198
        }
        else if (((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" || ((_c = this.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "DialogDeclaration" || this.isFunctionN()) {
            const typeType = this.checker.lookupTypeDeclaration(AlexaSchema.Type);
            const actionType = this.checker.lookupTypeDeclaration(AlexaConversations.Action);
            const argumentsType = this.checker.lookupTypeDeclaration(AlexaSchema.Arguments);
            const returnType = (_d = this.getFunctionReturnType()) !== null && _d !== void 0 ? _d : this.checker.thing;
            if (actionType && typeType && returnType) {
                properties.push({
                    kind: "Property",
                    index: 0,
                    name: "arguments",
                    type: new Type(this.checker, argumentsType, [this]),
                }, {
                    kind: "Property",
                    index: 1,
                    name: "returnType",
                    type: this.checker.instantiateTypeDeclaration(typeType, [returnType]),
                });
            }
        }
        else if (((_e = this.declaration) === null || _e === void 0 ? void 0 : _e.kind) === "TypeDeclaration") {
            if (((_f = this.declaration.name) === null || _f === void 0 ? void 0 : _f.name) === AlexaSchema.Type) {
                // this is the intrinsic `Type<T>` type that has varying behavior based on what type it references.
                const type = (_g = this.genericArguments) === null || _g === void 0 ? void 0 : _g[0];
                if (type) {
                    if (((_h = type.declaration) === null || _h === void 0 ? void 0 : _h.kind) === "EnumDeclaration") {
                        (_j = type.declaration.items) === null || _j === void 0 ? void 0 : _j.forEach((item, index) => {
                            var _a, _b;
                            if ((_a = item.name) === null || _a === void 0 ? void 0 : _a.name) {
                                properties.push({
                                    kind: "Property",
                                    index,
                                    name: (_b = item.name) === null || _b === void 0 ? void 0 : _b.name,
                                    declaration: item,
                                    type: this.checker.getType(item),
                                });
                            }
                        });
                    }
                    else {
                        const propertiesType = this.checker.lookupTypeDeclaration(AlexaSchema.Properties);
                        if (propertiesType) {
                            properties.push({
                                kind: "Property",
                                index: 0,
                                name: "properties",
                                type: new Type(this.checker, propertiesType, [type]),
                            });
                        }
                    }
                }
            }
            else if (((_k = this.declaration.name) === null || _k === void 0 ? void 0 : _k.name) === AlexaSchema.Properties || ((_l = this.declaration.name) === null || _l === void 0 ? void 0 : _l.name) === AlexaSchema.ArgumentProperties) {
                const property = ((_m = this.declaration.name) === null || _m === void 0 ? void 0 : _m.name) === AlexaSchema.Properties ? AlexaSchema.Property : AlexaSchema.ArgumentProperty;
                const typeType = this.checker.lookupTypeDeclaration(AlexaSchema.Type);
                const propType = this.checker.lookupTypeDeclaration(property);
                const type = (_o = this.genericArguments) === null || _o === void 0 ? void 0 : _o[0];
                if (typeType && propType && (type === null || type === void 0 ? void 0 : type.properties) !== undefined) {
                    properties.push(...type.properties.map((prop) => ({
                        ...prop,
                        type: this.checker.instantiateTypeDeclaration(propType, [prop.type]),
                        declaration: undefined,
                    })));
                }
            }
            else if (((_p = this.declaration.name) === null || _p === void 0 ? void 0 : _p.name) === AlexaConversations.ActionContextValues ||
                ((_q = this.declaration.name) === null || _q === void 0 ? void 0 : _q.name) === AlexaSchema.ArgumentValues ||
                ((_r = this.declaration.name) === null || _r === void 0 ? void 0 : _r.name) === AlexaSchema.Arguments) {
                // Arguments<F>, ArgumentValues<F> and ActionContextValues<A> all compute a type based on the arguments
                const targetType = (_s = this.genericArguments) === null || _s === void 0 ? void 0 : _s[0];
                const containerType = ((_t = this.declaration.name) === null || _t === void 0 ? void 0 : _t.name) === AlexaConversations.ActionContextValues
                    ? this.checker.lookupTypeDeclaration(AlexaSchema.Optional)
                    : this.declaration.name.name === AlexaSchema.Arguments
                        ? this.checker.lookupTypeDeclaration(AlexaSchema.Argument)
                        : undefined;
                properties.push(...((_v = (_u = targetType === null || targetType === void 0 ? void 0 : targetType.getFunctionArgumentDeclarations()) === null || _u === void 0 ? void 0 : _u.map((arg, index) => {
                    var _a, _b, _c, _d;
                    const innerType = this.checker.instantiateTypeReference(arg.type);
                    const prop = {
                        kind: "Property",
                        index,
                        name: (_a = arg.name) === null || _a === void 0 ? void 0 : _a.name,
                        type: ((_b = containerType === null || containerType === void 0 ? void 0 : containerType.name) === null || _b === void 0 ? void 0 : _b.name) === AlexaSchema.Optional && (innerType === null || innerType === void 0 ? void 0 : innerType.isOptional())
                            ? innerType
                            : containerType
                                ? this.checker.instantiateTypeDeclaration(containerType, [innerType])
                                : ((_d = (_c = this.declaration) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name) === AlexaSchema.ArgumentValues
                                    ? innerType
                                    : undefined,
                        declaration: arg,
                    };
                    return prop;
                })) !== null && _v !== void 0 ? _v : []));
            }
            else if (((_w = this.declaration.name) === null || _w === void 0 ? void 0 : _w.name) === AlexaSchema.Optional) {
                // Optional<T> type would contain all the properties of `T`.
                const argumentType = (_x = this.genericArguments) === null || _x === void 0 ? void 0 : _x[0];
                if (argumentType && argumentType.properties) {
                    properties.push(...argumentType.properties);
                }
            }
            else {
                properties.push(...(((_z = (_y = this.declaration) === null || _y === void 0 ? void 0 : _y.properties) === null || _z === void 0 ? void 0 : _z.map((prop, index) => {
                    var _a;
                    let type = prop.type !== undefined ? this.checker.instantiateTypeReference(prop.type, this.environment) : undefined;
                    if (prop.optional === true && (type === null || type === void 0 ? void 0 : type.isOptional()) === false) {
                        const optionalType = this.checker.lookupTypeDeclaration(AlexaSchema.Optional);
                        if (optionalType) {
                            type = this.checker.instantiateTypeDeclaration(optionalType, [type]);
                        }
                    }
                    return {
                        kind: "Property",
                        declaration: prop,
                        index,
                        name: (_a = prop.name) === null || _a === void 0 ? void 0 : _a.name,
                        type,
                    };
                })) || []));
            }
        }
        const seen = new Set();
        const _properties = [];
        addProperties(properties);
        if (this.extensions) {
            for (const ext of this.extensions) {
                if (ext === null || ext === void 0 ? void 0 : ext.properties) {
                    addProperties(ext.properties);
                }
            }
        }
        __classPrivateFieldSet(this, _Type_properties, _properties || null, "f");
        return __classPrivateFieldGet(this, _Type_properties, "f") || undefined;
        function addProperties(properties) {
            if (properties) {
                for (const property of properties) {
                    if (!seen.has(property.name)) {
                        _properties.push(property);
                        seen.add(property.name);
                    }
                }
            }
        }
    }
    /**
     * Index of all Properties by name.
     */
    get propertiesIndex() {
        var _a;
        if (__classPrivateFieldGet(this, _Type_propertiesIndex, "f") === undefined) {
            __classPrivateFieldSet(this, _Type_propertiesIndex, ((_a = this.properties) === null || _a === void 0 ? void 0 : _a.map((p) => ({
                [p.name]: p,
            })).reduce((a, b) => ({ ...a, ...b }), {})) || null, "f");
        }
        return __classPrivateFieldGet(this, _Type_propertiesIndex, "f") || undefined;
    }
    /**
     * Apply a Call to this Type.
     *
     *
     * @param call expression of input to the Action.
     */
    apply(call, checker = this.checker) {
        return new Apply(checker, call, this);
    }
    /**
     * Instantiate a new Thing of this Type.
     *
     * @param node AST node this Thing value originates from.
     * @returns a Thing instance representing this distinct Thing
     */
    getThing(token, origin, parent, apply) {
        var _a;
        // use the environment of the Application or default to this environment
        const checker = (_a = apply === null || apply === void 0 ? void 0 : apply.checker) !== null && _a !== void 0 ? _a : this.checker;
        if (this.isPrimitive()) {
            if (this.isStringLike()) {
                return new StringThing(checker, token, this, apply, origin, parent);
            }
            if (this.isBoolean()) {
                return new BooleanThing(checker, token, this, apply, origin, parent);
            }
            if (this.isNumber()) {
                return new NumberThing(checker, token, this, apply, origin, parent);
            }
            if (this.isVoid()) {
                return new VoidThing(checker, token, this, apply, origin, parent);
            }
            if (this.isNothing()) {
                return new NothingThing(checker, token, this, apply, origin, parent);
            }
        }
        else if (this.isAction()) {
            return new ActionThing(checker, token, this, this.declaration); // TODO
        }
        else if (this.isDialog()) {
            return new DialogThing(checker, token, this, this.declaration); // TODO
        }
        else if (this.isFunction()) {
            return new FunctionThing(checker, token, this, (origin === null || origin === void 0 ? void 0 : origin.kind) === "ArgumentDeclaration" ? origin : undefined);
        }
        else if (this.isList()) {
            return new ListThing(checker, token, this, apply, origin, parent);
        }
        else if (this.isArgument()) {
            return new ArgumentThing(checker, token, this, apply, origin, parent);
        }
        else if (this.isArguments()) {
            return new ArgumentsThing(checker, token, this, origin, parent === null || parent === void 0 ? void 0 : parent.asFunction());
        }
        else if (this.isObject()) {
            return new ObjectThing(checker, token, this, apply, origin, parent);
        }
        return new AnyThing(checker, token, this, apply, origin, parent);
    }
    /**
     * Get the type of a property enclosed by this Type.
     *
     * @param argument name or index
     */
    getPropertyType(argument) {
        var _a;
        return (_a = this.getProperty(argument)) === null || _a === void 0 ? void 0 : _a.type;
    }
    /**
     * Get a property enclosed by this Type.
     *
     * @param argument name or index
     */
    getProperty(argument) {
        var _a, _b, _c;
        if (argument === undefined) {
            return undefined;
        }
        if (ask.isArgument(argument)) {
            if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
                return this.getProperty(argument.name.name);
            }
            if (typeof argument.index === "number") {
                return this.getProperty(argument.index);
            }
        }
        else if (typeof argument === "number") {
            return (_b = this.properties) === null || _b === void 0 ? void 0 : _b[argument];
        }
        else {
            const prop = (_c = this.propertiesIndex) === null || _c === void 0 ? void 0 : _c[argument];
            if (prop) {
                return prop;
            }
            if (this.extensions) {
                for (const ext of this.extensions) {
                    const prop = ext === null || ext === void 0 ? void 0 : ext.getProperty(argument);
                    if (prop) {
                        return prop;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Get the Nodes referenced by this Type.
     */
    getReferences() {
        var _a;
        const references = new Set();
        (_a = this.properties) === null || _a === void 0 ? void 0 : _a.forEach((prop) => {
            var _a, _b;
            if (!(((_a = prop.type) === null || _a === void 0 ? void 0 : _a.isList()) || ((_b = prop.type) === null || _b === void 0 ? void 0 : _b.isOptional()))) {
                findReferences(prop.type);
            }
        });
        return references;
        function findReferences(type) {
            var _a, _b, _c;
            if ((type === null || type === void 0 ? void 0 : type.declaration) !== undefined && !references.has(type.declaration)) {
                references.add(type.declaration);
                (_a = type.genericArguments) === null || _a === void 0 ? void 0 : _a.forEach(findReferences);
                (_b = type.extensions) === null || _b === void 0 ? void 0 : _b.forEach(findReferences);
                (_c = type.properties) === null || _c === void 0 ? void 0 : _c.forEach((prop) => {
                    var _a, _b;
                    if (!(((_a = prop.type) === null || _a === void 0 ? void 0 : _a.isList()) || ((_b = prop.type) === null || _b === void 0 ? void 0 : _b.isOptional()))) {
                        findReferences(prop.type);
                    }
                });
            }
        }
    }
    /**
     * Scan this type for any type arguments or super-types that consist of TypeParameters.
     */
    hasTypeParameters() {
        var _a, _b, _c;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
            return true;
        }
        return (((_b = this.genericArguments) === null || _b === void 0 ? void 0 : _b.find((t) => t === null || t === void 0 ? void 0 : t.hasTypeParameters())) !== undefined ||
            ((_c = this.extensions) === null || _c === void 0 ? void 0 : _c.find((e) => e.hasTypeParameters())) !== undefined);
    }
    /**
     * A type has a catalog if it is a built-in or a custom slot type found in the interaction model.
     *
     * TODO: support catalog associations in ACDL https://github.com/alexa/ask-ac/issues/29
     */
    hasCatalog() {
        var _a, _b, _c;
        return (_c = (((_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(BuiltinsNamespace)) || ((_b = this.namespace) === null || _b === void 0 ? void 0 : _b.startsWith(SlotTypesNamespace)))) !== null && _c !== void 0 ? _c : false;
    }
    /**
     * A custom type is one that is not defined in:
     * 1. com.amazon.alexa.schema
     * 2. com.amazon.alexa.ask.conversations
     * 3. com.amazon.ask.types.builtins.AMAZON
     *
     * TODO: validate that users can't use these namespaces: https://github.com/alexa/ask-ac/issues/3
     */
    isCustom() {
        return !(this.isBuiltIn() || this.isAlexaSchema() || this.isCoreType());
    }
    /**
     * Checks if this is a built in type provided by the platform.
     *
     * Namespace:
     * `com.amazon.ask.types.builtins.AMAZON`
     *
     * TODO: should we also consider Alexa Schema as built-in?
     */
    isBuiltIn() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(BuiltinsNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * @returns true if the type can be used as the result type of an utterance
     */
    isValidForUtterance() {
        return this.isBuiltIn() || this.isCoreType() || this.isAlexaSchema() || this.isSlotType();
    }
    /**
     * Checks if this is a valid UtteranceEvent wrapper type
     */
    isValidUtteranceWrapper() {
        return (!this.isPrimitive() || this.isNothing()) && !this.isBuiltIn();
    }
    /**
     * Checks if this type is defined in an interaction model.
     *
     * Namespace:
     * `com.amazon.ask.types.builtins.AMAZON`
     */
    isSlotType() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(SlotTypesNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Checks if this type is defined in the AC core library.
     *
     * Namespace:
     * `com.amazon.alexa.ask.conversations`
     */
    isCoreType() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(AlexaConversationsNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Checks if this type is defined in Alexa Schema.
     *
     * Namespace:
     * `com.amazon.alexa.schema`
     */
    isAlexaSchema() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(AlexaSchemaNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Check if this type is the top-level Skill type.
     */
    isSkill() {
        var _a, _b;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === AlexaConversations.Skill;
    }
    /**
     * Check if this type is the SkillLevelResponses type.
     */
    isSkillLevelResponses() {
        var _a, _b;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === AlexaConversations.SkillLevelResponses;
    }
    /**
     * Check if this type is the InvocationName type.
     */
    isInvocationName() {
        var _a, _b;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === AlexaConversations.InvocationName;
    }
    /**
     * A complex type is one with at least one property.
     */
    isObject() {
        var _a, _b;
        return ((_b = (_a = this.properties) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0;
    }
    /**
     * Check if a name is (inclusively) found in this type's hierarchy.
     *
     * @param name name of type to find
     */
    isNameInHierarchy(name) {
        return this.findNameInHierarchy(name) !== undefined;
    }
    /**
     * Find a type by name in this type's hierarchy.
     *
     * E.g.
     * ```
     * looking for UtteranceEvent<T>
     *
     * // type is the one we're looking for
     * UtteranceEvent<T> => UtteranceEvent<T>
     *
     * // search the type's hierarchy.
     * type A : UtteranceEvent<String> => UtteranceEvent<String>
     *
     * // type does not exist
     * type B => undefined
     * ```
     *
     *
     * @param name name of the type to find
     */
    findNameInHierarchy(name) {
        var _a, _b, _c;
        if (name !== undefined) {
            if (((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined && typeof name === "function" ? name((_b = this.name) === null || _b === void 0 ? void 0 : _b.name) : ((_c = this.name) === null || _c === void 0 ? void 0 : _c.name) === name) {
                return this;
            }
            if (this.extensions) {
                for (const ext of this.extensions) {
                    const found = ext.findNameInHierarchy(name);
                    if (found) {
                        return found;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Check if this is the intrinsic `Properties<T>` type that computes the properties of some type, `T`.
     */
    isProperties() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Properties;
    }
    /**
     * Check if this is the intrinsic `Property<T>`.
     */
    isProperty() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Property;
    }
    /**
     * If this is a type `Property<T>`, return the inner type, `T`.
     */
    getPropertyTypeType() {
        var _a;
        if (this.isProperty()) {
            return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        }
        return undefined;
    }
    /**
     * Check if this is the `Type<T>` type.
     *
     * ```
     * type Person {
     *   String name
     * }
     *
     * // Type<Person>
     * person = Person
     * ```
     */
    isType() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Type;
    }
    /**
     * Get the type of the `Type<T>` type - in this case, `T`.
     *
     * ```
     * Type<Person> => Person
     * ```
     */
    getTypeType() {
        var _a, _b;
        if (this.isType()) {
            return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        }
        return (_b = this.findNameInHierarchy(AlexaSchema.Type)) === null || _b === void 0 ? void 0 : _b.getTypeType();
    }
    /**
     * Is the `ReturnValue<T>` intrinsic type.
     */
    isReturnValue() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.ReturnValue;
    }
    /**
     * Get the type parameter of the `ReturnValue<T>`.
     */
    getReturnValueType() {
        var _a;
        return this.isReturnValue() ? (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0] : undefined;
    }
    /**
     * Is this Type `alexa.schema.Nothing` (the Bottom Type)?
     */
    isNothing() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Nothing;
    }
    /**
     * Is this Type `alexa.schema.Thing` (the Bottom Type)?
     */
    isThing() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Thing;
    }
    /**
     * Is this type `Nothing`, `Void`, `Boolean`, `Number`, `String`, `Date` or `Time`.
     */
    isPrimitive() {
        return this.isNothing() || this.isVoid() || this.isBoolean() || this.isNumber() || this.isStringLike();
    }
    /**
     * Is this type one of 'Request', 'ConfirmArgs', 'ConfirmAction', 'Notify', 'Offer', 'ReqAlt', 'Bye', 'ReqMore'.
     */
    isResponseAct() {
        return (this.isRequest() ||
            this.isConfirmArgs() ||
            this.isConfirmAction() ||
            this.isNotify() ||
            this.isOffer() ||
            this.isReqAlt() ||
            this.isBye() ||
            this.isReqMore());
    }
    /**
     * Is this the Void type, `com.amazon.alexa.schema.Void`?
     *
     * @version 1.0.0-beta2
     */
    isVoid() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Void;
    }
    /**
     * Is this type, `Optional<T>`?
     *
     * Also known as a union, `T | Void`.
     */
    isOptional() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Optional;
    }
    /**
     * Is this boolean type, `com.amazon.alexa.schema.Boolean`?
     */
    isBoolean() {
        return this.isNameInHierarchy(AlexaSchema.Boolean);
    }
    /**
     * Is this boolean type, `com.amazon.alexa.schema.Boolean`?
     */
    isNumber() {
        return this.isNameInHierarchy(AlexaSchema.Number);
    }
    /**
     * Is this a String-like Type?
     *
     * TODO: should Date and Time really be considered String-like?
     */
    isStringLike() {
        return this.isString() || this.isUtterance();
    }
    /**
     * is this type String or a sub-type of String.
     */
    isString() {
        return this.isNameInHierarchy(AlexaSchema.String);
    }
    /**
     * Is this the core `com.amazon.alexa.ask.conversations.UtteranceEvent` type?
     */
    isUtteranceEvent() {
        return this.isNameInHierarchy(AlexaConversations.UtteranceEvent);
    }
    /**
     * Get the UtteranceEvent's inner type.
     *
     * E.g.
     *
     * ```
     * UtteranceEvent<Person> => Person
     * ```
     */
    getUtteranceEventType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(AlexaConversations.UtteranceEvent)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Is this the intrinsic `Utterance` type, representing a type-safe sample utterance string.
     *
     * ```
     * // UtteranceEvent<Person>
     * u = utterances<Person>(
     *   // List<Utterance<Person>>
     *   [
     *     // Utterance<Person>
     *     "i am {name}"
     *   ]
     * )
     * ```
     */
    isUtterance() {
        return this.isNameInHierarchy(AlexaConversations.Utterance);
    }
    /**
     * Is this the intrinsic com.amazon.alexa.ask.conversations.Argument type representing an argument on some action.
     *
     * ```
     * action A(String arg)
     *
     * // Argument<String>
     * a = A.arguments.arg
     * ```
     */
    isArgument() {
        return this.isNameInHierarchy(AlexaSchema.Argument);
    }
    /**
     * @returns the type `T` in `Argument<T>`.
     */
    getArgumentType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(AlexaSchema.Argument)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Is this the intrinsic com.amazon.alexa.ask.conversations.Arguments type representing the arguments of some Action.
     *
     * ```
     * action A(String arg)
     *
     * // Arguments<A>
     * a = A.arguments
     * ```
     */
    isArguments() {
        return this.isNameInHierarchy(AlexaSchema.Arguments);
    }
    /**
     * Get the item type of a parameterized List.
     *
     * ```
     * Utterance<Person> => (type) Person
     * utterances<Person>([
     *   "hello" => (type) Person
     * ])
     * ```
     *
     * @returns the item Type if this is a List, otherwise `undefined`.
     */
    getUtteranceType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(AlexaConversations.Utterance)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Get the type of an Optional.
     *
     * ```
     * Optional<String> => (type) String
     * Optional<T> => (type parameter) T
     * ```
     */
    getOptionalType() {
        var _a;
        if (this.isOptional()) {
            return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        }
        return undefined;
    }
    /**
     * If this is Optional<T> returns T else returns this
     * @returns
     */
    getNonOptionalType() {
        var _a;
        return this.isOptional() && ((_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0]) ? this.genericArguments[0] : this;
    }
    /**
     * Checks if this type is the `Locale` enum type.
     */
    isLocale() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Locale;
    }
    /**
     * Checks if this type is the `AnnotationTarget` enum type.
     */
    isAnnotationTarget() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.AnnotationTarget;
    }
    /**
     * Checks if this is a type that extends the base Function type.
     *
     * Both Action and Dialog types extend Function.
     *
     * @returns
     */
    isFunction() {
        return this.findNameInHierarchy(AlexaSchema.Function) !== undefined;
    }
    /**
     * Checks if this Type extends one of `FunctionN` functions where `N` is a numerical value representing
     * the number of arguments in the Function.
     */
    isFunctionN() {
        return this.getFunctionN() !== undefined;
    }
    /**
     * Gets the `FunctionN` type in this Type's hierarchy if this is of type `FunctionN` where `N` is a
     * numerical value representing the number of arguments in the Function.
     */
    getFunctionN() {
        return this.findNameInHierarchy((s) => s.startsWith(AlexaSchema.Function) && s !== AlexaSchema.Function);
    }
    /**
     * If this Type is a Function (Dialog or Action) then
     * @returns
     */
    getFunctionReturnType() {
        var _a, _b, _c, _d;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" || ((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "DialogDeclaration") {
            return this.checker.instantiateTypeReference(this.declaration.returnType);
        }
        if (this.isFunctionN()) {
            const functionN = this.getFunctionN();
            return (_c = functionN === null || functionN === void 0 ? void 0 : functionN.genericArguments) === null || _c === void 0 ? void 0 : _c[((_d = functionN === null || functionN === void 0 ? void 0 : functionN.genericArguments) === null || _d === void 0 ? void 0 : _d.length) - 1];
        }
        return undefined;
    }
    getFunctionArgumentType(index) {
        var _a, _b;
        return (_b = (_a = this.getFunctionN()) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[index];
    }
    getFunctionArgumentTypes() {
        var _a, _b, _c, _d, _e;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" || ((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "DialogDeclaration") {
            return (_c = this.declaration.arguments) === null || _c === void 0 ? void 0 : _c.map((arg) => this.checker.getType(arg));
        }
        if (this.isFunction()) {
            if (this.functionArgumentNames) {
                return this.functionArgumentNames.map((name, i) => { var _a; return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[i]; });
            }
            // parse the value of N in a FunctionN/ActionN/DialogN.
            const nStr = (_d = this.shortName) === null || _d === void 0 ? void 0 : _d.replace(/[^0-9]/g, "");
            if (nStr) {
                const n = parseInt(nStr, 10);
                const args = [];
                for (let i = 0; i < n; i++) {
                    args.push((_e = this.genericArguments) === null || _e === void 0 ? void 0 : _e[i]);
                }
                return args;
            }
        }
        return undefined;
    }
    /**
     * Get the ArgumentDeclarations for this Type if the Type is a Function.
     */
    getFunctionArgumentDeclarations() {
        var _a, _b, _c, _d, _e, _f;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" || ((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "DialogDeclaration") {
            return this.declaration.arguments;
        }
        if (this.isFunction()) {
            if (this.functionArgumentNames) {
                return this.functionArgumentNames.map((name, i) => {
                    var _a, _b, _c;
                    const decl = new ask.ArgumentDeclaration(new ask.Name(name), (_b = (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[i]) === null || _b === void 0 ? void 0 : _b.toTypeReference());
                    (_c = this.declaration) === null || _c === void 0 ? void 0 : _c.setAsParentOn(decl);
                    return decl;
                });
            }
            const nStr = (_c = this.shortName) === null || _c === void 0 ? void 0 : _c.replace(/[^0-9]/g, "");
            if (nStr) {
                const n = parseInt(nStr, 10);
                const args = [];
                for (let i = 0; i < n; i++) {
                    // BUG: we are moving the TypeReference to the TypeDeclaration so it has the wrong lexical scope.
                    const decl = new ask.ArgumentDeclaration(new ask.Name(`arg${i}`), (_e = (_d = this.genericArguments) === null || _d === void 0 ? void 0 : _d[i]) === null || _e === void 0 ? void 0 : _e.toTypeReference());
                    (_f = this.declaration) === null || _f === void 0 ? void 0 : _f.setAsParentOn(decl);
                    args.push(decl);
                }
                return args;
            }
        }
        return undefined;
    }
    /**
     * Takes two Function types and creates a mapping between their respective argument names based on position.
     *
     * This is the foundation on which we allow functions passed around as arguments to be compatible even
     * when they don't have the same argument names. We do not wish for argument names to be relevant for
     * the compatibility of functions.
     *
     * Ex. `foo.getFunctionArgumentDeclarationMappings(Foo)`:
     * ```
     * action String Foo(String arg)
     *
     * dialog Bar(
     *   action String foo(String str)
     * ) {
     *   sample {
     *     // here, foo's `str` will be mapped to Foo's `arg`.
     *     foo(str = "hello")
     *   }
     * }
     * ```
     *
     * @param other the other type we are mapping this argument's names to.
     * @returns resulting mappings will map from `this`'s argument names to `other`'s argument names.
     */
    getFunctionArgumentDeclarationMappings(other) {
        var _a;
        if (other === undefined || !(other.isFunction() && this.isFunction())) {
            return undefined;
        }
        const thisArgs = this.getFunctionArgumentDeclarations();
        if (thisArgs === undefined) {
            return undefined;
        }
        return (_a = other
            .getFunctionArgumentDeclarations()) === null || _a === void 0 ? void 0 : _a.map((arg, i) => {
            var _a, _b;
            const argDecl = thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs[i];
            if (((_a = argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === null || _a === void 0 ? void 0 : _a.name) && ((_b = arg.name) === null || _b === void 0 ? void 0 : _b.name)) {
                return {
                    [argDecl.name.name]: arg.name.name,
                };
            }
            return {};
        }).reduce((a, b) => ({ ...a, ...b }), {});
    }
    /**
     * Checks if this type is an DialogDeclaration.
     */
    isDialogDeclaration() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "DialogDeclaration";
    }
    /**
     * Checks if this type is an DialogDeclaration.
     */
    isDialog() {
        return this.findNameInHierarchy(AlexaConversations.Dialog) !== undefined;
    }
    /**
     * Checks if this type is a fully qualified ActionDeclaration.
     */
    isActionDeclaration() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration";
    }
    isAction() {
        return this.findNameInHierarchy(AlexaConversations.Action) !== undefined;
    }
    /**
     * Checks if this is a type
     * @returns
     */
    isEnum() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "EnumDeclaration";
    }
    /**
     * Checks if this is a Type representing an item in an `enum`.
     * @returns
     */
    isEnumItem() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "EnumItemDeclaration";
    }
    /**
     * Is this `com.amazon.alexa.ask.conversations.Args` or a sub-type.
     *
     * This type represents var args in an Action.
     *
     * ```
     * action void A(Args<String>)
     *
     * a = A(
     *   "no need",
     *   "to surround these with",
     *   "[ and ]"
     * )
     * ```
     */
    isArgs() {
        return this.isNameInHierarchy(AlexaConversations.Args);
    }
    /**
     * Does this Type extend `alexa.schema.List`.
     */
    isList() {
        return this.isNameInHierarchy(AlexaSchema.List);
    }
    isTaskContextProjection() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.TaskContextProjection;
    }
    isTaskContextProjectionType() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.TaskContextProjectionType;
    }
    isTaskContextProjectionAnnotation() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.taskContextProjection;
    }
    isTaskContextProjectionInfo() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.TaskContextProjectionInfo;
    }
    /**
     * Is this type one of 'Invoke', 'Inform', 'Affirm', 'Deny', 'RequestAct'.
     */
    isRequestAct() {
        var _a;
        return this.isInvoke() || this.isInform() || this.isAffirm() || this.isDeny() || ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.RequestAct;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Invoke"
     */
    isInvoke() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Invoke;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Inform"
     */
    isInform() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Inform;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Affirm"
     */
    isAffirm() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Affirm;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Deny"
     */
    isDeny() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Deny;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Offer"
     */
    isOffer() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Offer;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqAlt"
     */
    isReqAlt() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ReqAlt;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqMore"
     */
    isReqMore() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ReqMore;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Request"
     */
    isRequest() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Request;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Request"
     */
    isRequestArguments() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.RequestArguments;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ConfirmAction"
     */
    isConfirmAction() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ConfirmAction;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqMore"
     */
    isConfirmArgs() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ConfirmArgs;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqMore"
     */
    isConfirmArguments() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.ConfirmArguments;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Bye"
     */
    isBye() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Bye;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Notify"
     */
    isNotify() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.Notify;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.APLA"
     */
    isApla() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.APLA;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.MultiModalResponse"
     */
    isMultiModalResponse() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.MultiModalResponse;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.APL"
     */
    isApl() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaConversations.APL;
    }
    /**
     * Get the item type of a parameterized List.
     *
     * ```
     * List<String> => (type) String
     * List<T> => (type parameter) T
     * ```
     *
     * @returns the item Type if this is a List, otherwise `undefined`.
     */
    getListItemType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(AlexaSchema.List)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Check if this type is a sub-type (or same type) as a `baseType`.
     *
     * A type, `A` extends another type, `B` if `A & B == B`.
     *
     * In other words, the intersection of A and B should be exactly B.
     *
     * @param baseType base type
     */
    extends(baseType) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        if (baseType === undefined) {
            return false;
        }
        if (this.isNothing()) {
            // Nothing is a sub type of all Things
            return true;
        }
        if (baseType.isThing()) {
            // Thing is the base type of all Things.
            return true;
        }
        if (this.isVoid() && baseType.isOptional()) {
            return true;
        }
        if (this.isVoid() && baseType.isNothing()) {
            // for backwards compatibility, we will equate `Nothing` and `Void`.
            return true;
        }
        if ((((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" && ((_b = baseType.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration") ||
            (((_c = this.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "DialogDeclaration" && ((_d = baseType.declaration) === null || _d === void 0 ? void 0 : _d.kind) === "DialogDeclaration")) {
            // if we are comparing literal actions/dialogs, then their name must be identical regardless of compatibility
            // we still uphold nominal rules when comparing static references.
            return ((_e = this.declaration.name) === null || _e === void 0 ? void 0 : _e.name) === ((_f = baseType.declaration.name) === null || _f === void 0 ? void 0 : _f.name);
        }
        if (this.isFunctionN() && baseType.isFunctionN()) {
            if (baseType.isAction() && !this.isAction()) {
                return false;
            }
            if (baseType.isDialog() && !this.isDialog()) {
                return false;
            }
            const thisArgs = (_g = this.getFunctionN()) === null || _g === void 0 ? void 0 : _g.getFunctionArgumentTypes();
            const baseTypeArgs = (_h = baseType.getFunctionN()) === null || _h === void 0 ? void 0 : _h.getFunctionArgumentTypes();
            if (!((_k = (_j = this.getFunctionReturnType()) === null || _j === void 0 ? void 0 : _j.extends(baseType.getFunctionReturnType())) !== null && _k !== void 0 ? _k : false)) {
                // return types are co-variant, this function's return type must extend the base function's return type
                return false;
            }
            // Lengths are different, lets check the extraneous arguments in baseType and ensure they're optional
            if ((thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs.length) !== (baseTypeArgs === null || baseTypeArgs === void 0 ? void 0 : baseTypeArgs.length) && (baseTypeArgs === null || baseTypeArgs === void 0 ? void 0 : baseTypeArgs.length)) {
                const startArgPos = (_l = thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs.length) !== null && _l !== void 0 ? _l : 0;
                for (let i = startArgPos; i < baseTypeArgs.length; i++) {
                    if (!baseTypeArgs[i].isOptional() || !baseTypeArgs[i].isArgs()) {
                        return false;
                    }
                }
            }
            return ((_m = thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs.map((thisArg, i) => {
                const otherArg = baseTypeArgs === null || baseTypeArgs === void 0 ? void 0 : baseTypeArgs[i];
                if (otherArg === undefined) {
                    return thisArg.isOptional() || thisArg.isArgs();
                }
                // arguments are contra-variant, the base type's argument must be a super-type of this function's argument.
                return otherArg.extends(thisArg);
            }).reduce((a, b) => a && b, true)) !== null && _m !== void 0 ? _m : false);
        }
        if (((_o = this.name) === null || _o === void 0 ? void 0 : _o.name) === ((_p = baseType.name) === null || _p === void 0 ? void 0 : _p.name)) {
            if (this.genericArguments) {
                if (this.genericArguments.length === ((_q = baseType.genericArguments) === null || _q === void 0 ? void 0 : _q.length)) {
                    return this.genericArguments.find((genericArg, i) => (genericArg === null || genericArg === void 0 ? void 0 : genericArg.extends(baseType === null || baseType === void 0 ? void 0 : baseType.genericArguments[i])) !== true) === undefined;
                }
                return false;
            }
            return true;
        }
        // Check optional types, we currently allow Optional<T> as assignable to T.
        if (baseType.isOptional()) {
            return this.extends(baseType.getOptionalType());
        }
        else if (this.isOptional()) {
            return (_s = (_r = this.getOptionalType()) === null || _r === void 0 ? void 0 : _r.extends(baseType)) !== null && _s !== void 0 ? _s : false;
        }
        return ((_t = this.extensions) === null || _t === void 0 ? void 0 : _t.find((extension) => (extension === null || extension === void 0 ? void 0 : extension.extends(baseType)) === true)) !== undefined;
    }
    /**
     * Check if two instantiated types are identical.
     *
     * @param other
     */
    equals(other) {
        var _a;
        if (this.name !== undefined && this.name === other.name) {
            if (this.genericArguments !== undefined && this.genericArguments.length === ((_a = other.genericArguments) === null || _a === void 0 ? void 0 : _a.length)) {
                for (let i = 0; i < this.genericArguments.length; i++) {
                    const _this = this.genericArguments[i];
                    const _other = other.genericArguments[i];
                    if (_this === undefined || _other === undefined) {
                        return false;
                    }
                    if (!_this.equals(_other)) {
                        return false;
                    }
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Get the union of this type and another. We only have limited support for unions at this time.
     *
     * Rules:
     * 1. Void | Void = Void
     * 2. Nothing | T = T
     * 3. Void | T = Optional<T>
     * 4. Optional<T> | T = Optional<T>
     * 5. A | B = A & B
     *
     * RE: Rule #5 - when two non-Optional or Void types are unioned, we take their intersection. I.e. we
     * reduce their type to their most common denominator. We will change this once we add full support for
     * union types.
     *
     * @param other other type to union this type with
     * @returns the unioned type.
     */
    union(other) {
        var _a, _b;
        if (other === undefined) {
            return this;
        }
        if (this.equals(other)) {
            return this;
        }
        if (this.isNothing()) {
            return other;
        }
        if (other === null || other === void 0 ? void 0 : other.isNothing()) {
            return this;
        }
        if (this.isVoid() && (other === null || other === void 0 ? void 0 : other.isVoid())) {
            return this;
        }
        if (this.isVoid()) {
            return new Type(this.checker, this.checker.lookupTypeDeclaration(AlexaSchema.Optional), [other]);
        }
        if (other.isVoid()) {
            return new Type(this.checker, this.checker.lookupTypeDeclaration(AlexaSchema.Optional), [this]);
        }
        if (this.isOptional()) {
            return this.checker.void.union((_a = this.getOptionalType()) === null || _a === void 0 ? void 0 : _a.union(other));
        }
        if (other.isOptional()) {
            return this.checker.void.union((_b = other.getOptionalType()) === null || _b === void 0 ? void 0 : _b.union(this));
        }
        return this.intersect(other);
        // return this.getIntersection(other);
    }
    intersect(other) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (this.isNothing() || (other === null || other === void 0 ? void 0 : other.isNothing())) {
            return this.checker.nothing;
        }
        if (other === undefined) {
            return undefined;
        }
        if (((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ((_b = other.name) === null || _b === void 0 ? void 0 : _b.name)) {
            if (((_c = this.genericArguments) === null || _c === void 0 ? void 0 : _c.length) === 0 && ((_d = other.genericArguments) === null || _d === void 0 ? void 0 : _d.length) === 0) {
                return this;
            }
            if (((_e = this.genericArguments) === null || _e === void 0 ? void 0 : _e.length) === ((_f = other.genericArguments) === null || _f === void 0 ? void 0 : _f.length)) {
                const genericArguments = (_g = this.genericArguments) === null || _g === void 0 ? void 0 : _g.map((genericArg, i) => { var _a, _b; return (_b = genericArg === null || genericArg === void 0 ? void 0 : genericArg.intersect((_a = other.genericArguments) === null || _a === void 0 ? void 0 : _a[i])) !== null && _b !== void 0 ? _b : this.checker.thing; });
                return new Type(this.checker, this.declaration, genericArguments);
            }
        }
        else if (this.extends(other)) {
            for (const ext of (_h = this.extensions) !== null && _h !== void 0 ? _h : []) {
                if (ext.extends(other)) {
                    return ext.intersect(other);
                }
            }
        }
        else if (other.extends(this)) {
            for (const ext of (_j = other.extensions) !== null && _j !== void 0 ? _j : []) {
                if (ext.extends(this)) {
                    return ext.intersect(this);
                }
            }
        }
        else {
            for (const thisExt of (_k = this.extensions) !== null && _k !== void 0 ? _k : []) {
                for (const otherExt of (_l = other.extensions) !== null && _l !== void 0 ? _l : []) {
                    if (thisExt.extends(otherExt)) {
                        return thisExt.intersect(otherExt);
                    }
                }
            }
        }
        return this.checker.thing;
    }
    narrow(other) {
        if (other === undefined) {
            return this;
        }
        if (other.extends(this)) {
            // if the other type is more narrow, choose it
            return other;
        }
        if (this.extends(other)) {
            // if this type is more general, choose the other
            return this;
        }
        // these types have no intersection, this case is impossible.
        return this.checker.nothing;
    }
    /**
     * Find all locales this type support
     * E.G.
     * assume slotType deOnlySlot is only available in de_DE IM, sloType commonSlotType exist in both de_DE and en_US IM
     * ```
     * type myType {
     *  optional String id
     *  optional deOnlySlot german
     * }
     * getLocales() => ["de_DE"]
     * ```
     *
     * when type have nested type
     * ```
     * type complexType {
     *   myType name1
     *   optional commonSlotType name2
     * }
     *
     * getLocales() => ["de_DE"]
     * // only return de_DE cause this is the only overlap part of deOnlySlot and commonSlotType
     * ```
     * @returns
     */
    getLocales() {
        if (__classPrivateFieldGet(this, _Type_locales, "f") !== undefined) {
            return __classPrivateFieldGet(this, _Type_locales, "f");
        }
        const slotTypes = new Set();
        const seen = new Set();
        // Find all slotTypes this type depends on
        if (this.isSlotType()) {
            slotTypes.add(this.declaration);
        }
        else {
            // recursively look up the child types
            visitEachChildType(this, function collectSlotType(type) {
                var _a;
                if (type.declaration && !seen.has(type.toString())) {
                    seen.add(type.toString());
                    if (((_a = type.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "SlotType") {
                        slotTypes.add(type.declaration);
                    }
                    visitEachChildType(type, collectSlotType);
                }
            });
        }
        // calculate the overlap locales that all slotTypes support
        let locales;
        for (const slotType of slotTypes.values()) {
            if (!locales) {
                locales = [...slotType.locales];
            }
            else {
                locales = locales.filter((locale) => slotType.locales.includes(locale));
            }
        }
        __classPrivateFieldSet(this, _Type_locales, locales, "f");
        return __classPrivateFieldGet(this, _Type_locales, "f");
    }
    /**
     * Gets a map of required property names to properties in this.properties
     * @returns a map of required property names to properties in this.properties
     */
    getRequiredProperties() {
        var _a;
        return new Map((_a = this.properties) === null || _a === void 0 ? void 0 : _a.reduce((acc, property) => {
            var _a, _b, _c;
            if (((_a = property.type) === null || _a === void 0 ? void 0 : _a.isOptional()) || (((_b = property.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "TypeProperty" && ((_c = property.declaration) === null || _c === void 0 ? void 0 : _c.optional) === true)) {
                return acc;
            }
            acc.push([property.name, property]);
            return acc;
        }, []));
    }
    /**
     * Gets a map of property names to corresponding properties
     * @returns a map of property names to corresponding properties
     */
    getPropertyMap() {
        var _a;
        return new Map(((_a = this.properties) !== null && _a !== void 0 ? _a : []).map((property) => [property.name, property]));
    }
    /**
     * Retrieves generic arguments nested in a Type declaration of the form Apply<Optional<T>,K>.
     * For such type this will return an array with two elements, a type object corresponding to T
     * and a type object corresponding to K.
     */
    getNestedGenericArguments() {
        var _a, _b;
        // This is the recursion termination case for when we reach T in  Action1<Optional<T>, Nothing>
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
            return [this];
        }
        const typeGenericArguments = (_b = this.genericArguments) !== null && _b !== void 0 ? _b : [];
        if (typeGenericArguments.length === 0) {
            // This is a special case found in Action1<Optional<T>, Nothing>. Nothing has no
            // nested generic arguments so we just return a type object corresponding to Nothing
            return [this];
        }
        // Call getNestedGenericArguments recursively on each of this.genericArguents
        const returnValue = [];
        for (const typeGenericArgument of typeGenericArguments) {
            if (!typeGenericArgument) {
                continue;
            }
            returnValue.push(...typeGenericArgument.getNestedGenericArguments());
        }
        return returnValue;
    }
}
_Type_environment = new WeakMap(), _Type_extensions = new WeakMap(), _Type_properties = new WeakMap(), _Type_propertiesIndex = new WeakMap(), _Type_locales = new WeakMap();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90eXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLE9BQU8sS0FBSyxHQUFHLE1BQU0sT0FBTyxDQUFDO0FBRTdCLE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDOUIsT0FBTyxFQUNMLGNBQWMsRUFDZCxrQkFBa0IsRUFDbEIsMkJBQTJCLEVBQzNCLFdBQVcsRUFDWCxvQkFBb0IsRUFDcEIsaUJBQWlCLEVBQ2pCLGNBQWMsRUFDZCxrQkFBa0IsR0FDbkIsTUFBTSxPQUFPLENBQUM7QUFHZixPQUFPLEVBQUMsT0FBTyxFQUFFLFlBQVksRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUU3QyxPQUFPLEVBQ0wsV0FBVyxFQUNYLFFBQVEsRUFDUixjQUFjLEVBQ2QsYUFBYSxFQUNiLFlBQVksRUFDWixXQUFXLEVBQ1gsYUFBYSxFQUNiLFNBQVMsRUFDVCxZQUFZLEVBQ1osV0FBVyxFQUNYLFdBQVcsRUFDWCxXQUFXLEVBRVgsU0FBUyxHQUNWLE1BQU0sU0FBUyxDQUFDO0FBRWpCLE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUUzQyxNQUFNLFVBQVUsTUFBTSxDQUFDLEdBQVE7SUFDN0IsT0FBTyxDQUFBLEdBQUcsYUFBSCxHQUFHLHVCQUFILEdBQUcsQ0FBRSxJQUFJLE1BQUssTUFBTSxDQUFDO0FBQzlCLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLE9BQU8sSUFBSTtJQUdmLFlBQ1csT0FBb0I7SUFDN0I7O09BRUc7SUFDTSxXQVFZO0lBQ3JCOztPQUVHO0lBQ00sZ0JBQXVDO0lBQ2hEOztPQUVHO0lBQ0gsOEJBQThCO0lBQ3JCLHFCQUFnQztJQUN6Qzs7T0FFRztJQUNNLFlBQXFCOzs7OzttQkF6QnJCOzs7Ozs7bUJBSUE7Ozs7OzttQkFZQTs7Ozs7O21CQUtBOzs7Ozs7bUJBSUE7O1FBNUJYOzs7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