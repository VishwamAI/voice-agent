import fs from "fs-extra";
import path from "path";
import * as ask from "./ast";
import { filterDuplicateErrors, typeError, nameNotFound, sortErrors } from "./error";
import { AlexaConversations, AnnotationTarget } from "./ast";
import { trimScheme } from "./util";
import { APLAFileTypes, APLFileType, Constants } from "./constants";
import { evaluateDialogFlow, validateGlobalWelcome, validateSkillLevelResponses, validateArgumentListThing } from "./evaluate";
import { Flow } from "./flow";
import { validateSkill, validateSkillCallContext } from "./validate-skill";
import { EvaluationState } from "./evaluation-state";
import { collect } from "./visit";
import { getExpressionIfLocField, ValidationErrorFactory } from "./error-factory";
import { PropertyNode } from "./property-node";
import { memoize } from "./lazy";
/**
 * Validate the entire project for correctness and return and errors.
 *
 * @param project project to validate.
 * @param isSkill whether the project is a skill
 * @param skipSemanticValidations skip semantic validations
 * @returns array of all errors if detected.
 */
export function validateProject(project, isSkill, skipSemanticValidations) {
    var _a, _b, _c;
    const checker = project.getTypeChecker();
    const errors = [];
    const skills = checker.project.findSkills();
    errors.push(...project.sourceModules.flatMap((srcModule) => {
        var _a;
        return [
            // syntax errors from module errors
            ...((_a = srcModule.errors) !== null && _a !== void 0 ? _a : []),
            // syntax errors from validateRootExpressions
            ...(srcModule.content ? validateRootExpressions(srcModule.content, checker) : []),
            // semantic errors from validateModule
            ...(srcModule.content && !skipSemanticValidations ? validateModule(srcModule.content, checker) : []),
        ];
    }));
    if (skipSemanticValidations) {
        return errors;
    }
    errors.push(...validateGlobalWelcome(project, checker));
    // now that type checking has passed, let's pass over the AST and create a tree with all types resolved.
    // project = resolveProject(project);
    // checker = project.getTypeChecker();
    const isParsingSkill = isSkill !== null && isSkill !== void 0 ? isSkill : (project.isSkill() || skills.length > 0);
    if (!isParsingSkill) {
        // if we're not parsing a skill, then we should treat all dialogs as deployable
        // FIXME: this logic is wrong, we should validateDialogFlow of all dialogs and handle cases where the dialog "could be called"
        // e.g don't error when there is no prior expect event for a dialog that may be called.
        // This can be improved as part of our re-usability QA drive.
        (_a = checker.project
            .getRootDialogs()) === null || _a === void 0 ? void 0 : _a.forEach((dialog) => errors.push(...evaluateDialogFlow(new Flow(checker, dialog, undefined, []), new EvaluationState(undefined))));
    }
    else {
        if (skills.length > 1) {
            errors.push(...skills.map((skill) => ValidationErrorFactory.TooManySkillDeclarations({
                expr: getExpressionIfLocField(skill.declaration.name, skill.declaration),
                attributes: {
                    skillNames: skills
                        .filter((s) => s !== skill)
                        .map((skill) => { var _a; return `'${(_a = skill.declaration.name) === null || _a === void 0 ? void 0 : _a.name}'`; })
                        .join(", "),
                },
            })));
        }
        if (project.config.skill === undefined) {
            // no `package.json` or `ask.json` configuration, attempt to derive it from the context
            if (skills.length === 0) {
                // this skill contains no `skill()` declarations, so look for deployable dialogs and global `response/prompts` responses.
                errors.push(...validateDeployableDialogs(checker));
                errors.push(...validateSkillLevelResponses(project));
                (_b = checker.project
                    .getRootDialogs()) === null || _b === void 0 ? void 0 : _b.forEach((dialog) => errors.push(...evaluateDialogFlow(new Flow(checker, dialog, undefined, []), new EvaluationState(undefined))));
            }
            else {
                // skill declarations exist, validate each one.
                skills.forEach((skill) => errors.push(...validateSkill(skill.apply, checker)));
            }
        }
        else {
            // the skill is configured in `package.json` or `ask.json`, let's validate it.
            const skill = checker.lookupQualifiedName(project.config.skill);
            if (skill === undefined) {
                errors.push(ValidationErrorFactory.SkillNotFound({
                    attributes: {
                        skillName: project.config.skill,
                    },
                }));
            }
            else if (skill.kind === "NameDeclaration" && ((_c = skill.expression) === null || _c === void 0 ? void 0 : _c.kind) === "Call") {
                const apply = checker.getApply(skill.expression);
                if (apply) {
                    if (apply.isSkillAction()) {
                        errors.push(...validateSkill(apply, checker));
                    }
                    else {
                        errors.push(ValidationErrorFactory.InvalidSkillExpression({
                            expr: skill,
                            attributes: {
                                skillName: project.config.skill,
                            },
                        }));
                    }
                }
            }
            else {
                errors.push(ValidationErrorFactory.InvalidSkillExpression({
                    expr: skill,
                    attributes: {
                        skillName: project.config.skill,
                    },
                }));
            }
        }
    }
    return sortErrors(filterDuplicateErrors(errors));
}
/**
 * validate the skill has deployable dialog
 * This function should be used when there's no skill action call
 */
function validateDeployableDialogs(checker) {
    const deployableDialogs = checker.project.getRootDialogs();
    if (deployableDialogs === undefined || deployableDialogs.length === 0) {
        return [ValidationErrorFactory.NoDeployableDialog()];
    }
    return [];
}
/**
 * Validate all expressions in a module in the context of a Project.
 *
 * @param module ACDL file or ASK Module to validate.
 * @param checker type checker for querying the expressions.
 */
export const validateModule = (module, checker) => [
    ...validateImports(module, checker),
    ...validateNamespace(module, checker),
    ...validateBlock(module, checker),
];
/**
 * Returns errors for root expressions (expressions directly at the module level) that are not allowed in the ASKIR schema
 * @param module module we are validating
 * @param checker unused
 * @returns errors for root expressions that are not allowed in the ASKIR schema
 */
const validateRootExpressions = (module, checker) => {
    var _a;
    const errors = [];
    // As seen on https://github.com/alexa/ask-expressions/blob/9a88ebd49ea69dd49ecd2952d2cd6682d41d6b85/packages/%40alexa/ask-expressions-spec/schemas/Module.json#L37
    const validRootExpressions = new Set([
        "ActionDeclaration",
        "DialogDeclaration",
        "InteractionDeclaration",
        "EnumDeclaration",
        "NameDeclaration",
        "TypeDeclaration",
    ]);
    for (const expression of module.expressions || []) {
        if (!validRootExpressions.has(expression.kind)) {
            errors.push(ValidationErrorFactory.DeclarationExpected({
                expr: expression,
                attributes: {
                    text: expression.kind === "InteractionDeclaration" ? "" : ((_a = expression.name) === null || _a === void 0 ? void 0 : _a.name) || "",
                },
            }));
        }
    }
    return errors;
};
export const validateBlock = (scope, checker) => {
    var _a;
    return [
        ...validateDuplicateNames(scope, checker),
        ...((_a = scope.expressions) !== null && _a !== void 0 ? _a : []).map((expr) => validateExpression(expr, checker)).reduce((a, b) => a.concat(b), []),
    ];
};
export const validateNamespace = (module, checker) => {
    var _a;
    const nameSpace = (_a = module.namespace) === null || _a === void 0 ? void 0 : _a.name;
    // make sure the namespace doesn't contain reserved prefix
    const errors = [];
    if (nameSpace !== undefined) {
        Constants.RESERVED_PREFIXES.forEach((prefix) => {
            if (nameSpace.startsWith(prefix)) {
                errors.push(ValidationErrorFactory.InvalidNamespace({
                    expr: module.namespace,
                    attributes: {
                        prefix,
                    },
                }));
            }
        });
    }
    return errors;
};
/**
 * Validate the imports in a module.
 *
 * @param module ACDL file or ASK Module to validate.
 * @param checker type checker for querying the expressions.
 */
export const validateImports = (module, checker) => {
    var _a;
    return ((_a = module.imports) === null || _a === void 0 ? void 0 : _a.map((imprt) => {
        if (imprt.kind === "ImportName") {
            if (checker.lookupQualifiedName(imprt.name) === undefined) {
                return [
                    ValidationErrorFactory.InvalidImport({
                        expr: imprt,
                        attributes: {
                            importName: imprt.name,
                        },
                    }),
                ];
            }
        }
        else {
            const namespace = checker.listNamespace(imprt.name);
            if (namespace === undefined) {
                return [
                    ValidationErrorFactory.InvalidImportNamespace({
                        expr: imprt,
                        attributes: {
                            importName: imprt.name,
                        },
                    }),
                ];
            }
        }
        return [];
    }).reduce((a, b) => a.concat(b), [])) || [];
};
export const validateCircularReferences = (source, checker) => {
    var _a, _b, _c, _d, _e, _f, _g;
    if (source.kind === "TypeReference" || source.kind === "TypeDeclaration") {
        const type = source.kind === "TypeReference" ? checker.getType(source) : (_a = checker.getType(source)) === null || _a === void 0 ? void 0 : _a.getTypeType();
        if (type !== undefined) {
            if ((type === null || type === void 0 ? void 0 : type.properties) && type.declaration) {
                for (const prop of type.properties) {
                    if (prop.type === undefined || ((_b = prop.type) === null || _b === void 0 ? void 0 : _b.isOptional()) || ((_c = prop.type) === null || _c === void 0 ? void 0 : _c.isList()) || prop.type.isNothing()) {
                        continue;
                    }
                    else if (prop.type.extends(type) || prop.type.getReferences().has(type.declaration)) {
                        return [
                            ValidationErrorFactory.CircularReferenceType({
                                expr: source.name,
                                attributes: {
                                    typeName: (_d = type.toString(source)) !== null && _d !== void 0 ? _d : source.name,
                                },
                            }),
                        ];
                    }
                }
            }
        }
    }
    else if ((_e = checker.getReferences(source)) === null || _e === void 0 ? void 0 : _e.has(source)) {
        const expr = source.name;
        return [
            source.kind === "DialogDeclaration"
                ? ValidationErrorFactory.CircularReferenceDialog({
                    expr,
                    attributes: {
                        dialogName: (_f = source.name) === null || _f === void 0 ? void 0 : _f.name,
                    },
                })
                : ValidationErrorFactory.CircularReferenceName({
                    expr,
                    attributes: {
                        name: (_g = source.name) === null || _g === void 0 ? void 0 : _g.name,
                    },
                }),
        ];
    }
    return [];
};
/**
 * Validates all annotations on a node.
 */
export const validateAnnotations = (node, checker) => {
    var _a, _b;
    return [
        ...validateNameDeclarationAnnotations(node, checker),
        ...validateTypeDeclarationAnnotations(node, checker),
        ...validateDialogDeclarationAnnotations(node, checker),
        ...((_b = (_a = node.annotations) === null || _a === void 0 ? void 0 : _a.flatMap((ann) => validateAnnotation(ann, checker))) !== null && _b !== void 0 ? _b : []),
    ];
};
/**
 * Validates annotations on name declarations.
 *
 * There are two cases:
 *
 * 1. When the value is a `NameReference`, we should not allow any annotations.
 * 2. When the value is a `variations` call, we should not allow `locale` annotations.
 */
export const validateNameDeclarationAnnotations = (node, checker) => {
    var _a, _b, _c;
    const errors = [];
    if (!ask.isNameDeclaration(node)) {
        return errors;
    }
    if (ask.isNameReference(node.expression)) {
        errors.push(...((_b = (_a = node.annotations) === null || _a === void 0 ? void 0 : _a.map((ann) => ValidationErrorFactory.InvalidAnnotationNameDeclarationNameReference({
            expr: ann,
        }))) !== null && _b !== void 0 ? _b : []));
    }
    if (((_c = node.expression) === null || _c === void 0 ? void 0 : _c.kind) === "Call") {
        const apply = checker.getApply(node.expression);
        if ((apply === null || apply === void 0 ? void 0 : apply.isVariations()) && (node === null || node === void 0 ? void 0 : node.annotations)) {
            for (const ann of node === null || node === void 0 ? void 0 : node.annotations) {
                if (ann.kind === "Annotation" && ann.call && ann.call.kind === "Call") {
                    const annApply = checker.getApply(ann.call);
                    if (annApply === null || annApply === void 0 ? void 0 : annApply.isLocaleAction()) {
                        errors.push(ValidationErrorFactory.InvalidAnnotationNameDeclarationVariations({
                            expr: ann,
                        }));
                    }
                }
            }
        }
    }
    return errors;
};
/**
 * Validates annotations on type declarations, and the properties of the type.
 *
 * There is one case:
 *
 * 1. We should not allow `referable` annotation on type properties that aren't catalogs.
 */
export const validateTypeDeclarationAnnotations = (node, checker) => {
    var _a, _b, _c, _d;
    const errors = [];
    if (!ask.isTypeDeclaration(node)) {
        return errors;
    }
    for (const property of (_a = node.properties) !== null && _a !== void 0 ? _a : []) {
        for (const ann of (_b = property.annotations) !== null && _b !== void 0 ? _b : []) {
            const apply = checker.getApply(ann.call);
            if (apply === null || apply === void 0 ? void 0 : apply.isReferableAction()) {
                const type = checker.getType(property.type);
                if (!(type === null || type === void 0 ? void 0 : type.hasCatalog())) {
                    errors.push(ValidationErrorFactory.InvalidReferableAnnotation({
                        expr: ann,
                        attributes: {
                            typeName: (_c = node.name) === null || _c === void 0 ? void 0 : _c.name,
                            propertyName: (_d = property.name) === null || _d === void 0 ? void 0 : _d.name,
                        },
                    }));
                }
            }
        }
    }
    return errors;
};
/**
 * Validates annotations on dialog declarations.
 *
 * There are two cases:
 *
 * 1. When dialog is reusable, we should not allow the dialog to have a `locale` annotation.
 * 2. When dialog is reusable, we should not allow the dialog samples to have a `locale` annotation.
 */
export const validateDialogDeclarationAnnotations = (node, checker) => {
    var _a;
    const errors = [];
    if (!ask.isDialogDeclaration(node)) {
        return errors;
    }
    // locale annotation is not allowed on reusable dialog
    if (!checker.project.isRootDialog(node)) {
        if (node.annotations && node.annotations.length > 0) {
            for (const ann of node === null || node === void 0 ? void 0 : node.annotations) {
                if (ann.kind === "Annotation" && ann.call && ann.call.kind === "Call") {
                    const annApply = checker.getApply(ann.call);
                    if (annApply === null || annApply === void 0 ? void 0 : annApply.isLocaleAction()) {
                        errors.push(ValidationErrorFactory.InvalidAnnotationReusableDialog({
                            expr: ann,
                        }));
                    }
                }
            }
        }
        // locale annotation is not allowed on reusable dialogs' samples
        (_a = node.samples) === null || _a === void 0 ? void 0 : _a.forEach((sample) => {
            if (sample.annotations && sample.annotations.length > 0) {
                for (const ann of sample === null || sample === void 0 ? void 0 : sample.annotations) {
                    if (ann.kind === "Annotation" && ann.call && ann.call.kind === "Call") {
                        const annApply = checker.getApply(ann.call);
                        if (annApply === null || annApply === void 0 ? void 0 : annApply.isLocaleAction()) {
                            errors.push(ValidationErrorFactory.InvalidAnnotationReusableDialogSample({
                                expr: ann,
                            }));
                        }
                    }
                }
            }
        });
        if (errors.length > 0)
            return errors;
    }
    return errors;
};
/**
 * Validate an Annotation's Call data structure:
 *
 * 1. the annotation type must also be annotated with the meta-annotation `@com.amazon.alexa.ask.conversations.Annotation`.
 * 2. the list of supported targets for the annotation must include the target this annotation is being applied to,
 */
export const validateAnnotation = (annotation, checker) => {
    var _a, _b, _c;
    const errors = validateCall(annotation.call, checker);
    const annotationTarget = AnnotationTarget.from(annotation.context.kind);
    const target = checker.getApply(annotation.call);
    const decl = (target === null || target === void 0 ? void 0 : target.decl.kind) === "Type" ? target.decl.declaration : target === null || target === void 0 ? void 0 : target.decl;
    if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "ActionDeclaration") {
        const annotationDescription = (_a = decl.annotations) === null || _a === void 0 ? void 0 : _a.map((a) => checker.getApply(a.call)).find((a) => a === null || a === void 0 ? void 0 : a.isAnnotationAction());
        if (annotationDescription) {
            const allowMultiple = annotationDescription.getAnnotationAllowMultiple();
            if (allowMultiple === false) {
                const duplicates = (_b = annotation.context.annotations) === null || _b === void 0 ? void 0 : _b.filter((an) => { var _a, _b, _c, _d; return ((_c = (_b = (_a = checker.getApply(an.call)) === null || _a === void 0 ? void 0 : _a.decl) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name) === ((_d = decl.name) === null || _d === void 0 ? void 0 : _d.name); });
                if (duplicates && duplicates.length > 1) {
                    errors.push(ValidationErrorFactory.InvalidAnnotationMultiple({
                        expr: annotation,
                        attributes: {
                            annotatedType: target === null || target === void 0 ? void 0 : target.getName(),
                        },
                    }));
                }
            }
            const targets = annotationDescription.getAnnotationTargets();
            if ((targets === null || targets === void 0 ? void 0 : targets.find((a) => a === annotationTarget)) === undefined) {
                errors.push(ValidationErrorFactory.InvalidAnnotationTarget({
                    expr: annotation,
                    attributes: {
                        annotatedType: target === null || target === void 0 ? void 0 : target.getName(),
                        annotationTarget,
                        expectedAnnotationTargets: (_c = targets === null || targets === void 0 ? void 0 : targets.map((t) => `'AnnotationTarget.${t}'`).join(", ")) !== null && _c !== void 0 ? _c : "",
                    },
                }));
            }
        }
        else {
            errors.push(ValidationErrorFactory.InvalidAnnotationMetaAnnotation({
                expr: annotation,
                attributes: {
                    annotationType: target === null || target === void 0 ? void 0 : target.getName(),
                },
            }));
        }
    }
    return errors;
};
export const validateExpression = (expr, checker) => {
    if (expr === undefined) {
        return [];
    }
    if (expr.kind === "Module") {
        // return validateModule(expr, checker);
    }
    else if (expr.kind === "InteractionDeclaration") {
        return validateInteractionDeclaration(expr, checker);
    }
    else if (expr.kind === "Correction") {
        return validateCorrection(expr, checker);
    }
    else if (expr.kind === "ActionDeclaration") {
        return validateActionDeclaration(expr, checker);
    }
    else if (expr.kind === "Argument") {
        return validateExpression(expr.value, checker);
    }
    else if (expr.kind === "Call") {
        return validateCall(expr, checker);
    }
    else if (expr.kind === "Condition") {
        return validateCondition(expr, checker);
    }
    else if (expr.kind === "DialogDeclaration") {
        return validateDialogDeclaration(expr, checker);
    }
    else if (expr.kind === "EnumDeclaration") {
        return validateEnumDeclaration(expr, checker);
    }
    else if (expr.kind === "NameDeclaration") {
        return validateNameDeclaration(expr, checker);
    }
    else if (expr.kind === "NameReference") {
        return validateNameReference(expr, checker);
    }
    else if (expr.kind === "Sample") {
        return validateSample(expr, checker);
    }
    else if (expr.kind === "TypeDeclaration") {
        return validateTypeDeclaration(expr, checker);
    }
    else if (expr.kind === "Block") {
        return validateBlock(expr, checker);
    }
    else if (expr.kind === "PropertyReference") {
        return validatePropertyReference(expr, checker);
    }
    else if (expr.kind === "When") {
        return validateExpression(expr.expression, checker);
    }
    console.warn(`can not validate expression kind '${expr.kind}'`);
    return [];
};
export const validateDialogDeclaration = (dialog, checker) => {
    var _a, _b, _c;
    return [
        ...(dialog.samples === undefined || dialog.samples.length === 0
            ? [
                ValidationErrorFactory.EmptyDialog({
                    expr: dialog,
                    attributes: {
                        dialogName: (_a = dialog.name) === null || _a === void 0 ? void 0 : _a.name,
                    },
                }),
            ]
            : []),
        ...validateTypeReference(dialog.returnType, checker),
        ...validateTypeParameters(dialog.genericArguments, checker),
        ...(dialog.arguments ? validateArgumentDeclarations(dialog.arguments, checker, true) : []),
        ...validateAnnotations(dialog, checker),
        ...((_c = (_b = dialog.samples) === null || _b === void 0 ? void 0 : _b.map((sample) => validateSample(sample, checker)).reduce((a, b) => a.concat(b), [])) !== null && _c !== void 0 ? _c : []),
        ...validateCircularReferences(dialog, checker),
    ];
};
export const validateSample = (sample, checker) => {
    var _a, _b;
    if (sample.scope === undefined) {
        return [];
    }
    const dialog = sample.context;
    const errors = [...validateBlock(sample.scope, checker), ...validateAnnotations(sample, checker)];
    if (errors.length > 0) {
        return errors; // return if basic parse errors exist for each sample, before checking from entire sample scope
    }
    if (sample.scope.expressions === undefined || sample.scope.expressions.length === 0) {
        errors.push(ValidationErrorFactory.EmptySample({
            expr: sample,
            attributes: {
                dialogName: (_a = dialog.name) === null || _a === void 0 ? void 0 : _a.name,
            },
        }));
    }
    const expectedType = checker.getType(dialog.returnType) || checker.void;
    const actualType = checker.getType(sample.scope) || checker.void;
    if (!expectedType.isVoid() && !expectedType.isNothing() && !actualType.extends(expectedType)) {
        const last = sample.scope.expressions[sample.scope.expressions.length - 1];
        if (last) {
            errors.push(ValidationErrorFactory.TypeErrorDialogLastExpr({
                expr: last,
                attributes: {
                    dialogName: (_b = dialog.name) === null || _b === void 0 ? void 0 : _b.name,
                    expectedType: expectedType.toString(sample),
                    actualType: actualType.toString(sample),
                },
            }));
        }
    }
    return errors;
};
function hasName(expr) {
    var _a;
    return ((expr.kind === "NameDeclaration" ||
        expr.kind === "TypeDeclaration" ||
        expr.kind === "ActionDeclaration" ||
        expr.kind === "DialogDeclaration") &&
        ((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined);
}
export const validateDuplicateNames = (scope, checker) => {
    var _a, _b, _c;
    const errors = [];
    if (scope.kind === "Module") {
        const moduleUri = checker.getUri(scope);
        (_a = scope.expressions) === null || _a === void 0 ? void 0 : _a.forEach((expr) => {
            var _a;
            if (expr.kind !== "InteractionDeclaration" && ((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name)) {
                const declarations = checker.global.scope.get(expr.name.name);
                if (Array.isArray(declarations)) {
                    const files = Array.from(new Set(declarations
                        .map((d) => checker.getUri(d))
                        .filter((uri) => uri !== undefined && uri !== moduleUri)
                        .map((uri) => path.relative(checker.project.config.rootDir, uri))
                        .map((uri) => `'${trimScheme(uri)}'`)));
                    errors.push(ValidationErrorFactory.DuplicateNameDeclarationInModule({
                        expr,
                        attributes: {
                            name: expr.name.name,
                            filesLength: files.length,
                            fileNames: files.join(", "),
                        },
                    }));
                }
            }
        });
    }
    else {
        const seen = new Set();
        const duplicates = new Set();
        const parentScope = checker.getVisibleNames(scope.context, false);
        (_b = scope.expressions) === null || _b === void 0 ? void 0 : _b.forEach((expr) => {
            if (hasName(expr)) {
                const name = expr.name.name;
                if (seen.has(name) || (parentScope === null || parentScope === void 0 ? void 0 : parentScope.has(name)) || checker.global.scope.has(name)) {
                    duplicates.add(name);
                }
                seen.add(name);
            }
        });
        (_c = scope.expressions) === null || _c === void 0 ? void 0 : _c.forEach((expr) => {
            var _a;
            if (hasName(expr) && duplicates.has((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name)) {
                errors.push(ValidationErrorFactory.DuplicateNameDeclaration({
                    expr: expr.name,
                    attributes: {
                        name: expr.name.name,
                    },
                }));
            }
        });
    }
    return errors;
};
/**
 * Validates a name expression.
 *
 * @param checker
 * @param name
 */
export const validateNameDeclaration = (name, checker) => {
    var _a;
    const errors = name.expression ? [...validateExpression(name.expression, checker)] : [];
    errors.push(...validateCircularReferences(name, checker));
    errors.push(...validateAnnotations(name, checker));
    const valueType = checker.getType(name.expression);
    const explicitType = name.type ? checker.instantiateTypeReference(name.type) : undefined;
    if (name.type !== undefined) {
        errors.push(...validateTypeReference(name.type, checker));
    }
    if (explicitType !== undefined && valueType !== undefined) {
        if (!valueType.extends(explicitType)) {
            errors.push(typeError(valueType, explicitType, name, name.name));
        }
    }
    if (valueType === undefined) {
    }
    // declare a name with an expression of type Nothing is invalid
    const nameType = checker.getType(name.expression);
    if ((nameType === null || nameType === void 0 ? void 0 : nameType.isNothing()) || (nameType === null || nameType === void 0 ? void 0 : nameType.isVoid())) {
        errors.push(ValidationErrorFactory.InvalidNameDeclaration({
            expr: name.name,
            attributes: {
                name: (_a = name.name) === null || _a === void 0 ? void 0 : _a.name,
                nothingTypeName: checker.nothing.toString(name),
                voidTypeName: checker.void.toString(name),
            },
        }));
    }
    return errors;
};
export const validateNameReference = (id, checker) => [...validateName(id, checker)];
export const validateName = (id, checker) => {
    var _a;
    const found = lookupName(id, id.name);
    if (found === undefined) {
        // For Call, it's valid when name is undefined, like listLiteral
        if (id.name !== undefined && id.kind !== "Call") {
            return [nameNotFound(id.name)];
        }
    }
    else if (Array.isArray(found)) {
        const declares = found
            .map((f) => {
            if (f.kind === "ResponseTemplate") {
                return f.type === ask.ResponseTemplateType.Prompt ? `'prompts.${f.name}'` : `'displays.${f.name}'`;
            }
            return `'${f.name.name}'`;
        })
            .filter((f) => f !== undefined)
            .join(", ");
        return [
            ValidationErrorFactory.AmbiguousNameReference({
                expr: id,
                attributes: {
                    name: (_a = id.name) === null || _a === void 0 ? void 0 : _a.name,
                    possibleName: declares,
                },
            }),
        ];
    }
    return [];
    function lookupName(scope, name) {
        if (name === undefined) {
            return undefined;
        }
        const nameStr = typeof name === "string" ? name : name.name;
        if (checker.global.scope.has(nameStr)) {
            return checker.global.scope.get(nameStr);
        }
        const lexicalScope = checker.getVisibleNames(scope);
        if (lexicalScope === null || lexicalScope === void 0 ? void 0 : lexicalScope.has(nameStr)) {
            return lexicalScope.get(nameStr);
        }
        return undefined;
    }
};
export const validateActionDeclaration = (action, checker) => [
    ...validateTypeReference(action.returnType, checker),
    ...validateTypeParameters(action.genericArguments, checker),
    ...(action.arguments ? validateArgumentDeclarations(action.arguments, checker, false) : []),
    ...validateAnnotations(action, checker),
    ...validateAnnotatedActionDeclaration(action, checker),
];
/**
 * Validates that an ActionDeclaration that is annotated with the `@annotation` meta-annotation has a return type of void.
 */
export const validateAnnotatedActionDeclaration = (action, checker) => {
    var _a, _b, _c;
    if (((_a = action.annotations) === null || _a === void 0 ? void 0 : _a.find((a) => checker.qualifyName(action, a.call.name) === AlexaConversations.annotation)) !== undefined) {
        const actionDeclType = checker.getType(action);
        if ((actionDeclType === null || actionDeclType === void 0 ? void 0 : actionDeclType.isAction()) && ((_b = actionDeclType === null || actionDeclType === void 0 ? void 0 : actionDeclType.getPropertyType("returnType")) === null || _b === void 0 ? void 0 : _b.getTypeType())) {
            const returnType = (_c = actionDeclType === null || actionDeclType === void 0 ? void 0 : actionDeclType.getPropertyType("returnType")) === null || _c === void 0 ? void 0 : _c.getTypeType();
            if (returnType && !(returnType.isVoid() || returnType.isNothing())) {
                return [
                    ValidationErrorFactory.InvalidAnnotationMetaAnnotationReturnType({
                        expr: action.name,
                    }),
                ];
            }
        }
    }
    return [];
};
export function validateArgumentDeclarations(args, checker, isDialogArgument) {
    var _a, _b, _c, _d, _e;
    const seen = new Set();
    const duplicates = new Set();
    const errors = [];
    let isRequiredArgAllowed = true;
    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) {
            if (seen.has(arg.name.name)) {
                duplicates.add(arg.name.name);
            }
            seen.add((_b = arg.name) === null || _b === void 0 ? void 0 : _b.name);
        }
        const hasMoreArgs = args[i + 1] !== undefined;
        const type = checker.instantiateTypeReference(arg.type);
        if ((type === null || type === void 0 ? void 0 : type.isArgs()) && hasMoreArgs) {
            errors.push(ValidationErrorFactory.VarArgsMustBeLast({
                expr: arg,
            }));
        }
        if (type === null || type === void 0 ? void 0 : type.isOptional()) {
            isRequiredArgAllowed = false;
        }
        else if (!(type === null || type === void 0 ? void 0 : type.isArgs()) && !isRequiredArgAllowed) {
            errors.push(ValidationErrorFactory.RequiredArgExistAfterOptionalArg({
                expr: arg,
                attributes: {
                    argumentName: (_c = arg.name) === null || _c === void 0 ? void 0 : _c.name,
                },
            }));
        }
        errors.push(...validateArgumentDeclaration(arg, checker, isDialogArgument));
    }
    for (const arg of args) {
        if (((_d = arg.name) === null || _d === void 0 ? void 0 : _d.name) && duplicates.has((_e = arg.name) === null || _e === void 0 ? void 0 : _e.name)) {
            errors.push(ValidationErrorFactory.DuplicateArgument({
                expr: arg.name,
                attributes: {
                    argumentName: arg.name.name,
                },
            }));
        }
    }
    return errors;
}
export function validateArgumentDeclaration(arg, checker, isDialogArgument = false) {
    const errors = [
        ...validateExpression(arg.defaultExpression, checker),
        ...validateTypeReference(arg.type, checker),
        ...validateAnnotations(arg, checker),
    ];
    if (arg.name === undefined) {
        errors.push(ValidationErrorFactory.SyntaxError({
            expr: getExpressionIfLocField(arg.type, arg),
            overrideMessage: "expected name for argument declaration.",
        }));
    }
    if (arg.defaultExpression) {
        const actualType = checker.getType(arg.defaultExpression);
        const expectedType = checker.getType(arg.type);
        if (actualType && expectedType && !actualType.extends(expectedType)) {
            errors.push(typeError(actualType, expectedType, arg.defaultExpression, arg.defaultExpression));
        }
        // Arguments' default value must be nothing except dialogArgument
        if (!isDialogArgument) {
            const thing = checker.getThing(arg.defaultExpression);
            if (!((thing === null || thing === void 0 ? void 0 : thing.isNothing()) && thing.isLiteral())) {
                errors.push(ValidationErrorFactory.InvalidApiArgumentDefaultValue({
                    expr: arg,
                }));
            }
        }
        else {
            // for dialogArgument, the default expression can’t call dialogs, user defined APIs or branch with conditions
        }
    }
    return errors;
}
/**
 * Validate that an EnumDeclaration has at least one item and no duplicate items.
 *
 * ```acdl
 * enum E {} // invalid
 * enum E { // invalid
 *   A
 *   A
 * }
 * enum E { // valid
 *   A
 *   B
 * }
 * ```
 */
export const validateEnumDeclaration = (enumDecl, checker) => {
    var _a, _b, _c, _d;
    if (enumDecl.items === undefined || enumDecl.items.length === 0) {
        return [
            ValidationErrorFactory.EmptyEnumDeclaration({
                expr: enumDecl,
                attributes: {
                    enumName: (_a = enumDecl.name) === null || _a === void 0 ? void 0 : _a.name,
                },
            }),
            ...validateAnnotations(enumDecl, checker),
        ];
    }
    const names = new Set();
    const dups = new Set();
    (_b = enumDecl.items) === null || _b === void 0 ? void 0 : _b.forEach((item) => {
        var _a, _b;
        if ((_a = item.name) === null || _a === void 0 ? void 0 : _a.name) {
            if (names.has((_b = item.name) === null || _b === void 0 ? void 0 : _b.name)) {
                dups.add(item.name.name);
            }
            else {
                names.add(item.name.name);
            }
        }
    });
    if (dups.size === 0) {
        return [];
    }
    return [
        ...validateAnnotations(enumDecl, checker),
        ...((_d = (_c = enumDecl.items) === null || _c === void 0 ? void 0 : _c.map((item) => {
            var _a;
            if (((_a = item.name) === null || _a === void 0 ? void 0 : _a.name) && dups.has(item.name.name)) {
                return ValidationErrorFactory.DuplicateEnumItem({
                    expr: item,
                    attributes: {
                        enumItemName: item.name.name,
                    },
                });
            }
            return undefined;
        }).filter((e) => e !== undefined)) !== null && _d !== void 0 ? _d : []),
    ];
};
export const validateTypeDeclaration = (type, checker) => {
    var _a;
    return [
        ...validateTypeReferences((_a = type.properties) === null || _a === void 0 ? void 0 : _a.map((p) => p.type).filter((t) => t !== undefined), checker),
        ...validateTypeReferences(type.extensions, checker),
        ...validateTypeParameters(type.genericArguments, checker),
        ...validateCircularReferences(type, checker),
        ...validateAnnotations(type, checker),
        ...validateTypeDeclarationProperties(type, checker),
    ];
};
/**
 * validate the properties in typeDecl are not duplicate
 */
export const validateTypeDeclarationProperties = (typeDecl, checker) => {
    var _a, _b, _c;
    const seen = new Set((_a = typeDecl.extensions) === null || _a === void 0 ? void 0 : _a.map((ext) => { var _a, _b, _c; return (_c = (_b = (_a = checker.getType(ext)) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.map((p) => p.name)) !== null && _c !== void 0 ? _c : []; }).reduce((a, b) => a.concat(b), []));
    return ((_c = (_b = typeDecl.properties) === null || _b === void 0 ? void 0 : _b.map((prop) => {
        var _a;
        const name = (_a = prop.name) === null || _a === void 0 ? void 0 : _a.name;
        if (name === undefined) {
            return ValidationErrorFactory.SyntaxError({
                expr: getExpressionIfLocField(prop.type, prop),
                overrideMessage: "expected property name.",
            });
        }
        if (seen.has(name)) {
            return ValidationErrorFactory.DuplicatePropertyRedeclared({
                expr: prop,
                attributes: {
                    propertyName: name,
                },
            });
        }
        seen.add(name);
        return undefined;
    }).filter((e) => e !== undefined)) !== null && _c !== void 0 ? _c : []);
};
export const validateTypeParameters = (params, checker) => { var _a; return (_a = params === null || params === void 0 ? void 0 : params.map((param) => validateTypeParameter(param, checker)).flat()) !== null && _a !== void 0 ? _a : []; };
export const validateTypeParameter = (param, checker) => validateTypeReferences(param.constraints, checker);
export const validateTypeReferences = (refs, checker) => { var _a; return (_a = refs === null || refs === void 0 ? void 0 : refs.map((ref) => validateTypeReference(ref, checker)).flat()) !== null && _a !== void 0 ? _a : []; };
export const validateTypeReference = (ref, checker) => {
    var _a, _b;
    const errors = [];
    if (ref) {
        // check if the call name could be resolved, error if fail to resolve call name
        errors.push(...validateName(ref, checker));
        if (errors.length > 0) {
            return errors;
        }
        errors.push(...validateCircularReferences(ref, checker));
        const typeDecl = checker.lookupTypeReference(ref);
        if (typeDecl === undefined) {
            errors.push(nameNotFound(ref.name));
        }
        if (ref.arguments) {
            for (const arg of ref.arguments) {
                errors.push(...validateTypeReference(arg, checker));
            }
        }
        if (typeDecl && errors.length === 0) {
            const type = checker.instantiateTypeReference(ref);
            if (type !== undefined) {
                if (typeDecl.kind === "TypeDeclaration") {
                    if (typeDecl.genericArguments) {
                        if (typeDecl.genericArguments.length !== ((_a = type.genericArguments) === null || _a === void 0 ? void 0 : _a.length)) {
                            errors.push(ValidationErrorFactory.TypeErrorRequiredTypeArguments({
                                expr: ref,
                                attributes: {
                                    typeDeclarationName: (_b = typeDecl.name) === null || _b === void 0 ? void 0 : _b.name,
                                    numArguments: typeDecl.genericArguments.length,
                                },
                            }));
                        }
                        else {
                            type.genericArguments.forEach((genericArgument, i) => {
                                var _a, _b;
                                const typeParameter = (_a = typeDecl.genericArguments) === null || _a === void 0 ? void 0 : _a[i];
                                if (typeParameter !== undefined && typeParameter.constraints && genericArgument !== undefined) {
                                    for (const constraint of typeParameter.constraints) {
                                        const constraintType = checker.instantiateTypeReference(constraint, type.environment);
                                        if (constraintType && !genericArgument.extends(constraintType)) {
                                            errors.push(typeError(genericArgument, constraintType, ref, (_b = ref.arguments) === null || _b === void 0 ? void 0 : _b[i]));
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }
        }
    }
    return errors;
};
/**
 * Validate an `alexa.lang.property` call to access a property on a type.
 *
 * @param ref call expression representing the access of a property on another expression
 */
export const validatePropertyReference = (ref, checker) => {
    // property does not exist
    const { name } = ref;
    const expr = ref.expression;
    const exprType = checker.getType(expr);
    if ((name === null || name === void 0 ? void 0 : name.name) === undefined) {
        return [
            ValidationErrorFactory.IdentifierExpected({
                expr: getExpressionIfLocField(ref.name, ref),
            }),
        ];
    }
    const qualifiedName = ask.PropertyReference.tryResolveQualifiedName(ref);
    if (qualifiedName !== undefined && checker.lookupQualifiedName(qualifiedName) !== undefined) {
        return [];
    }
    if (exprType !== undefined) {
        const prop = exprType.getProperty(name.name);
        if (prop === undefined) {
            return [
                ...validateExpression(expr, checker),
                ValidationErrorFactory.UnknownProperty({
                    expr: getExpressionIfLocField(ref.name, ref),
                    attributes: {
                        propertyName: name.name,
                        typeName: exprType.toString(ref),
                    },
                }),
            ];
        }
    }
    return validateExpression(expr, checker);
};
export const validateUtteranceTypeWrapper = (apply) => {
    var _a;
    const errors = [];
    if (!apply.isUtterances()) {
        return [];
    }
    const utteranceType = (_a = apply.getReturnType()) === null || _a === void 0 ? void 0 : _a.getUtteranceEventType();
    if (!(utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.isValidUtteranceWrapper())) {
        errors.push(ValidationErrorFactory.UtteranceEventTypeMustReferToWrapper({
            expr: utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.declaration,
            attributes: {
                typeName: utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.shortName,
            },
        }));
    }
    return errors;
};
/**
 * Validate a Call to a Type or an Action:
 *
 * - Resolve its declaration and throw errors if it cannot be found.
 * - Infer generic arguments if they aren't provided and flag errors if that cannot be achieved.
 * - Validate that all required arguments are provided and that types of arguments match declaration.
 */
export const validateCall = (call, checker) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const errors = [];
    // check if the call name could be resolved, error if fail to resolve call name
    errors.push(...validateName(call, checker));
    const getPropertyMap = memoize((type) => type.getPropertyMap());
    if (errors.length > 0) {
        return errors;
    }
    const apply = checker.getApply(call);
    if (call.genericArguments) {
        errors.push(...validateTypeReferences(call.genericArguments, checker));
    }
    if (apply === undefined) {
        if (((_a = call.name) === null || _a === void 0 ? void 0 : _a.name) === undefined) {
            // could not infer anonymous type
            errors.push(ValidationErrorFactory.CouldNotInferAnonymousType({
                expr: call,
            }));
        }
        else {
            errors.push(nameNotFound(call.name));
        }
    }
    else {
        errors.push(...validateSkillCallContext(apply));
        errors.push(...validateRequireCall(apply, checker));
        errors.push(...validateValidateArgAnnotation(apply, checker));
        if (apply.isAnnotation()) {
            // if this is a call to an Annotation, we must ensure that it is in an Annotation context.
            if (apply.call.context.kind !== "Annotation" && apply.call.getSample() !== undefined) {
                errors.push(ValidationErrorFactory.InvalidAnnotationCall({
                    expr: call,
                    attributes: {
                        annotationTarget: apply.getName(),
                    },
                }));
            }
        }
        else if (apply.isEventDecl() || apply.isFileAccessAction() || apply.isSkillAction() || apply.isWelcome() || apply.isVariations()) {
            if (apply.isSkillAction()) {
                errors.push(...validateSkillCallContext(apply));
            }
            else if (call.context.kind !== "NameDeclaration" || ((_b = call.context.context) === null || _b === void 0 ? void 0 : _b.kind) !== "Module") {
                errors.push(ValidationErrorFactory.InvalidCallContextModuleNameDeclaration({
                    expr: call,
                    attributes: {
                        actionName: checker.qualifyName(call, (_c = call.name) === null || _c === void 0 ? void 0 : _c.name),
                    },
                }));
            }
            if (apply.isWelcome()) {
                const actionValue = apply.getArgumentValue("action");
                const actionType = checker.getType(actionValue);
                if (actionType === null || actionType === void 0 ? void 0 : actionType.isAction()) {
                    if (actionType.isBuiltIn()) {
                        errors.push(ValidationErrorFactory.InvalidWelcomeAction({
                            expr: actionValue,
                        }));
                    }
                    const returnType = (_d = actionType.getPropertyType("returnType")) === null || _d === void 0 ? void 0 : _d.getTypeType();
                    if (returnType) {
                        if (returnType.isVoid() || returnType.isNothing()) {
                            errors.push(ValidationErrorFactory.InvalidWelcomeActionReturnValue({
                                expr: actionValue,
                            }));
                        }
                    }
                }
            }
            else if (apply.isVariations()) {
                errors.push(...validateVariations(call, checker));
            }
        }
        else if (apply.isType() || apply.isGetListItem()) {
            // TODO: should we allow operators and get list item?
            if (apply.isResetArguments() || apply.isResetAllArguments() || apply.isEnsureArgOrder()) {
                const argumentsValue = apply.getArgumentValue("arguments");
                // for ResetArguments, all the arguments in the list should from same api
                if (apply.isResetArguments()) {
                    errors.push(...validateArgumentListThing(checker.getThing(argumentsValue), argumentsValue));
                }
                // for EnsureArgOrder, all the arguments in the list should be required args
                if (apply.isEnsureArgOrder()) {
                    errors.push(...validateEnsureArgOrder(apply, checker));
                }
            }
        }
        else if (call.findInContext(ask.isAnnotation) === undefined) {
            errors.push(...validateCallContext(call, checker));
        }
        if (apply.isUtterances()) {
            errors.push(...validateUtteranceTypeWrapper(apply, checker));
        }
        if (apply.getName() === AlexaConversations.utterances && checker.isNameReference((_e = apply.getArguments()) === null || _e === void 0 ? void 0 : _e.samples.value)) {
            errors.push(...validateNamedArguments(apply, checker, false)); // check the arguments but don't type check - we will do this in a custom way
            // special case - we're calling utterances with a name reference to a List.
            // we need to find that list and validate
            const value = (_f = apply.getArguments()) === null || _f === void 0 ? void 0 : _f.samples.value;
            const found = checker.resolveNameReference(value);
            const foundType = checker.getType(value);
            if (ask.isCall(found) && ask.isListLiteral(found.arguments) && (foundType === null || foundType === void 0 ? void 0 : foundType.isList())) {
                // if empty list, throw error
                if (found.arguments.items.length === 0) {
                    errors.push(ValidationErrorFactory.EmptyUtteranceSet({
                        expr: found.arguments,
                    }));
                }
                else if ((_g = foundType.getListItemType()) === null || _g === void 0 ? void 0 : _g.isString()) {
                    // yes, we are referencing a List<String> literal
                    const utteranceType = (_h = apply.getGenericArguments()) === null || _h === void 0 ? void 0 : _h[0];
                    for (const item of found.arguments.items) {
                        if (item.item !== undefined) {
                            // TODO: should we change the error message to provide more help? the error is associated with an afar list literal but attached to the name reference
                            errors.push(...validateUtterance(item.item, utteranceType, getPropertyMap).map((e) => {
                                var _a;
                                return ({
                                    ...e,
                                    loc: value.loc,
                                    uri: (_a = e.uri) !== null && _a !== void 0 ? _a : value.uri,
                                });
                            }));
                        }
                    }
                }
            }
            else {
                errors.push(ValidationErrorFactory.InvalidUtteranceArg({
                    expr: value,
                }));
            }
        }
        else {
            if (apply.getName() === AlexaConversations.utterances) {
                const utteranceList = (_k = (_j = apply.getArguments()) === null || _j === void 0 ? void 0 : _j.samples) === null || _k === void 0 ? void 0 : _k.value;
                if ((utteranceList === null || utteranceList === void 0 ? void 0 : utteranceList.kind) === "Call" && ask.isListLiteral(utteranceList.arguments) && utteranceList.arguments.items.length === 0) {
                    errors.push(ValidationErrorFactory.EmptyUtteranceSet({
                        expr: utteranceList.arguments,
                    }));
                }
            }
            errors.push(...validateNamedArguments(apply, checker));
            const genericArguments = apply.getGenericArguments();
            const genericEnvironment = apply.getGenericEnvironment();
            if (apply.decl.genericArguments !== undefined && genericArguments === undefined) {
                errors.push(ValidationErrorFactory.CouldNotInferGenericArguments({
                    expr: call,
                    attributes: {
                        argumentName: (_l = apply.decl.name) === null || _l === void 0 ? void 0 : _l.name,
                    },
                }));
            }
            else if (genericArguments && ((_m = apply.decl.genericArguments) === null || _m === void 0 ? void 0 : _m.length) === (genericArguments === null || genericArguments === void 0 ? void 0 : genericArguments.length)) {
                const decl = apply.decl.kind === "Type" ? apply.decl.declaration : apply.decl;
                if (decl &&
                    decl.kind !== "TypeParameter" &&
                    decl.kind !== "SlotType" &&
                    decl.kind !== "EnumDeclaration" &&
                    decl.kind !== "EnumItemDeclaration" &&
                    decl.kind !== "TypeReference") {
                    (_o = decl.genericArguments) === null || _o === void 0 ? void 0 : _o.forEach((genericArgument, i) => {
                        var _a, _b;
                        const actualType = genericArguments === null || genericArguments === void 0 ? void 0 : genericArguments[i];
                        if (actualType && genericArgument.constraints) {
                            for (const constraint of genericArgument.constraints) {
                                const expectedType = checker.instantiateTypeReference(constraint, genericEnvironment);
                                if (expectedType && !actualType.extends(expectedType)) {
                                    errors.push(typeError(actualType, expectedType, (_b = (_a = call === null || call === void 0 ? void 0 : call.genericArguments) === null || _a === void 0 ? void 0 : _a[i]) !== null && _b !== void 0 ? _b : call));
                                }
                            }
                        }
                    });
                }
            }
            const returnType = apply.getReturnType();
            if (apply.isType() && returnType) {
                // this is a Type expression, e.g. `Person { name = "sam" }` or `[1, 2]` or `"hello"`
                if (call.arguments === null && !(returnType.isVoid() || returnType.isNothing() || returnType.isOptional())) {
                    errors.push(typeError(returnType, checker.void, call));
                }
                else if (typeof call.arguments === "string" && !returnType.isStringLike()) {
                    errors.push(typeError(returnType, checker.string, call));
                }
                else if (typeof call.arguments === "number" && !returnType.isNumber()) {
                    errors.push(typeError(returnType, checker.number, call));
                }
                else if (typeof call.arguments === "boolean" && !returnType.isBoolean()) {
                    errors.push(typeError(returnType, checker.boolean, call));
                }
                else if (ask.isListLiteral(call.arguments) && !returnType.isList()) {
                    errors.push(ValidationErrorFactory.TypeErrorListType({
                        expr: call,
                    }));
                }
                if (returnType.isUtterance()) {
                    const utteranceType = returnType.getUtteranceType();
                    errors.push(...validateUtterance(call, utteranceType, getPropertyMap));
                }
                if (ask.isListLiteral(call.arguments) && returnType.isList()) {
                    const expectedType = returnType.getListItemType();
                    if (expectedType) {
                        for (const item of call.arguments.items) {
                            errors.push(...validateExpression(item.item, checker));
                            const actualType = checker.getType(item.item);
                            if (actualType) {
                                if (!actualType.extends(expectedType)) {
                                    errors.push(ValidationErrorFactory.TypeErrorListItem({
                                        expr: getExpressionIfLocField(item.item, item),
                                        attributes: {
                                            actualType: actualType.toString(item.item),
                                            expectedType: expectedType.toString(item.item),
                                        },
                                    }));
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return errors;
};
/**
 * validate the variations call
 * 1. The argument value can't use duplicate locale info
 * 2. SkillLevelResponses can't be used as an argument of variations call
 * 3. prompts.abc can't be used as an argument of variations call
 *
 * Invalid case example:
 * 1. duplicate locales
 * ```
 *  @locale(Locale.en_US)
 *  promptUS = utterances<Person>([
 *     "hi I am American my name is {name}",
 *     "hi I am American my name is {name} and i am {age} years old"
 *  ])
 *
 *  @locale(Locale.en_US, Locale.en_GB)
 *  promptGB = utterances<Person>([
 *    "hi I am British my name is {name}",
 *    "hi I am British my name is {name} and i am {age} years old"
 *  ])
 *  u = variations(promptUS, promptGB)
 * ```
 *
 * 2. SkillLevelResponses used as argument
 * ```
 * skillLevelResponsesEN = SkillLevelResponses { ... }
 * skillLevelResponsesGB = SkillLevelResponses { ... }
 *
 * skillLevelResponses = variations(skillLevelResponsesEN, skillLevelResponsesGB)
 * ```
 *
 * 3. prompts used as argument
 * ```
 * skillLevelResponses = variations(prompts.AlexaConversationsWelcome, prompts.AlexaConversationsOutOfDomain)
 * ```
 */
export const validateVariations = (call, checker) => {
    const apply = checker.getApply(call);
    if (apply === undefined) {
        return [];
    }
    const errors = [];
    const usedLocale = new Map();
    const argumentValueThing = apply.getArgumentValueThing("variations");
    if (argumentValueThing === null || argumentValueThing === void 0 ? void 0 : argumentValueThing.isList()) {
        const items = argumentValueThing.getListItems();
        items === null || items === void 0 ? void 0 : items.forEach((item) => {
            var _a, _b, _c;
            if (((_a = item === null || item === void 0 ? void 0 : item.item) === null || _a === void 0 ? void 0 : _a.kind) === "NameReference" || ((_b = item === null || item === void 0 ? void 0 : item.item) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                // TODO: validate the item is not SkillLevelResponses or prompts
                const thing = checker.getThing(item.item);
                if (thing === null || thing === void 0 ? void 0 : thing.type.isSkillLevelResponses()) {
                    // SkillLevelResponses can't be used as an argument of variations call
                    errors.push(ValidationErrorFactory.InvalidVariationsArgumentSkillLevelResponses({
                        expr: getExpressionIfLocField(item.item, item),
                    }));
                }
                else if (((_c = checker.resolveNameReference(item.item)) === null || _c === void 0 ? void 0 : _c.kind) === "ResponseTemplate") {
                    errors.push(ValidationErrorFactory.InvalidVariationsArgumentResponsePrompts({
                        expr: getExpressionIfLocField(item.item, item),
                    }));
                }
                else {
                    const locales = checker.collectLocaleInfo(item.item);
                    locales.forEach((locale) => {
                        var _a, _b;
                        if (usedLocale.has(locale)) {
                            errors.push(ValidationErrorFactory.DuplicateLocale({
                                expr: getExpressionIfLocField(item.item, item),
                                attributes: {
                                    locale,
                                    variationItem: usedLocale.get(locale),
                                },
                            }));
                        }
                        else {
                            usedLocale.set(locale, (_b = (_a = item.item) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name);
                        }
                    });
                }
            }
        });
    }
    return errors;
};
/**
 * Validate that a call to a User Defined API or Dialog is not contained within another call.
 *
 * Validate that this Call is allowed in this Context.
 *
 * @param call
 * @param checker
 * @returns
 */
export const validateCallContext = (call, checker) => {
    const apply = checker.getApply(call);
    if (apply !== undefined) {
        const callType = apply.isUserDefinedApi()
            ? `user defined API '${apply.getName()}'`
            : apply.isDialog()
                ? "a dialog"
                : apply.isBuiltin()
                    ? `'${apply.getShortName()}'`
                    : "an action";
        return walkCallContext(call.context);
        function walkCallContext(context) {
            if (context === undefined || ask.isDialogDeclaration(context)) {
                return [];
            }
            if (context.kind === "InteractionDeclaration" || context.kind === "Correction") {
                // TODO: add validation checks - https://github.com/alexa/ask-ac/issues/869
                return [];
            }
            if (ask.isModule(context)) {
                return [
                    ValidationErrorFactory.InvalidCallContextInModule({
                        expr: call,
                        attributes: {
                            callType,
                        },
                    }),
                ];
            }
            if (context.kind === "When") {
                if (!(apply.isOperator() || apply.isNativeAction())) {
                    return [
                        ValidationErrorFactory.InvalidCallContextInCondition({
                            expr: call,
                            attributes: {
                                callType,
                            },
                        }),
                    ];
                }
            }
            else if (context.kind === "Call") {
                const contextApply = checker.getApply(context);
                if ((contextApply === null || contextApply === void 0 ? void 0 : contextApply.isUserDefinedApi()) || (contextApply === null || contextApply === void 0 ? void 0 : contextApply.isDialog()) || (contextApply === null || contextApply === void 0 ? void 0 : contextApply.isType())) {
                    const contextType = contextApply.isType() ? (contextApply.isList() ? "a list item" : "a property") : "an argument";
                    const errorArguments = {
                        expr: call,
                        attributes: {
                            callType,
                            contextType,
                        },
                    };
                    if (apply.isOperator()) {
                        return [ValidationErrorFactory.InvalidCallContextComparison(errorArguments)];
                    }
                    if (apply.isNativeAction()) {
                        return [ValidationErrorFactory.InvalidCallContextType(errorArguments)];
                    }
                    return [ValidationErrorFactory.InvalidCallContextTypeInline(errorArguments)];
                }
            }
            return walkCallContext(context.context);
        }
    }
    return [];
};
/**
 * Validates that a `validateArg` annotation matches the following rules:
 * 1. action must have at least one argument
 * 2. condition must reference at least one of those arguments in its boolean expression
 * 3. at least one argument must be referenced
 * 4. that argument must be from the same action that this validateArg annotation is attached to.
 *
 * @param apply Apply instance for the validateArg annotation call.
 * @param checker static TypeChecker instance
 * @returns validation errors
 * @see https://github.com/alexa/ask-ac/issues/690
 */
export const validateValidateArgAnnotation = (apply, checker) => {
    var _a;
    if (!apply.isValidateArg()) {
        return [];
    }
    const action = (_a = apply.checker.getThing(apply.call.context.context)) === null || _a === void 0 ? void 0 : _a.asAction();
    if (action === undefined) {
        // we don't need to error here - validateArg's annotation targets restricts it to an Action
        return [];
    }
    if (action.origin.arguments === undefined || action.origin.arguments.length === 0) {
        return [
            ValidationErrorFactory.InvalidAnnotationValidateArg({
                expr: apply.call,
            }),
        ];
    }
    const argumentsNode = apply.getArgumentValue("arguments");
    const conditionNode = apply.getArgumentValue("condition");
    const condition = apply.getArgumentValueThing("condition");
    const args = apply.getArgumentValueThing("arguments");
    const argsNode = apply.getArgumentValue("arguments");
    const requestPromptNode = apply.getArgumentValue("requestPrompt");
    const requestPrompt = apply.getArgumentValueThing("requestPrompt");
    return [
        ...validateArguments(),
        ...validateConditionReferencesAtLeastOneArgument(),
        ...validateConditionOperations(conditionNode, undefined),
        ...validateRequestPrompt(),
    ];
    function validateConditionReferencesAtLeastOneArgument() {
        var _a;
        if (conditionNode === undefined) {
            // type error
            return [];
        }
        if (condition === null || condition === void 0 ? void 0 : condition.isNothing()) {
            return [
                ValidationErrorFactory.IllegalNothingValueBoolean({
                    expr: getExpressionIfLocField(conditionNode, apply.call),
                }),
            ];
        }
        if (!hasAtLeastOneArgumentNameReference(conditionNode)) {
            return [
                ValidationErrorFactory.InvalidAnnotationValidateArgCondition({
                    expr: conditionNode,
                    attributes: {
                        actionArguments: (_a = action === null || action === void 0 ? void 0 : action.origin.arguments) === null || _a === void 0 ? void 0 : _a.map((arg) => { var _a; return `'${(_a = arg.name) === null || _a === void 0 ? void 0 : _a.name}'`; }).join(","),
                        actionName: action.actionName,
                    },
                }),
            ];
        }
        return [];
    }
    function hasAtLeastOneArgumentNameReference(node) {
        if (node.kind === "NameReference") {
            const referencedNode = checker.resolveNameReference(node);
            if ((referencedNode === null || referencedNode === void 0 ? void 0 : referencedNode.kind) === "ArgumentDeclaration") {
                return true;
            }
        }
        return collect(node, hasAtLeastOneArgumentNameReference, (a, b) => a || b, false);
    }
    function validateConditionOperations(node, errorExpr) {
        if (node === undefined) {
            return [];
        }
        if (node.kind === "NameReference") {
            return validateConditionOperations(checker.resolveNameReference(node), getExpressionIfLocField(errorExpr, node));
        }
        if (node.kind === "PropertyReference") {
            return validateConditionOperations(checker.resolveNameReferenceToCall(node), getExpressionIfLocField(errorExpr, node));
        }
        if (node.kind === "Call") {
            const apply = checker.getApply(node);
            if (apply === undefined) {
                // type error
                return [];
            }
            if (apply.isType()) {
                if (node.arguments === null ||
                    typeof node.arguments === "string" ||
                    typeof node.arguments === "number" ||
                    typeof node.arguments === "boolean" ||
                    ask.isListLiteral(node.arguments)) {
                    if (ask.isListLiteral(node.arguments)) {
                        // check that each of the values in the list are also valid
                        return node.arguments.items.map((item) => validateConditionOperations(item.item, errorExpr)).flat();
                    }
                    // literal value comparisons are allowed
                    return [];
                }
                return [
                    ValidationErrorFactory.InvalidBooleanExpressionTypeLiteral({
                        expr: getExpressionIfLocField(errorExpr, node, conditionNode),
                        attributes: {
                            typeName: apply.getName(),
                        },
                    }),
                ];
            }
            if (apply.isBinaryOperator()) {
                return [
                    ...validateConditionOperations(apply.getArgumentValue("left"), errorExpr),
                    ...validateConditionOperations(apply.getArgumentValue("right"), errorExpr),
                ];
            }
            if (apply.isNot() || apply.isIs() || apply.isExists()) {
                return validateConditionOperations(apply.getArgumentValue("right"), errorExpr);
            }
            if (apply.isSize()) {
                return validateConditionOperations(apply.getArgumentValue("list"), errorExpr);
            }
            if (apply.isGetListItem()) {
                return [
                    ...validateConditionOperations(apply.getArgumentValue("list"), errorExpr),
                    ...validateConditionOperations(apply.getArgumentValue("index"), errorExpr),
                ];
            }
            if (apply.isLength()) {
                return validateConditionOperations(apply.getArgumentValue("s"), errorExpr);
            }
            return [
                ValidationErrorFactory.InvalidBooleanExpressionAction({
                    expr: getExpressionIfLocField(errorExpr, node, conditionNode),
                    attributes: {
                        actionName: apply.getName(),
                    },
                }),
            ];
        }
        return [];
    }
    function validateRequestPrompt() {
        if (requestPromptNode === undefined) {
            // type error
            return [];
        }
        if (requestPrompt === null || requestPrompt === void 0 ? void 0 : requestPrompt.isNothing()) {
            return [
                ValidationErrorFactory.IllegalNothingValueResponsePrompt({
                    expr: getExpressionIfLocField(requestPromptNode, apply.call),
                }),
            ];
        }
        return [];
    }
    function validateArguments() {
        var _a, _b;
        if (argumentsNode === undefined || (args === null || args === void 0 ? void 0 : args.isNothing())) {
            return [
                ValidationErrorFactory.ExpectedNonEmptyList({
                    expr: apply.call,
                    attributes: {
                        actionName: (_a = action.name) === null || _a === void 0 ? void 0 : _a.name,
                    },
                }),
            ];
        }
        if (!(args === null || args === void 0 ? void 0 : args.isLiteral())) {
            return [
                ValidationErrorFactory.ExpectedLiteralValue({
                    expr: getExpressionIfLocField(argumentsNode, apply.call),
                }),
            ];
        }
        if (!args.isList()) {
            return [];
        }
        const items = args.getItems();
        if (!(items === null || items === void 0 ? void 0 : items.length)) {
            return [
                ValidationErrorFactory.ExpectedNonEmptyList({
                    expr: getExpressionIfLocField(argumentsNode, apply.call),
                    attributes: {
                        actionName: (_b = action.name) === null || _b === void 0 ? void 0 : _b.name,
                    },
                }),
            ];
        }
        return items.flatMap((arg, i) => {
            var _a;
            // if this arguments is an inline literal list, we will place the error on the specific item in the list
            const argsExpr = (argsNode === null || argsNode === void 0 ? void 0 : argsNode.kind) === "Call" && ask.isListLiteral(argsNode.arguments)
                ? (_a = argsNode.arguments.items[i]) === null || _a === void 0 ? void 0 : _a.item
                : getExpressionIfLocField(argumentsNode, apply.call);
            if (arg === undefined) {
                return []; // type error;
            }
            if (arg.isNothing()) {
                return [
                    ValidationErrorFactory.IllegalNothingValueActionArgument({
                        expr: argsExpr,
                        attributes: {
                            actionName: action === null || action === void 0 ? void 0 : action.actionName,
                        },
                    }),
                ];
            }
            if (arg.isArgument() && arg.action && !arg.action.equals(action)) {
                return [
                    ValidationErrorFactory.MismatchedActionArgumentsValidateArguments({
                        expr: argsExpr,
                        attributes: {
                            argumentName: arg.argumentName,
                            actualActionName: arg.action.actionName,
                            expectedActionName: action.actionName,
                        },
                    }),
                ];
            }
            return [];
        });
    }
    return [];
};
/**
 * Validate a call to `require` - an internal action to reference a file from disk.
 */
export const validateRequireCall = (apply, checker) => {
    var _a, _b;
    const name = apply.getName();
    if (name === AlexaConversations.apl || name === AlexaConversations.apla) {
        const pathArg = (_a = apply.getArguments()) === null || _a === void 0 ? void 0 : _a.path;
        if (((_b = pathArg === null || pathArg === void 0 ? void 0 : pathArg.value) === null || _b === void 0 ? void 0 : _b.kind) === "Call") {
            const filePath = ask.isUtterance(pathArg.value.arguments)
                ? pathArg.value.arguments.text
                : typeof pathArg.value.arguments === "string"
                    ? pathArg.value.arguments
                    : undefined;
            if (filePath !== undefined) {
                const uri = checker.getUri(apply.call);
                if (uri !== undefined) {
                    let absolutePath;
                    if (path.isAbsolute(filePath)) {
                        absolutePath = filePath;
                    }
                    else {
                        absolutePath = path.join(uri, "..", filePath);
                    }
                    if (!fs.existsSync(absolutePath)) {
                        // TODO: don't use synchronous IO in the validators
                        // see: https://github.com/alexa/ask-ac/issues/504
                        return [
                            ValidationErrorFactory.PathNotAccessible({
                                expr: pathArg.value,
                                attributes: {
                                    filePath,
                                },
                            }),
                        ];
                    }
                    // developer could provide folder name only
                    // auto fill the 'document.json' in path
                    const status = fs.statSync(absolutePath);
                    let documentPath;
                    if (status.isFile()) {
                        documentPath = absolutePath;
                    }
                    else {
                        documentPath = path.join(absolutePath, Constants.APLADocumentFileName);
                    }
                    // The document can only use the name 'document.json'
                    if (path.basename(documentPath) !== Constants.APLADocumentFileName) {
                        const errorArguments = {
                            expr: pathArg.value,
                            attributes: {
                                documentName: path.basename(documentPath),
                            },
                        };
                        return [
                            name === AlexaConversations.apl
                                ? ValidationErrorFactory.InvalidAplDocumentName(errorArguments)
                                : ValidationErrorFactory.InvalidAplaDocumentName(errorArguments),
                        ];
                    }
                    // if no document.json found
                    if (!fs.existsSync(documentPath)) {
                        return [
                            ValidationErrorFactory.FileNotFound({
                                expr: pathArg.value,
                                attributes: {
                                    filePath,
                                },
                            }),
                        ];
                    }
                    // Type check to make sure apla action point to APLA document
                    // and apl action point to APL document
                    try {
                        const content = fs.readFileSync(documentPath);
                        const json = JSON.parse(content.toString("utf8"));
                        const { type } = json;
                        const errorArguments = {
                            expr: pathArg.value,
                            attributes: {
                                filePath,
                                fileType: type === undefined ? type : `"${type}"`,
                            },
                        };
                        if (name === AlexaConversations.apl && type !== APLFileType.APL) {
                            return [ValidationErrorFactory.InvalidFileTypeApl(errorArguments)];
                        }
                        if (name === AlexaConversations.apla && !APLAFileTypes.includes(type)) {
                            return [ValidationErrorFactory.InvalidFileTypeApla(errorArguments)];
                        }
                    }
                    catch (err) {
                        return [
                            ValidationErrorFactory.FileReadError({
                                expr: pathArg.value,
                                attributes: {
                                    filePath,
                                },
                                overrideMessage: err.message,
                            }),
                        ];
                    }
                }
            }
        }
    }
    return [];
};
/**
 * Validate the arguments passed to a Call against the target declaration.
 *
 * - Finds missing required arguments.
 * - Detect unknown arguments, whether by name or position. Account for var-args.
 * - Detect when positional arguments are used after named ones.
 * - Check that the types of arguments.
 *
 * @param apply
 * @param checker
 * @param checkType should we type check? default true
 */
export const validateNamedArguments = (apply, checker, checkType = true) => {
    var _a, _b, _c;
    if (apply.isType() && ((_a = apply.getReturnType()) === null || _a === void 0 ? void 0 : _a.isPrimitive())) {
        return [];
    }
    const { call } = apply;
    const errors = [];
    let isPositionalAllowed = true;
    let position = 0;
    const seenNamedArgs = new Set();
    if (Array.isArray(call.arguments)) {
        for (const argument of call.arguments) {
            // recursively descend and validate this argument
            errors.push(...validateExpression(argument, checker));
            if ((_b = argument.name) === null || _b === void 0 ? void 0 : _b.name) {
                isPositionalAllowed = false;
                const decl = apply.argumentDeclIndex[argument.name.name];
                if (decl === undefined) {
                    unknown();
                }
                if (seenNamedArgs.has(argument.name.name)) {
                    errors.push(ValidationErrorFactory.InvalidApiArgumentRedeclare({
                        expr: argument,
                        attributes: {
                            argumentName: argument.name.name,
                        },
                    }));
                }
                else {
                    seenNamedArgs.add(argument.name.name);
                }
            }
            else if (isPositionalAllowed) {
                const decl = (_c = apply.argumentDeclarations) === null || _c === void 0 ? void 0 : _c[position];
                const env = apply.getGenericEnvironment();
                const declType = (decl === null || decl === void 0 ? void 0 : decl.kind) === "ArgumentDeclaration" ? checker.instantiateTypeReference(decl.type, env) : decl === null || decl === void 0 ? void 0 : decl.type;
                if (declType === undefined) {
                    unknown();
                }
                if ((declType === null || declType === void 0 ? void 0 : declType.isArgs()) !== true) {
                    // if this is not var args, increment the declaration position
                    // otherwise, subsequent arguments are considered an item in the var-args list
                    position += 1;
                }
            }
            else {
                errors.push(ValidationErrorFactory.PositionalArgumentAfterName({
                    expr: argument,
                }));
                // If positional arguments are used after a named argument, skip the rest validation
                return errors;
            }
            function unknown() {
                var _a, _b, _c;
                let error;
                const expr = getExpressionIfLocField(argument.name, argument);
                if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
                    error = apply.isType()
                        ? ValidationErrorFactory.UnknownProperty({
                            expr,
                            attributes: {
                                propertyName: argument.name.name,
                                typeName: (_c = (_b = apply.getReturnType()) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name,
                            },
                        })
                        : ValidationErrorFactory.UnknownArgument({
                            expr,
                            attributes: {
                                argumentName: argument.name.name,
                                callName: apply.getName(),
                            },
                        });
                }
                else {
                    const errorArguments = {
                        expr,
                        attributes: {
                            index: argument.index,
                        },
                    };
                    error = apply.isType()
                        ? ValidationErrorFactory.UnknownPropertyIndex(errorArguments)
                        : ValidationErrorFactory.UnknownArgumentIndex(errorArguments);
                }
                errors.push(error);
            }
        }
    }
    const missing = new Set(apply.requiredArguments);
    const sanitizedArguments = apply.getArguments();
    if (sanitizedArguments !== undefined) {
        // arguments are grouped by name and var-args are assembled into a List.
        // now go through each argument and type check it.
        for (const [name, argument] of Object.entries(sanitizedArguments || {})) {
            missing.delete(name);
            if (checkType) {
                // special case: when property of an event result is of type optional, and there's request prompt available for that property
                // Then we should treat this property as not optional
                let actualType = checker.getType(argument.value);
                if (actualType === null || actualType === void 0 ? void 0 : actualType.isOptional()) {
                    // for backwards compatibility
                    // Temporarily make Optional<T> assignable to T
                    // TODO: get argumentEnsured condition back once we are ready to ship breaking changes
                    // if (checker.isArgumentEnsured(call, apply.decl, name)) {
                    while (actualType === null || actualType === void 0 ? void 0 : actualType.isOptional()) {
                        actualType = actualType.getOptionalType();
                    }
                }
                const expectedType = apply === null || apply === void 0 ? void 0 : apply.getType(argument);
                if (actualType && expectedType) {
                    if (!actualType.extends(expectedType)) {
                        errors.push(typeError(actualType, expectedType, apply.call, argument));
                    }
                }
            }
        }
    }
    if (missing.size > 0) {
        errors.push(apply.isType()
            ? ValidationErrorFactory.MissingProperties({
                expr: call,
                attributes: { properties: Array.from(missing.values()).join(",") },
            })
            : ValidationErrorFactory.MissingArguments({
                expr: call,
                attributes: { args: Array.from(missing.values()).join(",") },
            }));
    }
    errors.push(...validateBinaryOperator(apply));
    return errors;
};
export function validateBinaryOperator(apply) {
    var _a, _b;
    if (apply.isBinaryOperator()) {
        // special-case logic for binary operators - the types must match
        // for example, if we have `1 == "hello"`, then it will be inferred as
        // `equals<Thing>(1, "hello")` // there is no type error here
        // for these cases, we will explicitly check that either:
        // 1. left extends right
        // 2. right extends left
        const left = (_a = apply.getArgumentValueThing("left")) === null || _a === void 0 ? void 0 : _a.type;
        const right = (_b = apply.getArgumentValueThing("right")) === null || _b === void 0 ? void 0 : _b.type;
        if (left && right) {
            if (!left.extends(right) && !right.extends(left)) {
                return [
                    ValidationErrorFactory.TypeErrorIncomparableExpr({
                        expr: apply.call,
                        attributes: {
                            leftExpr: left.toString(apply.call),
                            rightExpr: right.toString(apply.call),
                        },
                    }),
                ];
            }
        }
    }
    return [];
}
/**
 * Validates the utterance in expr
 * @param expr expression containing the utterance to validate
 * @param utteranceType type for utterance
 * @param getPropertyMap memoized type's getPropertyMap
 * @returns
 */
export const validateUtterance = (expr, utteranceType, getPropertyMap) => {
    var _a;
    let errors = [];
    // throw error if the item in a list is not literal string
    if (expr.kind !== "Call" || (!(typeof expr.arguments === "string") && !ask.isUtterance(expr.arguments))) {
        return [ValidationErrorFactory.InvalidUtteranceItem({ expr })];
    }
    let utterance;
    if (ask.isUtterance(expr.arguments)) {
        utterance = expr.arguments.text;
    }
    else {
        utterance = expr.arguments;
    }
    // Validate the utterance text here. Currently only validating it's not an empty string
    if (utterance.trim().length === 0) {
        return [ValidationErrorFactory.EmptyUtteranceString({ expr })];
    }
    if (!utteranceType) {
        return errors;
    }
    const utteranceTypeRequiredProperties = utteranceType.getRequiredProperties();
    if (typeof expr.arguments === "string" && utteranceTypeRequiredProperties.size > 0) {
        errors.push(ValidationErrorFactory.MissingPropertiesOnType({
            expr,
            attributes: {
                requiredProperties: Array.from(utteranceTypeRequiredProperties.values())
                    .map((p) => `${p.name}`)
                    .join(", "),
                typeName: utteranceType.toString(expr),
            },
        }));
    }
    else if (ask.isUtterance(expr.arguments)) {
        const propertyPaths = [];
        const pathsSeen = new Set();
        for (const name of expr.arguments.names || []) {
            if (!name.name) {
                continue;
            }
            if (pathsSeen.has(name.name)) {
                errors.push(ValidationErrorFactory.DuplicateProperty({
                    expr: name,
                    attributes: {
                        propertyName: name.name,
                    },
                }));
            }
            pathsSeen.add(name.name);
            propertyPaths.push(name.name);
        }
        const { errors: propertyTreeErrors, root: propertyTreeRoot } = PropertyNode.buildPropertyTree(expr.arguments.names || [], utteranceType, expr, getPropertyMap);
        errors = [...errors, ...propertyTreeErrors];
        // Verify required properties at each tree level.
        // The tree traversal algorithm is the standard queue breadth first
        // (level by level) logic where we quee the root and while the queue
        // is not empty we unqueue element and queue its children.
        const queue = [propertyTreeRoot];
        while (queue.length !== 0) {
            const propertyNode = queue.shift();
            const requiredProperties = propertyNode === null || propertyNode === void 0 ? void 0 : propertyNode.propertyType.getRequiredProperties();
            for (const child of propertyNode.children.values()) {
                // mark this child as present by removing from requiredProperties
                requiredProperties.delete(child.property.name);
                // queue child which is a part of standard queue traversal
                queue.push(child);
            }
            for (const requiredProperty of requiredProperties.values()) {
                // if it's a list, then it's allowed to be omitted - omitted means empty list?
                if (!((_a = requiredProperty.type) === null || _a === void 0 ? void 0 : _a.isList())) {
                    errors.push(ValidationErrorFactory.MissingPropertiesOnUtteranceType({
                        expr,
                        attributes: {
                            utterance: expr.arguments.text,
                            propertyName: requiredProperty.name,
                            typeName: utteranceType.toString(expr),
                        },
                    }));
                }
            }
        }
    }
    return errors;
};
export const validateCondition = (condition, checker) => {
    const errors = [];
    if (condition.when !== undefined) {
        errors.push(...validateExpression(condition.when, checker));
    }
    if (condition.then === undefined) {
        console.warn("undefined then");
    }
    else {
        errors.push(...validateConditionBlock(condition.then, checker));
        errors.push(...validateBlock(condition.then, checker));
    }
    if (condition.else) {
        errors.push(...validateConditionBlock(condition.else, checker));
        errors.push(...validateBlock(condition.else, checker));
    }
    const whenType = checker.getType(condition.when);
    if ((whenType === null || whenType === void 0 ? void 0 : whenType.isBoolean()) === false) {
        errors.push(ValidationErrorFactory.TypeErrorWhenBoolean({
            expr: getExpressionIfLocField(condition.when, condition),
            attributes: {
                whenType: whenType.toString(condition.when),
                whenCondition: checker.boolean.toString(condition.when),
            },
        }));
    }
    return errors;
};
/**
 * Validate that a Condition Block has expressions.
 */
export const validateConditionBlock = (scope) => {
    var _a;
    return scope.expressions === undefined || ((_a = scope.expressions) === null || _a === void 0 ? void 0 : _a.length) === 0
        ? [
            ValidationErrorFactory.EmptyConditionBlock({
                expr: scope,
            }),
        ]
        : [];
};
/**
 * Validate EnsureOrder action call
 * 1. All the args in the list should from same api
 * 2. All the args in the list should be required args
 *
 * Related Github feature request:
 * https://github.com/alexa/ask-ac/issues/553
 */
export const validateEnsureArgOrder = (apply, checker) => {
    const errors = [];
    if (apply.isEnsureArgOrder()) {
        const argumentsValue = apply.getArgumentValue("arguments");
        const argumentsValueThing = checker.getThing(argumentsValue);
        // all the arguments in the list should be required args
        errors.push(...validateArgumentListThing(argumentsValueThing, argumentsValue));
        if ((argumentsValueThing === null || argumentsValueThing === void 0 ? void 0 : argumentsValueThing.isLiteral()) && argumentsValueThing.isList()) {
            const items = argumentsValueThing.getItems();
            items === null || items === void 0 ? void 0 : items.forEach((item) => {
                var _a, _b, _c;
                if (item === null || item === void 0 ? void 0 : item.isArgument()) {
                    const referencedArgumentDeclaration = item.getReferencedActionArgumentDeclaration();
                    const type = checker.getType(referencedArgumentDeclaration === null || referencedArgumentDeclaration === void 0 ? void 0 : referencedArgumentDeclaration.type);
                    if (type === null || type === void 0 ? void 0 : type.isOptional()) {
                        errors.push(ValidationErrorFactory.InvalidEnsureArgOptional({
                            expr: item,
                            attributes: {
                                argumentName: (_a = referencedArgumentDeclaration === null || referencedArgumentDeclaration === void 0 ? void 0 : referencedArgumentDeclaration.name) === null || _a === void 0 ? void 0 : _a.name,
                                actionName: (_c = (_b = referencedArgumentDeclaration === null || referencedArgumentDeclaration === void 0 ? void 0 : referencedArgumentDeclaration.context) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name,
                            },
                        }));
                    }
                }
            });
        }
    }
    return errors;
};
export const validateInteractionDeclaration = (action, checker) => [
    ...validateAnnotations(action, checker),
    ...validateExpression(action.scope, checker),
];
export const validateCorrection = (action, checker) => [
    ...validateExpression(action.actual, checker),
    ...validateExpression(action.expected, checker),
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdmFsaWRhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQzFCLE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUN4QixPQUFPLEtBQUssR0FBRyxNQUFNLE9BQU8sQ0FBQztBQUU3QixPQUFPLEVBQTJCLHFCQUFxQixFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBTTdHLE9BQU8sRUFBQyxrQkFBa0IsRUFBZSxnQkFBZ0IsRUFBa0IsTUFBTSxPQUFPLENBQUM7QUFDekYsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUNsQyxPQUFPLEVBQUMsYUFBYSxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFFbEUsT0FBTyxFQUFDLGtCQUFrQixFQUFFLHFCQUFxQixFQUFFLDJCQUEyQixFQUFFLHlCQUF5QixFQUFDLE1BQU0sWUFBWSxDQUFDO0FBQzdILE9BQU8sRUFBQyxJQUFJLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxFQUFDLGFBQWEsRUFBRSx3QkFBd0IsRUFBQyxNQUFNLGtCQUFrQixDQUFDO0FBQ3pFLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUNuRCxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBQ2hDLE9BQU8sRUFBQyx1QkFBdUIsRUFBa0Isc0JBQXNCLEVBQThCLE1BQU0saUJBQWlCLENBQUM7QUFFN0gsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQzdDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFJL0I7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSxlQUFlLENBQUMsT0FBZ0IsRUFBRSxPQUFpQixF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