import * as immutable from "immutable";
import * as ask from "./ast";
import { Apply } from "./apply";
import { AlexaConversations, AlexaSchema, ThenScope } from "./ast";
import { computeGlobal } from "./global";
import { computeLexicalScope, emptyLexicalScope, mergeLexicalScope } from "./lexical-scope";
import { getName, getNamespace, isQualifiedNamePattern, stringifyTypeParameter } from "./util";
import { Type } from "./type";
// TODO: decide whether we should implement our own immutable set instead of depending on `immutable-js`
import { memoize } from "./lazy";
import { visitEachChild, collectArray } from "./visit";
import { ActionThing, DialogThing, NothingThing, UnionThing, VoidThing } from "./thing";
import { tokens } from "./token";
let i = 0;
/**
 * API for querying a Module for error checking, type checking, descriptions and suggestions.
 */
export class TypeChecker {
    constructor(
    /**
     * Project context of the module being checked.
     */
    project, 
    /**
     * Previous TypeChecker environment.
     */
    prev, 
    /**
     * Map of Node to resolved Thing.
     */
    things, 
    /**
     * Map of TypeParameter to resolved Type.
     */
    types) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        Object.defineProperty(this, "project", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: project
        });
        Object.defineProperty(this, "prev", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: prev
        });
        Object.defineProperty(this, "types", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: types
        });
        Object.defineProperty(this, "ID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (i += 1)
        });
        /**
         * Name bindings for expressions in the project.
         */
        Object.defineProperty(this, "global", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "nothing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "nothingToken", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "thing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "void", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "voidToken", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "boolean", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "number", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "string", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "enumeration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Global index of Node to its {@link LexicalScope}.
         *
         * i.e. the names available in its lexical environment and a map of the node they point to.
         */
        Object.defineProperty(this, "lexicalScopeIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Global index of a Module-scoped Node to its corresponding Thing value.
         *
         * This index is shared across all instances of a {@link TypeChecker} within a {@link Project}. I.e. it is a global index.
         */
        Object.defineProperty(this, "globalThingIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Global index of a Node to its corresponding Type.
         */
        Object.defineProperty(this, "globalTypeIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Local index of a Node to its corresponding Thing value within the lexical environment represented by this {@link TypeCehcker}.
         */
        Object.defineProperty(this, "localThingIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        /**
         * Local index of a Node to its corresponding Apply within the leixcal environment represented by this {@link TypeChecker}.
         */
        Object.defineProperty(this, "localApplyIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "tokens", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.globalTypeIndex = (_a = prev === null || prev === void 0 ? void 0 : prev.globalTypeIndex) !== null && _a !== void 0 ? _a : new WeakMap();
        this.tokens = (_b = prev === null || prev === void 0 ? void 0 : prev.tokens) !== null && _b !== void 0 ? _b : tokens();
        this.global = (_c = prev === null || prev === void 0 ? void 0 : prev.global) !== null && _c !== void 0 ? _c : computeGlobal(project);
        this.globalThingIndex = (_d = prev === null || prev === void 0 ? void 0 : prev.globalThingIndex) !== null && _d !== void 0 ? _d : new Map();
        this.lexicalScopeIndex = (_e = prev === null || prev === void 0 ? void 0 : prev.lexicalScopeIndex) !== null && _e !== void 0 ? _e : new WeakMap();
        this.thing = (_f = prev === null || prev === void 0 ? void 0 : prev.thing) !== null && _f !== void 0 ? _f : this.instantiateAlexaSchemaType(AlexaSchema.Thing);
        this.nothing = (_g = prev === null || prev === void 0 ? void 0 : prev.nothing) !== null && _g !== void 0 ? _g : this.instantiateAlexaSchemaType(AlexaSchema.Nothing);
        this.void = (_h = prev === null || prev === void 0 ? void 0 : prev.void) !== null && _h !== void 0 ? _h : this.instantiateAlexaSchemaType(AlexaSchema.Void);
        this.nothingToken = (_j = prev === null || prev === void 0 ? void 0 : prev.nothingToken) !== null && _j !== void 0 ? _j : this.nextToken();
        this.voidToken = (_k = prev === null || prev === void 0 ? void 0 : prev.voidToken) !== null && _k !== void 0 ? _k : this.nextToken();
        this.boolean = (_l = prev === null || prev === void 0 ? void 0 : prev.boolean) !== null && _l !== void 0 ? _l : this.instantiateAlexaSchemaType(AlexaSchema.Boolean);
        this.number = (_m = prev === null || prev === void 0 ? void 0 : prev.number) !== null && _m !== void 0 ? _m : this.instantiateAlexaSchemaType(AlexaSchema.Number);
        this.string = (_o = prev === null || prev === void 0 ? void 0 : prev.string) !== null && _o !== void 0 ? _o : this.instantiateAlexaSchemaType(AlexaSchema.String);
        this.enumeration = (_p = prev === null || prev === void 0 ? void 0 : prev.enumeration) !== null && _p !== void 0 ? _p : memoize(() => this.instantiateAlexaSchemaType(AlexaConversations.Enumeration));
        // this.apl = prev?.apl ?? memoize(() => this.instantiateAlexaSchemaType(AlexaConversations.APL));
        // this.apla = prev?.apla ?? memoize(() => this.instantiateAlexaSchemaType(AlexaConversations.APLA));
        if (prev === undefined) {
            const checker = this;
            for (const expr of this.global.scope.values()) {
                if (expr === undefined) {
                    // return;
                }
                else if (Array.isArray(expr)) {
                    expr.forEach((expr) => { var _a; return checker.globalThingIndex.set(expr, (_a = checker.getThing(expr)) !== null && _a !== void 0 ? _a : null); });
                }
                else {
                    checker.globalThingIndex.set(expr, (_q = checker.getThing(expr)) !== null && _q !== void 0 ? _q : null);
                }
            }
        }
        if (things) {
            for (const [node, thing] of things.entries()) {
                this.localThingIndex.set(node, thing);
            }
        }
    }
    /**
     * Returns a reference to the root TypeChecker instance. TypeCheckers form a chain as we descend into
     * Dialog Sample Blocks and Conditional Blocks. This `root` instance refers to the global TypeChecker.
     *
     * We use this, for example, to look at the raw type signature of an ArgumentDeclaration instead of
     * looking at the type of the value passed into that argument within a Dialog Flow:
     *
     * ```
     * action myAction(String string)
     *
     * Foo(MyAction)
     *
     * dialog Foo(
     *   action bar(String arg)
     * ) {
     *   sample {
     *     // TypeChecker.root.getThing(NameReference(bar)) will return `action bar(String arg)`
     *     // If the TypeChecker is for the scope of this sample when `Foo` was called, then it would refer to `myAction` instead since that was passed in.
     *     bar("hello")
     *   }
     * }
     * ```
     */
    get root() {
        let curr = this;
        while (curr.prev !== undefined) {
            curr = curr.prev;
        }
        return curr;
    }
    /**
     * Get the next unique token.
     */
    nextToken() {
        return this.tokens.next().value;
    }
    /**
     * Find the URI of the Module containing this node.
     *
     * @param node
     */
    getUri(node) {
        const mod = node.getModule();
        if (mod) {
            for (const file of this.project.sourceModules.concat(this.project.externalModules)) {
                if ((file === null || file === void 0 ? void 0 : file.content) === mod) {
                    return file.uri;
                }
            }
        }
        return undefined;
    }
    /**
     * Lookup an expression by its FQN.
     *
     * @param fqn fully qualified name of the expression.
     */
    lookupQualifiedName(fqn) {
        const found = fqn ? this.global.scope.get(fqn) : undefined;
        return Array.isArray(found) ? found[0] : found;
    }
    /**
     * List all known types in a namespace.
     * @param namespace
     */
    listNamespace(namespace) {
        return this.global.namespaces.get(namespace);
    }
    /**
     * Qualify a name within a scope.
     *
     * @param scope to qualify the name within
     * @param name name to qualify
     * @returns the qualified name
     */
    qualifyName(scope, query) {
        var _a, _b;
        const name = typeof query === "object" ? query === null || query === void 0 ? void 0 : query.name : query;
        if (name === undefined) {
            return undefined;
        }
        if (isQualifiedNamePattern(name)) {
            return name;
        }
        const found = this.lookupName(scope, name);
        if ((found === null || found === void 0 ? void 0 : found.kind) === "NameDeclaration") {
            return (_a = found.name) === null || _a === void 0 ? void 0 : _a.name;
        }
        if ((found === null || found === void 0 ? void 0 : found.kind) === "TypeParameter") {
            return name;
        }
        if ((found === null || found === void 0 ? void 0 : found.kind) === "TypeDeclaration" ||
            (found === null || found === void 0 ? void 0 : found.kind) === "ActionDeclaration" ||
            (found === null || found === void 0 ? void 0 : found.kind) === "DialogDeclaration" ||
            (found === null || found === void 0 ? void 0 : found.kind) === "EnumDeclaration") {
            return (_b = found.name) === null || _b === void 0 ? void 0 : _b.name;
        }
        if ((found === null || found === void 0 ? void 0 : found.kind) === "SlotType") {
            return found.name.name;
        }
        if ((found === null || found === void 0 ? void 0 : found.kind) === "ResponseTemplate") {
            if (found.isPrompt()) {
                return `${ask.PromptsNamespace}.${found.name}`;
            }
            if (found.isDisplay()) {
                return `${ask.DisplayNamespace}.${found.name}`;
            }
        }
        return name;
    }
    /**
     * Find where a name is declared in the stack.
     *
     * @param scope scope to trace back from
     * @param name name to find
     */
    lookupName(scope, name) {
        if (name === undefined) {
            return undefined;
        }
        const nameStr = typeof name === "string" ? name : name.name;
        if (this.global.scope.has(nameStr)) {
            const found = this.global.scope.get(nameStr);
            return Array.isArray(found) ? found[0] : found;
        }
        const lexicalScope = this.getVisibleNames(scope);
        if (lexicalScope) {
            const found = lexicalScope.get(nameStr);
            return Array.isArray(found) ? found[0] : found;
        }
        return undefined;
    }
    lookupNameReference(ref) {
        return this.lookupName(ref, ref.name);
    }
    /**
     * Recursively resolve the name reference when it's NameDeclaration
     * Stop when it's no longer a NameReference expression, or it's no longer a NameDeclaration
     *
     * @param ref nameReference to resolve
     * @returns the last resolved node
     */
    resolveNameReference(ref) {
        const decl = this.resolveNameReferenceToDecl(ref);
        if (ask.isNameDeclaration(decl)) {
            return decl.expression;
        }
        return decl;
    }
    /**
     * Recursively resolve the name reference to find the NameDeclaration
     * Stop when it's no longer a NameReference expression
     *
     * @param ref nameReference to resolve
     * @returns the last resolved NameDecl node
     */
    resolveNameReferenceToDecl(ref, seen = new Set()) {
        const found = ask.isPropRef(ref)
            ? this.lookupQualifiedName(ask.PropertyReference.tryResolveQualifiedName(ref))
            : this.lookupNameReference(ref);
        if (found === undefined) {
            return undefined;
        }
        if (seen.has(found)) {
            // circular reference
            return undefined;
        }
        seen.add(found);
        if (ask.isNameDeclaration(found)) {
            return this.isNameReference(found.expression)
                ? this.resolveNameReferenceToDecl(found.expression, seen)
                : found;
        }
        return found;
    }
    /**
     * Recursively resolve the name reference until find a call
     * If the name is not initialized by a call, return undefined
     *
     * @param ref nameReference to resolve
     */
    resolveNameReferenceToCall(ref) {
        const found = this.resolveNameReference(ref);
        return ask.isCall(found) ? found : undefined;
    }
    /**
     * Recursively resolve the name reference until find a propertyReference
     * If the name is not initialized by a call, return undefined
     *
     * @param ref nameReference to resolve
     */
    resolveNameReferenceToPropReference(ref) {
        const found = this.resolveNameReference(ref);
        return ask.isPropRef(found) ? found : undefined;
    }
    /**
     * Computes and caches the visible names at a Node.
     *
     * @param node the node in which we are looking for visible names
     * @param allowDescend a flag to set whether the code should descend into a Correction's `expected` block and include names in that block within this ${node}'s lexical scope.
     */
    getVisibleNames(node, allowDescend = true) {
        var _a, _b;
        if (node === undefined) {
            return immutable.Map();
        }
        // we skip caching the Correction block since its lexical scope varies on how it is approached (unfortunately)
        // 1. when the Correction Node is within a Block node, we consider the names in `expected` as a part of the lexical scope
        // 2. when we are in the Correction's `expected` or `actual` blocks, we do not consider the `expected` block as part of the lexical scope
        // we need this special behavior the Correction's expected block has abnormal lexical scope laws
        const useCache = node.kind !== "Correction";
        if (useCache && this.lexicalScopeIndex.has(node)) {
            return this.lexicalScopeIndex.get(node);
        }
        const inheritedNames = this.getVisibleNames((_a = node.previous) !== null && _a !== void 0 ? _a : node.context, ((_b = node.previous) === null || _b === void 0 ? void 0 : _b.kind) === "Correction");
        const producedNames = this.getProducedNames(node, allowDescend);
        const lexicalScope = inheritedNames !== undefined && producedNames !== undefined
            ? // TODO: check for conflicts or allow shadowing?
                inheritedNames.merge(producedNames)
            : inheritedNames === undefined
                ? producedNames
                : inheritedNames;
        if (useCache) {
            this.lexicalScopeIndex.set(node, lexicalScope);
        }
        return lexicalScope;
    }
    /**
     * Collect the names produced by a Node.
     */
    getProducedNames(node, allowDescend) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (node.kind === "Module") {
            const imports = (_b = (_a = node.imports) === null || _a === void 0 ? void 0 : _a.map((imprt) => {
                var _a;
                if (imprt.name) {
                    if (imprt.kind === "ImportName") {
                        const namespace = getNamespace(imprt.name);
                        const name = getName(imprt.name);
                        const expr = (_a = this.global.namespaces.get(namespace)) === null || _a === void 0 ? void 0 : _a.get(name);
                        if (expr) {
                            return immutable.Map({
                                [name]: expr,
                            });
                        }
                    }
                    else {
                        return this.global.namespaces.get(imprt.name);
                    }
                }
                return undefined;
            }).filter((scope) => scope !== undefined)) !== null && _b !== void 0 ? _b : [];
            // regard content in same namespace as import
            const thisNamespace = ((_c = node.namespace) === null || _c === void 0 ? void 0 : _c.name) ? this.global.namespaces.get(node.namespace.name) : undefined;
            const declared = (_e = (_d = node.expressions) === null || _d === void 0 ? void 0 : _d.map((expr) => {
                var _a;
                if (expr.kind !== "InteractionDeclaration" &&
                    ((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name) &&
                    (expr.kind === "ActionDeclaration" ||
                        expr.kind === "DialogDeclaration" ||
                        expr.kind === "EnumDeclaration" ||
                        expr.kind === "NameDeclaration" ||
                        expr.kind === "TypeDeclaration")) {
                    if (node.namespace !== undefined) {
                        // we're in an ACDL module so import the short name into lexical scope
                        return immutable.Map({
                            [expr.name.name]: expr,
                            [getName(expr.name.name)]: expr,
                        });
                    }
                    return immutable.Map({
                        [expr.name.name]: expr,
                    });
                }
                return undefined;
            }).filter((scope) => scope !== undefined)) !== null && _e !== void 0 ? _e : [];
            return [...imports, thisNamespace, ...declared].reduce(mergeLexicalScope, emptyLexicalScope()).map((value) => {
                if (Array.isArray(value)) {
                    const set = new Set(value);
                    if (set.size === 1) {
                        return value[0];
                    }
                    return Array.from(set);
                }
                return value;
            });
        }
        if ((node.kind === "NameDeclaration" || node.kind === "EnumDeclaration") && ((_f = node.name) === null || _f === void 0 ? void 0 : _f.name) !== undefined) {
            return immutable.Map({
                [node.name.name]: node,
            });
        }
        if ((node === null || node === void 0 ? void 0 : node.kind) === "ActionDeclaration" || (node === null || node === void 0 ? void 0 : node.kind) === "DialogDeclaration" || (node === null || node === void 0 ? void 0 : node.kind) === "TypeDeclaration") {
            const genericArguments = computeLexicalScope(node.genericArguments);
            if (node.kind === "DialogDeclaration") {
                const argumentsScope = computeLexicalScope(node.arguments);
                return genericArguments.merge(argumentsScope);
            }
            return genericArguments;
        }
        if (node.kind === "Correction" && allowDescend) {
            if ((_h = (_g = node.expected) === null || _g === void 0 ? void 0 : _g.expressions) === null || _h === void 0 ? void 0 : _h.length) {
                return this.getVisibleNames(node.expected.expressions[node.expected.expressions.length - 1]);
            }
        }
        else if (node.kind === "Argument") {
            // special lexical scoping logic for validateArg, see https://github.com/alexa/ask-ac/issues/690
            const annotationName = this.lookupName(node.context, node.context.name);
            if ((annotationName === null || annotationName === void 0 ? void 0 : annotationName.kind) === "ActionDeclaration" && ((_j = annotationName.name) === null || _j === void 0 ? void 0 : _j.name) === AlexaConversations.validateArg) {
                if (((_k = node.name) === null || _k === void 0 ? void 0 : _k.name) === "condition" || (node.name === undefined && node.index === 0)) {
                    // we only want the argument names to be visible for the `condition` argument.
                    if (node.context.context.kind === "Annotation" && node.context.context.context.kind === "ActionDeclaration") {
                        return computeLexicalScope(node.context.context.context.arguments);
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Find the Expression located at a specific position in the file.
     *
     * @param uri module uri to search
     * @param position line and column number
     */
    findName(uri, position) {
        const module = this.project.getModule(uri);
        if (module === null || module === void 0 ? void 0 : module.content) {
            if (module.content.kind === "Module") {
                return (find(module.content.expressions, position) || find(module.content.imports, position) || find(module.content.namespace, position));
            }
            return find(module.content.expressions, position);
        }
        return undefined;
        function find(node, position) {
            if (node === undefined || node === null) {
                return undefined;
            }
            if (Array.isArray(node)) {
                for (const i of node) {
                    const found = find(i, position);
                    if (found !== undefined) {
                        return found;
                    }
                }
            }
            else if (typeof node === "object") {
                if ((node === null || node === void 0 ? void 0 : node.loc) !== undefined) {
                    if (ask.locationContains(node.loc, position, true)) {
                        if (node.kind === "Name") {
                            return node;
                        }
                    }
                }
                for (const [name, value] of Object.entries(node)) {
                    if (name === "context" || name === "previous") {
                        continue;
                    }
                    const found = find(value, position);
                    if (found !== undefined) {
                        return found;
                    }
                }
            }
            return undefined;
        }
    }
    /**
     * Finds the type referenced by a TypeReference.
     *
     * @param type type reference to lookup
     */
    lookupTypeReference(type) {
        var _a;
        const target = this.lookupName(type, (_a = type.name) === null || _a === void 0 ? void 0 : _a.name);
        if ((target === null || target === void 0 ? void 0 : target.kind) === "ActionDeclaration" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "DialogDeclaration" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "EnumDeclaration" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "TypeDeclaration" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "TypeParameter" ||
            (target === null || target === void 0 ? void 0 : target.kind) === "SlotType") {
            return target;
        }
        return undefined;
    }
    /**
     * Get the declaration of a call's target.
     *
     * @param call the call expression to find the target of
     * @returns the named Action or Dialog declaration if exists, undefined otherwise.
     */
    lookupCallDeclaration(call) {
        var _a;
        const target = this.lookupName(call, (_a = call.name) === null || _a === void 0 ? void 0 : _a.name);
        if (target !== undefined &&
            (target.kind === "ActionDeclaration" ||
                target.kind === "ArgumentDeclaration" ||
                target.kind === "DialogDeclaration" ||
                target.kind === "NameDeclaration" ||
                target.kind === "SlotType" ||
                target.kind === "TypeDeclaration")) {
            return target;
        }
        return undefined;
    }
    /**
     * Get the declaration of a call's target.
     *
     * @param call the call expression to find the target of
     * @returns the named Action or Dialog declaration if exists, undefined otherwise.
     */
    lookupTypeDeclaration(fqn) {
        const names = this.global.scope.get(fqn);
        const expr = Array.isArray(names) ? names[0] : names;
        if ((expr === null || expr === void 0 ? void 0 : expr.kind) === "TypeDeclaration") {
            return expr;
        }
        return undefined;
    }
    /**
     * Get auto-completion suggestions for the Node.
     */
    getCompletions(node) {
        var _a, _b, _c, _d, _e, _f;
        // TODO: type safe interface
        if (node.kind === "Name") {
            const { context } = node;
            if (context.kind === "Utterance") {
                const type = (_a = this.getType(context.context)) === null || _a === void 0 ? void 0 : _a.getUtteranceType();
                if (type !== undefined) {
                    const alreadyProvided = new Set((_b = context.names) === null || _b === void 0 ? void 0 : _b.map((n) => n.name).filter((n) => n !== undefined && n !== node.name));
                    return (_c = type.properties) === null || _c === void 0 ? void 0 : _c.map((prop) => prop.name).filter((n) => n !== undefined && !alreadyProvided.has(n)).map((label) => ({
                        label,
                    }));
                }
            }
            else if (context.kind === "Block") {
                return Object.keys(this.getVisibleNames(node) || {}).map((label) => ({ label }));
            }
            else {
                return this.getCompletions(node.context);
            }
        }
        else if (this.isNameReference(node)) {
            return Object.keys(this.getVisibleNames(node) || {})
                .filter((label) => !label.includes("."))
                .map((label) => ({
                label,
            }));
        }
        else if (node.kind === "PropertyReference") {
            const exprType = this === null || this === void 0 ? void 0 : this.getType(node.expression);
            if (exprType) {
                return (_d = exprType.properties) === null || _d === void 0 ? void 0 : _d.map((property) => ({
                    label: property.name,
                }));
            }
        }
        else if (node.kind === "Argument") {
            return (_f = (_e = this.getApply(node.context)) === null || _e === void 0 ? void 0 : _e.argumentDeclarations) === null || _f === void 0 ? void 0 : _f.map((arg) => {
                var _a;
                return ({
                    label: typeof arg.name === "string" ? arg.name : (_a = arg.name) === null || _a === void 0 ? void 0 : _a.name,
                });
            });
        }
        return undefined;
    }
    /**
     * Compute a detailed description of the expression.
     *
     * @param node expression to describe.
     */
    getDescription(node) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        if (node !== undefined) {
            if (node.kind === "Name") {
                const { context } = node;
                if (context.kind === "Utterance") {
                    const type = (_a = this.getType(context.context)) === null || _a === void 0 ? void 0 : _a.getUtteranceType();
                    if (type && node.name) {
                        return `(property) ${type.toString(node)} ${node.name}`;
                    }
                }
                return this.getDescription(context);
            }
            if (node.kind === "NameReference") {
                const type = this.getType(node);
                if (type && ((_b = node.name) === null || _b === void 0 ? void 0 : _b.name)) {
                    return `(name) ${type.toString(node)} ${node.name.name}`;
                }
            }
            else if (node.kind === "NameDeclaration") {
                if (((_c = node.name) === null || _c === void 0 ? void 0 : _c.name) && node.expression) {
                    const type = this.getType(node);
                    if (type) {
                        return `(name) ${type.toString(node)} ${node.name.name}`;
                    }
                }
            }
            else if (node.kind === "PropertyReference") {
                if (this.isNameReference(node)) {
                    const type = this.getType(node);
                    if (type && ((_d = node.name) === null || _d === void 0 ? void 0 : _d.name)) {
                        return `(name) ${type.toString(node)} ${node.name.name}`;
                    }
                }
                const propertyName = (_e = node.name) === null || _e === void 0 ? void 0 : _e.name;
                const returnType = this.getType(node);
                if (returnType && propertyName) {
                    return `(property) ${returnType.toString(node)} ${propertyName}`;
                }
            }
            else if (node.kind === "TypeReference") {
                const type = this.getType(node);
                if (((_f = node.name) === null || _f === void 0 ? void 0 : _f.name) && type) {
                    const label = ((_g = type === null || type === void 0 ? void 0 : type.declaration) === null || _g === void 0 ? void 0 : _g.kind) === "TypeParameter" ? "type parameter" : "type";
                    return `(${label}) ${type.toString(node)}`;
                }
            }
            else if (node.kind === "Type") {
                return node.toString(node.declaration);
            }
            else if (node.kind === "TypeParameter") {
                if ((_h = node.name) === null || _h === void 0 ? void 0 : _h.name) {
                    return `(type parameter) ${node.name.name}`;
                }
            }
            else if (node.kind === "TypeProperty") {
                const type = this.getType(node.type);
                if (type && ((_j = node.name) === null || _j === void 0 ? void 0 : _j.name)) {
                    return `(property) ${type.toString(node)} ${node.name.name}`;
                }
            }
            else if (node.kind === "TypeDeclaration") {
                return `(type declaration) ${(_k = node.name) === null || _k === void 0 ? void 0 : _k.name}${node.genericArguments ? `<${node.genericArguments.map((arg) => stringifyTypeParameter(arg))}>` : ""}`;
            }
            else if (node.kind === "EnumDeclaration") {
                return `(enum declaration) ${(_l = node.name) === null || _l === void 0 ? void 0 : _l.name}`;
            }
            else if (node.kind === "EnumItemDeclaration") {
                return `(enum item) ${(_m = node.name) === null || _m === void 0 ? void 0 : _m.name}`;
            }
            else if (node.kind === "DialogDeclaration" || node.kind === "ActionDeclaration") {
                const type = node.kind === "ActionDeclaration" ? "action" : "dialog";
                const returnType = this.getType(node.returnType);
                const argumentDeclarations = node.arguments && node.arguments.length > 0
                    ? `(\n  ${node.arguments.map((a) => { var _a, _b; return `${(_a = this.getType(a)) === null || _a === void 0 ? void 0 : _a.toString(node)} ${(_b = a.name) === null || _b === void 0 ? void 0 : _b.name}`; }).join(",\n  ")}\n)`
                    : "()";
                if (returnType && ((_o = node.name) === null || _o === void 0 ? void 0 : _o.name)) {
                    return `${type} ${returnType.toString(node)} ${node.name.name}${argumentDeclarations}`;
                }
            }
            else if (node.kind === "ArgumentDeclaration") {
                const type = this.getType(node.type);
                if (type && ((_p = node.name) === null || _p === void 0 ? void 0 : _p.name)) {
                    return `(argument) ${type.toString(node)} ${(_q = node.name) === null || _q === void 0 ? void 0 : _q.name}`;
                }
            }
            else if (node.kind === "Argument") {
                const type = this.getType(node.value);
                if (type && ((_r = node.name) === null || _r === void 0 ? void 0 : _r.name)) {
                    return `(argument) ${type.toString(node)} ${(_s = node.name) === null || _s === void 0 ? void 0 : _s.name}`;
                }
            }
            else if (node.kind === "Call") {
                return this.getDescription((_t = this.getApply(node)) === null || _t === void 0 ? void 0 : _t.decl);
            }
        }
        return undefined;
    }
    /**
     * Gets a `Thing` instance representing the value of some Node.
     *
     * @param node AST node to get a Thing to represent.
     * @param backtrack backtrack to control type interface
     * @param seen nodes seen so far in this traversal to detect infinite loops
     */
    getThing(node, token, origin = node, seen = immutable.Set()) {
        var _a, _b, _c;
        if (node === undefined) {
            return undefined;
        }
        if (seen.has(node)) {
            // circular reference
            return undefined;
        }
        const checker = this;
        seen = seen.add(node);
        if (this.globalThingIndex.has(node)) {
            return (_a = this.globalThingIndex.get(node)) !== null && _a !== void 0 ? _a : undefined;
        }
        if (!this.localThingIndex.has(node)) {
            this.localThingIndex.set(node, (_b = getThing(node, seen)) !== null && _b !== void 0 ? _b : null);
        }
        return (_c = this.localThingIndex.get(node)) !== null && _c !== void 0 ? _c : undefined;
        function getThing(node, seen) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
            if (node.kind === "NameReference" ||
                node.kind === "PropertyReference" ||
                (node.kind === "Call" && ((_a = checker.getApply(node, undefined, seen)) === null || _a === void 0 ? void 0 : _a.isGetListItem()))) {
                let rootThing = undefined;
                if (node.kind === "PropertyReference") {
                    const nameRef = checker.lookupName(node, ask.PropertyReference.tryResolveQualifiedName(node));
                    if (nameRef) {
                        rootThing = checker.getThing(nameRef, token, node, seen);
                    }
                    else {
                        rootThing = (_b = checker.getThing(node.expression, undefined, undefined, seen)) === null || _b === void 0 ? void 0 : _b.getProperty(node.name);
                    }
                }
                else if (node.kind === "Call") {
                    const apply = checker.getApply(node);
                    const index = (_c = checker.getThing(apply.getArgumentValue("index"))) === null || _c === void 0 ? void 0 : _c.asNumber();
                    let listThing = checker.getThing(apply.getArgumentValue("list"), undefined, undefined, seen);
                    // If listThing is Optional<List> then we need to unwrap the List from the generic
                    // argument and transform it from an AnyThing to a ListThing.
                    if (!(listThing === null || listThing === void 0 ? void 0 : listThing.isList()) && (listThing === null || listThing === void 0 ? void 0 : listThing.type.isOptional())) {
                        const genericType = (_e = (_d = listThing === null || listThing === void 0 ? void 0 : listThing.type) === null || _d === void 0 ? void 0 : _d.genericArguments) === null || _e === void 0 ? void 0 : _e[0];
                        if (genericType && genericType.isList()) {
                            listThing = genericType.getThing(checker.nextToken(), origin, listThing, apply);
                        }
                    }
                    if (index) {
                        rootThing = (_f = listThing === null || listThing === void 0 ? void 0 : listThing.asList()) === null || _f === void 0 ? void 0 : _f.getItem(index, node);
                    }
                }
                else {
                    rootThing = checker.getThing(checker.lookupNameReference(node), token, undefined, seen);
                }
                if (rootThing === undefined) {
                    return undefined;
                }
                return search(node.context);
                function search(context) {
                    if (context === undefined) {
                        return rootThing;
                    }
                    if (context.kind === "Block") {
                        if (context instanceof ThenScope) {
                            if (context.context.when) {
                                return descend(context.context.when.expression, search(context.context));
                            }
                            return search(context.context);
                        }
                        if (context.context.kind === "Sample") {
                            const sample = context.context;
                            if (sample.annotations) {
                                for (const annotation of sample.annotations) {
                                    const annotationApply = checker.getApply(annotation.call);
                                    if (annotationApply === null || annotationApply === void 0 ? void 0 : annotationApply.isWhen()) {
                                        const condition = annotationApply.getArgumentValue("condition");
                                        if (condition) {
                                            return descend(condition, search(context.context));
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    else if (context.kind === "Argument") {
                        const apply = checker.getApply(context.context);
                        if (apply === null || apply === void 0 ? void 0 : apply.isAnd()) {
                            const left = apply.getArgument("left");
                            const right = apply.getArgument("right");
                            if (left === context) {
                                return search(context.context);
                            }
                            if (right === context) {
                                return descend(left, search(context.context));
                            }
                        }
                    }
                    return search(context.context);
                }
                function descend(when, thing) {
                    var _a;
                    if (when === undefined) {
                        return thing;
                    }
                    if (when.kind === "Argument") {
                        return descend(when.value, thing);
                    }
                    if (when.kind === "Call") {
                        const apply = checker.getApply(when, true, seen);
                        if (apply) {
                            if (apply.isIs()) {
                                const isThing = apply.getArgumentValueThing("thing");
                                const type = (_a = apply.getGenericArguments()) === null || _a === void 0 ? void 0 : _a[0];
                                if (type && (isThing === null || isThing === void 0 ? void 0 : isThing.equals(thing))) {
                                    return thing.cast(thing.type.narrow(type));
                                }
                            }
                            else if (apply.isAnd()) {
                                const left = descend(apply.getArgumentValue("left"), thing);
                                const right = descend(apply.getArgumentValue("right"), left);
                                if (left === undefined && right === undefined) {
                                    return search(when.context);
                                }
                                if (left === undefined || right === undefined) {
                                    return left || right;
                                }
                                const intersection = left.type.narrow(right.type);
                                if (intersection) {
                                    return search(when.context).cast(intersection);
                                }
                            }
                            else if (apply.isOr()) {
                                const left = descend(apply.getArgumentValue("left"), thing);
                                const right = descend(apply.getArgumentValue("right"), thing);
                                const union = left.type.union(right.type);
                                if (union) {
                                    return thing.cast(union);
                                }
                            }
                            else if (apply.isEq() || apply.isNeq()) {
                                const left = apply.getArgumentValueThing("left");
                                const right = apply.getArgumentValueThing("right");
                                if ((left === null || left === void 0 ? void 0 : left.equals(thing)) || (right === null || right === void 0 ? void 0 : right.equals(thing))) {
                                    const operand = (left === null || left === void 0 ? void 0 : left.equals(thing)) ? right : left;
                                    if ((operand === null || operand === void 0 ? void 0 : operand.type.isVoid()) || (operand === null || operand === void 0 ? void 0 : operand.type.isNothing())) {
                                        if (apply.isEq()) {
                                            return new VoidThing(checker, thing.token, checker.void, thing.apply, thing.origin, thing.parent);
                                        }
                                        let { type } = thing;
                                        while (type === null || type === void 0 ? void 0 : type.isOptional()) {
                                            type = type.getOptionalType();
                                        }
                                        return type ? thing.cast(type) : thing;
                                    }
                                    return thing;
                                }
                            }
                        }
                    }
                    return thing;
                }
            }
            if (node.kind === "NameDeclaration") {
                const expr = checker.getThing(node.expression, token !== null && token !== void 0 ? token : checker.nextToken(), (_g = node.expression) !== null && _g !== void 0 ? _g : node, seen);
                if (node.type && (expr === null || expr === void 0 ? void 0 : expr.type.isNothing())) {
                    return (_h = checker.getType(node.type)) === null || _h === void 0 ? void 0 : _h.getThing(token !== null && token !== void 0 ? token : checker.nextToken(), (_j = node.expression) !== null && _j !== void 0 ? _j : node);
                }
                return expr;
            }
            if (node.kind === "Call") {
                const apply = checker.getApply(node, true, seen);
                if (apply !== undefined) {
                    if (apply.isType()) {
                        const returnType = apply.getReturnType(seen);
                        if (returnType === null || returnType === void 0 ? void 0 : returnType.isNothing()) {
                            return new NothingThing(checker, checker.nothingToken, checker.nothing, apply, origin !== null && origin !== void 0 ? origin : node, undefined);
                        }
                        if (returnType === null || returnType === void 0 ? void 0 : returnType.isVoid()) {
                            return new VoidThing(checker, checker.voidToken, checker.void, apply, origin !== null && origin !== void 0 ? origin : node, undefined);
                        }
                        return returnType === null || returnType === void 0 ? void 0 : returnType.getThing(token !== null && token !== void 0 ? token : checker.nextToken(), origin !== null && origin !== void 0 ? origin : node, undefined, apply);
                    }
                    if (apply.isAction()) {
                        return (_k = apply.getReturnType(seen)) === null || _k === void 0 ? void 0 : _k.getThing(token !== null && token !== void 0 ? token : checker.nextToken(), origin !== null && origin !== void 0 ? origin : node, undefined, apply);
                    }
                    if (apply.isDialog()) {
                        return (_l = apply.getReturnType(seen)) === null || _l === void 0 ? void 0 : _l.getThing(token !== null && token !== void 0 ? token : checker.nextToken(), origin !== null && origin !== void 0 ? origin : node);
                    }
                }
                return undefined;
            }
            if (node.kind === "Annotation") {
                return checker.getThing(node.call, token, undefined, seen);
            }
            if (node.kind === "Argument") {
                return checker.getThing(node.value, token, undefined, seen);
            }
            if (node.kind === "ListItem") {
                return checker.getThing(node.item, token, undefined, seen);
            }
            if (node.kind === "ListLiteral") {
                return checker.getThing(node.context, token, undefined, seen);
            }
            if (node.kind === "ResponseTemplate") {
                // TODO
            }
            else if (node.kind === "Sample") {
                return checker.getThing(node.scope, token !== null && token !== void 0 ? token : checker.nextToken(), node, seen);
            }
            else if (node.kind === "ActionDeclaration") {
                return new ActionThing(checker, checker.nextToken(), checker.getType(node), node);
            }
            else if (node.kind === "DialogDeclaration") {
                return new DialogThing(checker, checker.nextToken(), checker.getType(node), node);
            }
            else if (node.kind === "Condition") {
                const then = ((_o = (_m = node.then) === null || _m === void 0 ? void 0 : _m.expressions) === null || _o === void 0 ? void 0 : _o.length)
                    ? checker.getThing(node.then.expressions[node.then.expressions.length - 1], undefined, undefined, seen)
                    : checker.void.getThing(checker.nextToken(), node);
                const _else = ((_q = (_p = node.else) === null || _p === void 0 ? void 0 : _p.expressions) === null || _q === void 0 ? void 0 : _q.length)
                    ? checker.getThing(node.else.expressions[node.else.expressions.length - 1], undefined, undefined, seen)
                    : checker.void.getThing(checker.nextToken(), node);
                if (then && _else) {
                    return new UnionThing(checker, checker.nextToken(), checker.getType(node), node, [then, _else]);
                }
                if (then) {
                    return new UnionThing(checker, checker.nextToken(), checker.getType(node), node, [then]);
                }
                return undefined;
            }
            else if (node.kind === "Block" && node.expressions && node.expressions.length > 0) {
                return checker.getThing(node.expressions[node.expressions.length - 1]);
            }
            else if (node.kind === "When") {
                return checker.getThing(node.expression, token, origin, seen);
            }
            // recursion
            return ((_r = checker.getType(node)) !== null && _r !== void 0 ? _r : checker.thing).getThing(token !== null && token !== void 0 ? token : checker.nextToken(), origin !== null && origin !== void 0 ? origin : node);
        }
    }
    /**
     * Gets the type of a Node.
     *
     * @param node to determine the type of
     * @param backtrack backtrack to control the behavior of the get type search
     * @param seen a set of seen nodes for detecting circular references
     * @returns instantiate type of the node or undefined if it cannot be determined
     */
    getType(node, backtrack = true, seen = immutable.Set()) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (node === undefined || seen.has(node)) {
            return undefined;
        }
        if (node.kind === "Call") {
            const apply = this.getApply(node, backtrack);
            if (apply === null || apply === void 0 ? void 0 : apply.isGetListItem()) {
                return (_a = this.getThing(node, undefined, undefined, seen)) === null || _a === void 0 ? void 0 : _a.type;
            }
            return apply === null || apply === void 0 ? void 0 : apply.getReturnType(seen.add(node));
        }
        if (node.kind === "Annotation") {
            return this.getType(node.call, backtrack, seen);
        }
        if (node.kind === "Utterance") {
            return this.getType(node.context, backtrack);
        }
        if (node.kind === "NameDeclaration") {
            if (node.type) {
                return this.instantiateTypeReference(node.type);
            }
            // infer the type from the expression
            return (_b = this.getThing(node.expression, undefined, node, seen.add(node))) === null || _b === void 0 ? void 0 : _b.type;
        }
        if (node.kind === "NameReference") {
            return (_c = this.getThing(node, undefined, node, seen)) === null || _c === void 0 ? void 0 : _c.type;
        }
        if (node.kind === "PropertyReference") {
            return (_d = this.getThing(node, undefined, node, seen)) === null || _d === void 0 ? void 0 : _d.type;
        }
        if (node.kind === "ListLiteral") {
            // empty list defaults to List<Thing>, otherwise List<T> where T is the intersection of all Types in the List.
            // TODO: should it default to List<Nothing> so that it is a List compatible with all lists? Probably...
            const itemType = node.items.length === 0
                ? this.thing
                : node.items
                    .map((item) => this.getType(item.item, false, seen))
                    // reduce the list of types to a single type which is their shared sub type
                    // if two types have an `undefined` intersection, assume as `Thing`
                    // initial value of reduction is nothing (0, "zero") - nothing intersects with all types, so the first value in the list always takes precedence
                    .reduce((a, b) => { var _a; return (_a = a === null || a === void 0 ? void 0 : a.union(b)) !== null && _a !== void 0 ? _a : this.thing; }, this.nothing);
            if (itemType === undefined) {
                return undefined;
            }
            if (node.context.kind === "Call" && ((_e = node.context.name) === null || _e === void 0 ? void 0 : _e.name) === AlexaConversations.Args) {
                return this.instantiateAlexaSchemaType(AlexaConversations.Args, itemType);
            }
            return this.instantiateAlexaSchemaType(AlexaSchema.List, itemType);
        }
        if (node.kind === "ArgumentDeclaration") {
            return this.instantiateTypeReference(node.type);
        }
        if (node.kind === "TypeReference") {
            return this.instantiateTypeReference(node);
        }
        if (node.kind === "Condition") {
            const then = (_f = this.getType(node.then, backtrack, seen)) !== null && _f !== void 0 ? _f : this.nothing; // then as `undefined` is impossible
            const _else = node.else ? (_g = this.getType(node.else, backtrack, seen)) !== null && _g !== void 0 ? _g : this.nothing : this.void;
            return then === null || then === void 0 ? void 0 : then.union(_else);
        }
        if (node.kind === "Correction") {
            return this.void;
        }
        if (node.kind === "When") {
            return this.getType(node.expression);
        }
        if (node.kind === "Block") {
            if (node.expressions && node.expressions.length > 0) {
                return this.getType(node.expressions[node.expressions.length - 1], backtrack, seen);
            }
            return this.void;
        }
        if (node.kind === "ActionDeclaration" || node.kind === "DialogDeclaration") {
            return new Type(this, node, undefined);
        }
        if (node.kind === "TypeDeclaration") {
            // Type<T>
            const typeType = this.lookupTypeDeclaration(AlexaSchema.Type);
            const type = this.instantiateTypeDeclaration(node, undefined);
            if (type) {
                return new Type(this, typeType, [type]);
            }
        }
        else if (node.kind === "TypeParameter") {
            return this.instantiateTypeParameter(node);
        }
        else if (node.kind === "ResponseTemplate") {
            if (node.type === ask.ResponseTemplateType.Display) {
                return this.instantiateTypeDeclaration(this.lookupTypeDeclaration(AlexaConversations.APL), [this.thing]);
            }
            if (node.type === ask.ResponseTemplateType.Prompt) {
                return this.instantiateTypeDeclaration(this.lookupTypeDeclaration(AlexaConversations.APLA), [this.thing]);
            }
        }
        else if (node.kind === "SlotType") {
            return this.instantiateTypeDeclaration(node);
        }
        else if (node.kind === "Sample") {
            return this.getType(node.scope, backtrack, seen);
        }
        else if (node.kind === "ListItem") {
            return this.getType(node.item, backtrack, seen);
        }
        else if (node.kind === "Argument") {
            return this.getType(node.value, backtrack, seen);
        }
        else if (node.kind === "TypeProperty") {
            let propertyType = (_h = this.getType(node.type, backtrack, seen)) !== null && _h !== void 0 ? _h : this.nothing;
            if (node.optional === true && !propertyType.isOptional()) {
                propertyType = new Type(this, this.lookupTypeDeclaration(AlexaSchema.Optional), [propertyType]);
            }
            return new Type(this, this.lookupTypeDeclaration(AlexaSchema.Property), [propertyType]);
        }
        else if (node.kind === "EnumDeclaration") {
            const typeType = this.lookupTypeDeclaration(AlexaSchema.Type);
            const type = this.instantiateTypeDeclaration(node);
            if (type) {
                /**
                 * e.g.
                 * ```
                 * enum A {
                 *   a
                 * }
                 *
                 * A // type: `Type<A>`
                 * A.a // type: `A`
                 * ``
                 */
                return new Type(this, typeType, [type]);
            }
        }
        else if (node.kind === "EnumItemDeclaration") {
            return (_j = this.getType(node.context, backtrack, seen)) === null || _j === void 0 ? void 0 : _j.getTypeType();
        }
        return undefined;
    }
    /**
     * Get the type of a Call implied by its context.
     *
     * @param call
     */
    getImpliedType(call) {
        var _a, _b, _c;
        const callContext = call.context;
        if ((callContext.kind === "NameDeclaration" || callContext.kind === "ArgumentDeclaration") && callContext.type) {
            return this.instantiateTypeReference(callContext.type);
        }
        if (callContext.kind === "ListItem") {
            return (_b = (_a = this.getApply(callContext.context.context, true)) === null || _a === void 0 ? void 0 : _a.getReturnType()) === null || _b === void 0 ? void 0 : _b.getListItemType();
        }
        if (callContext.kind === "Argument") {
            return (_c = this.getApply(callContext.context, true)) === null || _c === void 0 ? void 0 : _c.getType(callContext);
        }
        return undefined;
    }
    /**
     * Get an Apply for this call.
     *
     * @param call to analyze
     * @param backtrack whether to look back up the tree to infer types
     */
    getApply(call, backtrack = true, seenNames = immutable.Set()) {
        var _a, _b;
        const checker = this;
        if (!backtrack) {
            return getApply();
        }
        if (!this.localApplyIndex.has(call)) {
            this.localApplyIndex.set(call, (_a = getApply()) !== null && _a !== void 0 ? _a : null);
        }
        return (_b = this.localApplyIndex.get(call)) !== null && _b !== void 0 ? _b : undefined;
        function getApply() {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            if (checker.prev) {
                return (_a = checker.root.getApply(call, backtrack, seenNames)) === null || _a === void 0 ? void 0 : _a.instantiate(checker);
            }
            if (((_b = call.name) === null || _b === void 0 ? void 0 : _b.name) === undefined) {
                if (backtrack) {
                    let impliedType = checker.getImpliedType(call);
                    while (impliedType === null || impliedType === void 0 ? void 0 : impliedType.isOptional()) {
                        // if the implied type is optional and we have a non-null call, then we know we are instantiating the Some type
                        impliedType = impliedType.getOptionalType();
                    }
                    if (ask.isListLiteral(call.arguments) && (impliedType === null || impliedType === void 0 ? void 0 : impliedType.isThing())) {
                        // if checker is a list literal in an argument that is of type, `Thing`, then infer the the type of the list from the literal items.
                        impliedType = checker.getType(call.arguments);
                    }
                    const implied = impliedType === null || impliedType === void 0 ? void 0 : impliedType.apply(call);
                    if (implied) {
                        return implied;
                    }
                }
                if (ask.isListLiteral(call.arguments)) {
                    return (_c = checker.getType(call.arguments, backtrack, seenNames)) === null || _c === void 0 ? void 0 : _c.apply(call);
                }
                return undefined;
            }
            if (((_d = call.name) === null || _d === void 0 ? void 0 : _d.name) === AlexaSchema.String && (typeof call.arguments === "string" || ask.isUtterance(call.arguments))) {
                // string literal, let's check if this string should be treated as an utterance or some other specialized string
                if (backtrack) {
                    const impliedType = checker.getImpliedType(call);
                    if (impliedType === null || impliedType === void 0 ? void 0 : impliedType.isStringLike()) {
                        return impliedType.apply(call);
                    }
                }
            }
            else if (call.name.name === AlexaSchema.Number && typeof call.arguments === "number") {
                // number literal, let's check if it should be up-casted to a specialized string based on context
                // e.g. Ordinal ord = 1
                // `1` should be interpreted as Ordinal(1), not Number(1)
                if (backtrack) {
                    const impliedType = checker.getImpliedType(call);
                    if (impliedType === null || impliedType === void 0 ? void 0 : impliedType.isNumber()) {
                        return impliedType.apply(call);
                    }
                }
            }
            const decl = checker.lookupCallDeclaration(call);
            if (decl === undefined) {
                return undefined;
            }
            if (decl.kind === "TypeDeclaration") {
                if (decl.genericArguments === undefined) {
                    // concrete type
                    return (_e = checker.instantiateTypeDeclaration(decl, undefined)) === null || _e === void 0 ? void 0 : _e.apply(call);
                }
                if (((_f = call.genericArguments) === null || _f === void 0 ? void 0 : _f.length) === decl.genericArguments.length) {
                    // generic with explicits
                    return (_g = checker
                        .instantiateTypeDeclaration(decl, call.genericArguments.map((a) => checker.instantiateTypeReference(a)))) === null || _g === void 0 ? void 0 : _g.apply(call);
                }
                return new Apply(checker, call, decl);
            }
            if (decl.kind === "SlotType") {
                return (_h = checker.instantiateTypeDeclaration(decl)) === null || _h === void 0 ? void 0 : _h.apply(call);
            }
            if (decl.kind === "ArgumentDeclaration" || decl.kind === "NameDeclaration") {
                // either a concrete reference to an action or an abstract action signature (argument declaration).
                const actionThing = checker.getThing(decl);
                if (!actionThing || !actionThing.type || ((_j = actionThing.origin) === null || _j === void 0 ? void 0 : _j.kind) === "ActionDeclaration") {
                    return undefined;
                }
                // actual type of the argument declaration
                const actualType = actionThing.type.isOptional() ? actionThing.type.getOptionalType() : actionThing.type;
                // abstract type of the argument declaration, e.g. FunctionN<..>
                const abstractType = checker.root.getType(decl);
                if (abstractType && (actualType === null || actualType === void 0 ? void 0 : actualType.isFunction())) {
                    return new Apply(checker, call, actualType);
                }
                return undefined;
            }
            return new Apply(checker, call, decl);
        }
    }
    /**
     * Find an Argument's TypeProperty based on its position or name in a Call to a TypeDeclaration.
     *
     * @param type type declaration called
     * @param argument argument value in the call
     */
    findArgumentTypeProperty(type, argument) {
        var _a;
        if (type.properties === undefined) {
            return undefined;
        }
        if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
            return type.getProperty(argument.name.name);
        }
        if (typeof argument.index === "number") {
            return type.getProperty(argument.index);
        }
        return undefined;
    }
    /**
     * Find an Argument's declaration based on its name or position
     *
     * @param action action or dialog declaration
     * @param argument argument value in the call
     */
    findArgumentDeclaration(action, argument) {
        var _a, _b;
        if (action.arguments === undefined) {
            return undefined;
        }
        if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
            // named argument
            return (_b = action.arguments) === null || _b === void 0 ? void 0 : _b.find((arg) => { var _a, _b; return ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) === ((_b = argument.name) === null || _b === void 0 ? void 0 : _b.name); });
        }
        if (argument.index) {
            return action.arguments[argument.index];
        }
        return undefined;
    }
    instantiateActionDeclaration(decl, call) {
        return new Apply(this, call, decl);
    }
    /**
     * Instantiate a TypeDeclaration given some typeArgs and a type environment.
     *
     * @param type type declaration to instantiate
     * @param typeArgs known type arguments
     * @param env type environment
     */
    instantiateTypeDeclaration(type, typeArgs, functionArgumentNames, functionName) {
        var _a;
        if (typeArgs === undefined) {
            const cached = this.globalTypeIndex.get(type);
            if (cached !== undefined) {
                return cached;
            }
        }
        let newType = new Type(this, type, typeArgs, functionArgumentNames, functionName);
        if (newType.isReturnValue()) {
            // compute the intrinsic type alias `ReturnValue<A>`
            // we substitute this type with the type of the value returned by the action or dialog
            const returnValueType = newType.getReturnValueType();
            if ((returnValueType === null || returnValueType === void 0 ? void 0 : returnValueType.isAction()) || (returnValueType === null || returnValueType === void 0 ? void 0 : returnValueType.isDialog())) {
                const returnType = (_a = returnValueType.getPropertyType("returnType")) === null || _a === void 0 ? void 0 : _a.getTypeType();
                if (returnType) {
                    newType = returnType;
                }
            }
        }
        if (typeArgs === undefined) {
            // cache a forward-reference to the constructed type if there are no type arguments
            this.globalTypeIndex.set(type, newType);
        }
        return newType;
    }
    /**
     * Instantiate a type by substituting all type parameters and propagating the types to all super types.
     *
     * @param type type reference to instantiate
     * @param env optional lookup table of known names
     */
    instantiateTypeReference(type, env) {
        var _a, _b, _c, _d, _e;
        if (type === undefined) {
            return undefined;
        }
        if (env === null || env === void 0 ? void 0 : env[(_a = type.name) === null || _a === void 0 ? void 0 : _a.name]) {
            return env === null || env === void 0 ? void 0 : env[(_b = type.name) === null || _b === void 0 ? void 0 : _b.name];
        }
        const typeDecl = this.lookupTypeReference(type);
        if ((typeDecl === null || typeDecl === void 0 ? void 0 : typeDecl.kind) === "TypeParameter") {
            return this.instantiateTypeParameter(typeDecl);
        }
        if (typeDecl !== undefined) {
            let typeArgs;
            if (typeDecl.kind === "TypeDeclaration" || typeDecl.kind === "ActionDeclaration" || typeDecl.kind === "DialogDeclaration") {
                if (typeDecl.genericArguments) {
                    if (type.arguments === undefined || ((_c = type.arguments) === null || _c === void 0 ? void 0 : _c.length) === 0) {
                        typeArgs = typeDecl.genericArguments.map((arg) => {
                            const type = this.getType(arg);
                            if ((type === null || type === void 0 ? void 0 : type.extensions) === undefined || type.extensions.length === 0) {
                                return this.thing;
                            }
                            if (type.extensions.length === 1) {
                                return type.extensions[0];
                            }
                            // TODO: how should we handle a multiple-inheritance lower bound.
                            return this.thing;
                        });
                    }
                    else {
                        typeArgs = (_d = type.arguments) === null || _d === void 0 ? void 0 : _d.map((arg) => this.instantiateTypeReference(arg, env));
                    }
                    // infer the type arguments
                }
            }
            return this.instantiateTypeDeclaration(typeDecl, typeArgs, type.functionArgumentNames, type.functionArgumentNames !== undefined && type.context.kind === "ArgumentDeclaration" ? (_e = type.context.name) === null || _e === void 0 ? void 0 : _e.name : undefined);
        }
        return undefined;
    }
    /**
     * Instantiate a TypeParameter.
     *
     * @param param type parameter.
     */
    instantiateTypeParameter(param) {
        return new Type(this, param, undefined);
    }
    instantiateAlexaSchemaType(name, ...genericArguments) {
        const decl = this.lookupQualifiedName(name);
        if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "TypeDeclaration") {
            const type = this.instantiateTypeDeclaration(decl, genericArguments.length > 0 ? genericArguments : undefined);
            if (type) {
                return type;
            }
        }
        throw new Error(`could not find alexa schema type: ${name}`);
    }
    /**
     * determine if the a propertyReference is a type used in an event
     *
     * E.G.
     * ```
     * type Person {
     *   String name
     * }
     *
     * u = utterances<Person>(["Hi {name}"])
     * personInfo = expect(Invoke, u)
     * a = personInfo.name
     * ```
     * `a` is a property reference and it's from the event expr, thus should return true
     *
     */
    isPropertyReferenceFromEvent(value) {
        const rootExpr = this.getPropertyChainRootExpression(value);
        if (this.isNameReference(rootExpr)) {
            const rootExprValue = this.resolveNameReferenceToCall(rootExpr);
            if (rootExprValue !== undefined) {
                const rootExprValueApply = this.getApply(rootExprValue);
                // TODO: don't use hard code once know how to determine the type is from event
                if ((rootExprValueApply === null || rootExprValueApply === void 0 ? void 0 : rootExprValueApply.isExpect()) || (rootExprValueApply === null || rootExprValueApply === void 0 ? void 0 : rootExprValueApply.isUserSays())) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * determine if the a propertyReference is refer to api result
     *
     * E.G.
     * ```
     * type Person {
     *   String name
     * }
     *
     * action Person getPerson()
     * person = getPerson()
     *
     *
     * a = person.name
     * ```
     * `a` is a property reference and it's refer to api result, thus should return true
     *
     */
    isPropertyReferenceFromApiInvocation(value) {
        const rootExpr = this.getPropertyChainRootExpression(value);
        if (this.isNameReference(rootExpr)) {
            const rootExprValue = this.resolveNameReferenceToCall(rootExpr);
            if (rootExprValue !== undefined) {
                const rootExprValueApply = this.getApply(rootExprValue);
                if (rootExprValueApply === null || rootExprValueApply === void 0 ? void 0 : rootExprValueApply.isUserDefinedApi()) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Get all Nodes referenced by a source Node.
     *
     * @param source node to start the search from
     * @returns a set of all Nodes referenced by this
     */
    getReferences(source) {
        const checker = this;
        const references = new Set();
        visitEachChild(source, findReferences);
        return references;
        function findReferences(node) {
            var _a;
            const ref = (node === null || node === void 0 ? void 0 : node.kind) === "Type" ? node.declaration : node;
            if (node === undefined || ref === undefined || references.has(ref)) {
                return;
            }
            references.add(ref);
            if (node.kind === "Call") {
                const apply = checker.getApply(node);
                // findReferences(apply?.decl);
                const decl = (apply === null || apply === void 0 ? void 0 : apply.decl.kind) === "Type" ? apply.decl.declaration : apply === null || apply === void 0 ? void 0 : apply.decl;
                if (decl) {
                    findReferences(decl);
                }
                visitEachChild(node, findReferences);
            }
            else if (node.kind === "NameReference") {
                findReferences(checker.lookupNameReference(node));
            }
            else if (node.kind === "Type") {
                (_a = node.getReferences()) === null || _a === void 0 ? void 0 : _a.forEach((ref) => references.add(ref));
            }
            else {
                visitEachChild(node, findReferences);
            }
            return false;
        }
    }
    /**
     * Get all response call used in a module.
     *
     * @param module module where to retrieve the responses
     * @returns a set of all responses
     */
    getResponseInfosInModule(module) {
        if (module === undefined) {
            return [];
        }
        const checker = this;
        return collectArray(module, findResponses);
        function findResponses(node) {
            if (node === undefined) {
                return [];
            }
            if (node.kind === "Call") {
                const apply = checker.getApply(node);
                if ((apply === null || apply === void 0 ? void 0 : apply.isResponse()) || (apply === null || apply === void 0 ? void 0 : apply.isConfirmAction()) || (apply === null || apply === void 0 ? void 0 : apply.isConfirmArgs()) || (apply === null || apply === void 0 ? void 0 : apply.isEnsure())) {
                    return [...apply.getResponseInfo()];
                }
            }
            return collectArray(node, findResponses);
        }
    }
    /**
     * Find the very beginning expr of property chain
     *
     * ```
     * a.b.c => a
     * a().b.c => a()
     * com.api.a.b.c => com.api.a
     * ```
     */
    getPropertyChainRootExpression(propertyRef) {
        let temp = propertyRef;
        while ((temp === null || temp === void 0 ? void 0 : temp.kind) === "PropertyReference") {
            const fullName = ask.PropertyReference.tryResolveQualifiedName(temp);
            if (fullName !== undefined && this.lookupQualifiedName(fullName) !== undefined) {
                return temp;
            }
            temp = temp.expression;
        }
        return temp;
    }
    /**
     * check whether the node is a nameReference
     *
     * 1. if node is of "NameReference" Type, then it's a nameReference
     * 2. if node is of "PropertyReference", then check whether it's QFN point to a node. E.G. test.getPerson,
     *    "test" is a namespace, thus this should also be treated as nameReference
     */
    isNameReference(node) {
        if (node === undefined) {
            return false;
        }
        if (node.kind === "NameReference") {
            return true;
        }
        if (node.kind === "PropertyReference") {
            const fqn = ask.PropertyReference.tryResolveQualifiedName(node);
            if (this.lookupQualifiedName(fqn) !== undefined) {
                return true;
            }
        }
        return false;
    }
    /**
     * Get all NameDeclarations under module scope
     */
    getAllModuleScopeNameDeclarations() {
        const nameDecls = [];
        this.global.scope.forEach((value) => {
            if (value) {
                if (Array.isArray(value)) {
                    value.forEach((node) => {
                        if (node.kind === "NameDeclaration") {
                            nameDecls.push(node);
                        }
                    });
                }
                else if (value.kind === "NameDeclaration") {
                    nameDecls.push(value);
                }
            }
        });
        return nameDecls;
    }
    /**
     * collect locale info based on input
     *
     * E.G.
     * 1. when input is a nameDecl
     * ```
     * @locale(Locale.en_US)
     * myWelcome = apla("./apla/document.json")
     *
     * collectLocaleInfo(myWelcome) => ['en_US']
     * ```
     *
     * 2. when input is a nameReference
     * ```
     * @locale(Locale.en_US)
     * myWelcome = apla("./apla/document.json")
     * temp = myWelcome
     * collectLocaleInfo(temp) => ['en_US']
     * ```
     *
     * 3. when input is a propertyReference
     * ```
     * namespace test
     * @locale(Locale.en_US)
     * myWelcome = apla("./apla/document.json")
     * temp = myWelcome
     * collectLocaleInfo(test.temp) => ['en_US']
     *
     * 4. when input is variations call
     * ```
     * namespace test
     * @locale(Locale.en_US)
     * myWelcomeEN = apla("./apla/document.json")
     *
     * @locale(Locale.en_GB)
     * myWelcomeGB = apla("./apla/document.json")
     *
     * myWelcome = variations(myWelcomeEN, myWelcomeGB)
     *
     * collectLocaleInfo(test.myWelcome) => ['en_US', 'en_GB']
     *
     * 5. when input is nested variations call
     * ```
     * namespace test
     * @locale(Locale.en_US)
     * myWelcomeUS = apla("./apla/document.json")
     *
     * @locale(Locale.en_GB)
     * myWelcomeGB = apla("./apla/document.json")
     *
     * myWelcomeEN = variations(myWelcomeEN, myWelcomeGB)
     *
     * @locale(Locale.ja_JP)
     * myWelcomeJP = apla("./apla/document.json")
     *
     * myWelcome = variations(myWelcomeEN, myWelcomeJP)
     *
     * collectLocaleInfo(test.myWelcome) => ['en_US', 'en_GB', 'en_JP']
     */
    collectLocaleInfo(input) {
        var _a, _b, _c, _d, _e, _f, _g;
        const locales = [];
        // handle variations action call
        if (input.kind === "Call") {
            const apply = this.getApply(input);
            if (apply === null || apply === void 0 ? void 0 : apply.isVariations()) {
                const argumentValueThing = apply.getArgumentValueThing("variations");
                if (argumentValueThing === null || argumentValueThing === void 0 ? void 0 : argumentValueThing.isList()) {
                    const items = argumentValueThing.getListItems();
                    items === null || items === void 0 ? void 0 : items.forEach((item) => {
                        var _a, _b;
                        if (((_a = item === null || item === void 0 ? void 0 : item.item) === null || _a === void 0 ? void 0 : _a.kind) === "NameReference" || ((_b = item === null || item === void 0 ? void 0 : item.item) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                            locales.push(...this.collectLocaleInfo(item.item));
                        }
                    });
                }
            }
            return locales;
        }
        // handle nameDecl
        if (ask.isNameDeclaration(input)) {
            if (((_a = input.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call") {
                const apply = this.getApply(input.expression);
                if (apply === null || apply === void 0 ? void 0 : apply.isVariations()) {
                    return this.collectLocaleInfo(input.expression);
                }
                else if (((_c = (_b = input.expression) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name) === "MultiModalResponse") {
                    const apla = apply === null || apply === void 0 ? void 0 : apply.getArgumentValue("apla");
                    const apl = apply === null || apply === void 0 ? void 0 : apply.getArgumentValue("apl");
                    return [...getArgumentValueLocales(apla, this), ...getArgumentValueLocales(apl, this)];
                }
            }
            (_d = input.annotations) === null || _d === void 0 ? void 0 : _d.forEach((annotation) => {
                if (annotation.kind === "Annotation" && annotation.call && annotation.call.kind === "Call") {
                    const apply = this.getApply(annotation.call);
                    if (apply !== undefined && apply.isLocaleAction()) {
                        const localeValueThing = apply.getArgumentValueThing("locales");
                        if (localeValueThing === null || localeValueThing === void 0 ? void 0 : localeValueThing.isList()) {
                            const items = localeValueThing.getListItems();
                            items === null || items === void 0 ? void 0 : items.forEach((item) => {
                                var _a, _b, _c;
                                if (ask.isPropRef(item === null || item === void 0 ? void 0 : item.item) && ((_b = (_a = item === null || item === void 0 ? void 0 : item.item.expression) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === "Locale" && ((_c = item.item.name) === null || _c === void 0 ? void 0 : _c.name)) {
                                    locales.push(item.item.name.name);
                                }
                            });
                        }
                    }
                }
            });
        }
        // handle nameReference and propertyReference
        if (input.kind === "NameReference" || input.kind === "PropertyReference") {
            const thing = this.getThing(input);
            if (ask.isNameDeclaration((_e = thing === null || thing === void 0 ? void 0 : thing.origin) === null || _e === void 0 ? void 0 : _e.context)) {
                return this.collectLocaleInfo((_f = thing === null || thing === void 0 ? void 0 : thing.origin) === null || _f === void 0 ? void 0 : _f.context);
            }
            if (thing === null || thing === void 0 ? void 0 : thing.isObject()) {
                return (_g = thing.getLocales()) !== null && _g !== void 0 ? _g : [];
            }
        }
        return locales;
        function getArgumentValueLocales(value, checker) {
            if ((value && checker.isNameReference(value)) || ask.isNameDeclaration(value)) {
                return checker.collectLocaleInfo(value);
            }
            return [];
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jaGVja2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxTQUFTLE1BQU0sV0FBVyxDQUFDO0FBQ3ZDLE9BQU8sS0FBSyxHQUFHLE1BQU0sT0FBTyxDQUFDO0FBRTdCLE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDOUIsT0FBTyxFQUFDLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQVMsTUFBTSxPQUFPLENBQUM7QUFDekUsT0FBTyxFQUFDLGFBQWEsRUFBUyxNQUFNLFVBQVUsQ0FBQztBQUMvQyxPQUFPLEVBQUMsbUJBQW1CLEVBQUUsaUJBQWlCLEVBQWdCLGlCQUFpQixFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFFeEcsT0FBTyxFQUFDLE9BQU8sRUFBRSxZQUFZLEVBQUUsc0JBQXNCLEVBQUUsc0JBQXNCLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFHN0YsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUM1Qix3R0FBd0c7QUFDeEcsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUMvQixPQUFPLEVBQUMsY0FBYyxFQUFFLFlBQVksRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUVyRCxPQUFPLEVBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQVMsVUFBVSxFQUFFLFNBQVMsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUM3RixPQUFPLEVBQVEsTUFBTSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBRXRDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUVWOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFdBQVc7SUEwRHRCO0lBQ0U7O09BRUc7SUFDYSxPQUFnQjtJQUNoQzs7T0FFRztJQUNhLElBQWtCO0lBQ2xDOztPQUVHO0lBQ0gsTUFBOEM7SUFDOUM7O09BRUc7SUFDTSxLQUFxRDs7Ozs7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