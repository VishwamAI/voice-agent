import { ValidationErrorFactory } from ".";
/**
 * Node in a tree useful to validate property paths in an utterance. See buildPropertyTree for details.
 */
export class PropertyNode {
    /**
     *
     * @param property a Property in a type
     * @param propertyType the corresponding propertyType
     * @param children nodes corresponding to propertyType.Properties
     */
    constructor(property, propertyType, children = new Map()) {
        Object.defineProperty(this, "property", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: property
        });
        Object.defineProperty(this, "propertyType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: propertyType
        });
        Object.defineProperty(this, "children", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: children
        });
    }
    /**
     * Out of a string in Utterances<MealOrderType> like:
     *  'I want a {pizzaOrder.size} {pizzaOrder.pizzaType} pizza and a {drinkOrder.size} {drinkOrder.drinkType} drink'
     * This will build a tree like seen below where each Parenthesis is a Property with the given name and type:
     *
     *                                                    ('', MealOrderType)
     *
     *                 ('pizzaOrder', PizzaOrderType)                                      ('drinkOrder', DrinkOrderType)
     *
     *     ('pizzaType' ,PizzaType)          ('size', PizzaSizeType)             ('drinkType', DrinkType)        ('size', DrinkSizeType)
     *
     * In the process of building the tree 'no such property' errors can be produced.
     * With the tree, at each node, we can verify if the required properties have been specified
     * @param propertyPaths each ask.Name contains dot separate property path like 'pizzaOrder.size' plus its location for error messages.
     * @param type the type where all the first segments in propertyPaths are supposed to belong to.
     * @param context used for type's toString
     * @param getPropertyMap memoized type's getPropertyMap
     * @returns errors and the root of the tree
     */
    static buildPropertyTree(propertyPaths, type, context, getPropertyMap) {
        var _a, _b;
        const errors = [];
        const root = new PropertyNode({ name: "", type, kind: "Property", index: 0 }, type);
        for (const propertyPath of propertyPaths) {
            const segments = ((_a = propertyPath.name) !== null && _a !== void 0 ? _a : "").split(".");
            let currentType = type;
            let currentNode = root;
            let propertyFound = true;
            for (const segment of segments) {
                const propertyToTypes = getPropertyMap(currentType);
                const segmentProperty = propertyToTypes.get(segment);
                const segmentType = segmentProperty === null || segmentProperty === void 0 ? void 0 : segmentProperty.type;
                if (!segmentProperty) {
                    propertyFound = false;
                    errors.push(ValidationErrorFactory.UnknownProperty({
                        expr: propertyPath,
                        attributes: {
                            propertyName: segment,
                            typeName: currentType.toString(context),
                        },
                    }));
                    continue;
                }
                if (!segmentType) {
                    propertyFound = false;
                    errors.push(ValidationErrorFactory.NameNotFoundInUtteranceValue({
                        expr: propertyPath,
                        attributes: {
                            value: segment,
                        },
                    }));
                    continue;
                }
                let segmentNode = currentNode.children.get(segment);
                if (!segmentNode) {
                    segmentNode = new PropertyNode(segmentProperty, segmentType);
                    currentNode.children.set(segment, segmentNode);
                }
                currentType = segmentType.getNonOptionalType();
                currentNode = segmentNode;
            }
            const elementType = currentType.isList()
                ? currentType.getListItemType()
                : currentType.isOptional()
                    ? currentType.getNonOptionalType()
                    : currentType;
            const isTypeValid = (elementType === null || elementType === void 0 ? void 0 : elementType.isBuiltIn()) || (elementType === null || elementType === void 0 ? void 0 : elementType.isCoreType()) || (elementType === null || elementType === void 0 ? void 0 : elementType.isAlexaSchema()) || (elementType === null || elementType === void 0 ? void 0 : elementType.isSlotType());
            if (propertyFound && !(elementType === null || elementType === void 0 ? void 0 : elementType.isValidForUtterance())) {
                errors.push(ValidationErrorFactory.UndefinedCatalogCustomType({
                    expr: propertyPath,
                    attributes: {
                        propertyName: (_b = propertyPath.name) !== null && _b !== void 0 ? _b : "",
                        propertyType: elementType === null || elementType === void 0 ? void 0 : elementType.toString(propertyPath),
                    },
                }));
            }
        }
        return { errors, root };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvcGVydHktbm9kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcm9wZXJ0eS1ub2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBYSxzQkFBc0IsRUFBQyxNQUFNLEdBQUcsQ0FBQztBQUtyRDs7R0FFRztBQUNILE1BQU0sT0FBTyxZQUFZO0lBQ3ZCOzs7OztPQUtHO0lBQ0gsWUFBcUIsUUFBa0IsRUFBVyxZQUFrQixFQUFXLFdBQVcsSUFBSSxHQUFHLEVBQXdCOzs7OzttQkFBcEc7Ozs7OzttQkFBNkI7Ozs7OzttQkFBNkI7O0lBQTZDLENBQUM7SUFFN0g7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWtCRztJQUNJLE1BQU0sQ0FBQyxpQkFBaUIsQ0FDN0IsYUFBeUIsRUFDekIsSUFBVSxFQUNWLE9BQTZCLEVBQzdCLGNBQXFEOztRQUVyRCxNQUFNLE1BQU0sR0FBaUIsRUFBRSxDQUFDO1FBQ2hDLE1BQU0sSUFBSSxHQUFHLElBQUksWUFBWSxDQUFDLEVBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDbEYsS0FBSyxNQUFNLFlBQVksSUFBSSxhQUFhLEVBQUU7WUFDeEMsTUFBTSxRQUFRLEdBQUcsQ0FBQyxNQUFBLFlBQVksQ0FBQyxJQUFJLG1DQUFJLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN0RCxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUM7WUFDdkIsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDO1lBQ3ZCLElBQUksYUFBYSxHQUFHLElBQUksQ0FBQztZQUN6QixLQUFLLE1BQU0sT0FBTyxJQUFJLFFBQVEsRUFBRTtnQkFDOUIsTUFBTSxlQUFlLEdBQUcsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUNwRCxNQUFNLGVBQWUsR0FBRyxlQUFl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