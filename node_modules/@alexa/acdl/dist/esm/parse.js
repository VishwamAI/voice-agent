import * as antlr from "antlr4ts";
import * as acdl from "./syntax";
import * as ask from "./ast";
import { sourceFile } from "./source-file";
import { Try } from "./try";
import { getNamespace, readFile, readFileSync, readJsonFile, readJsonFileSync, sanitize, trimScheme } from "./util";
import { ActionTypeName, AlexaConversations, AlexaSchema, DialogTypeName, FunctionTypeName } from "./ast";
import { ValidationErrorFactory } from "./error-factory";
export class Counter {
    constructor(counter = 0) {
        Object.defineProperty(this, "counter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: counter
        });
    }
    nextId() {
        this.counter += 1;
        return this.counter;
    }
}
export class ParseContext {
    constructor(uri, namespace, nameCounter, errors, scope, imports) {
        Object.defineProperty(this, "uri", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: uri
        });
        Object.defineProperty(this, "namespace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: namespace
        });
        Object.defineProperty(this, "nameCounter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: nameCounter
        });
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: errors
        });
        Object.defineProperty(this, "scope", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: scope
        });
        Object.defineProperty(this, "imports", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: imports
        });
    }
    hasOptionalImported() {
        return (this.imports.find((i) => (i.kind === "ImportName" && i.name === AlexaSchema.Optional) ||
            (i.kind === "ImportNamespace" && i.name === getNamespace(AlexaSchema.Optional))) !== undefined);
    }
    withScope(scope) {
        return new ParseContext(this.uri, this.namespace, this.nameCounter, this.errors, scope, this.imports);
    }
    addError(err) {
        this.errors.push(err);
    }
    newName() {
        return `var${this.nameCounter.nextId()}`;
    }
}
/**
 * Load an ASK Module file from file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.json`.
 * @param uri file path of the Module File
 * @returns source file of the module if it is a valid module, otherwise `undefined`.
 */
export function loadModuleFileSync(baseDir, uri) {
    const json = readJsonFileSync(trimScheme(uri));
    if ((json === null || json === void 0 ? void 0 : json.schema) === ask.ModuleSchema) {
        try {
            return sourceFile(baseDir, uri, ask.fromASKModule(json, uri));
        }
        catch (err) {
            console.log(`failed to load module file: ${uri}`);
            console.error(err);
            throw err;
        }
    }
    else {
        return undefined;
    }
}
/**
 * Load an ASK Module file from file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.json`.
 * @param uri file path of the Module File
 * @returns source file of the module if it is a valid module, otherwise `undefined`.
 */
export async function loadModuleFile(baseDir, uri) {
    const json = await readJsonFile(trimScheme(uri));
    if ((json === null || json === void 0 ? void 0 : json.schema) === ask.ModuleSchema) {
        try {
            return sourceFile(baseDir, uri, ask.fromASKModule(json, uri));
        }
        catch (err) {
            console.log(`failed to load module file: ${uri}`);
            console.error(err);
            throw err;
        }
    }
    else {
        return undefined;
    }
}
/**
 * Load an ACDL file from the file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.acdl`.
 * @param uri file path of the Module File
 * @param content optionally pass the ACDL string content already read from the file
 */
export function loadACDLFileSync(dir, uri, content) {
    return sourceFile(dir, uri, ...parseACDLFile(uri, content !== null && content !== void 0 ? content : readFileSync(uri)));
}
/**
 * Load an ACDL file from the file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.acdl`.
 * @param uri file path of the Module File
 * @param content optionally pass the ACDL string content already read from the file
 */
export async function loadACDLFile(dir, uri, content) {
    return sourceFile(dir, uri, ...parseACDLFile(uri, content !== null && content !== void 0 ? content : (await readFile(uri))));
}
/**
 * Parse an ACDL file.
 *
 * @param content ACDL file content
 */
export function parseACDLFile(uri, content) {
    const lexer = new acdl.ACDLLexer(antlr.CharStreams.fromString(content));
    const tokenStream = new antlr.CommonTokenStream(lexer);
    const parser = new acdl.ACDLParser(tokenStream);
    const errors = [];
    parser.removeErrorListeners();
    parser.addErrorListener({
        syntaxError: (recognizer, offendingSymbol, line, charPositionInLine, msg) => {
            errors.push(ValidationErrorFactory.SyntaxError({
                expr: {
                    uri,
                    loc: {
                        begin: { line, character: charPositionInLine },
                        end: { line, character: charPositionInLine },
                    },
                },
                overrideMessage: msg,
            }));
        },
    });
    let module;
    try {
        const unit = parser.module();
        const nameCounter = new Counter();
        const imports = [];
        const namespaceNode = Try(() => unit.namespaceDeclaration())
            .flatMap((ns) => Try(() => ns === null || ns === void 0 ? void 0 : ns.qualifiedName()))
            .getOrDefault(undefined);
        const context = new ParseContext(uri, namespaceNode === null || namespaceNode === void 0 ? void 0 : namespaceNode.text, nameCounter, errors, [], imports);
        const namespace = new ask.Name(namespaceNode === null || namespaceNode === void 0 ? void 0 : namespaceNode.text, namespaceNode ? parseLocation(namespaceNode) : undefined);
        unit.moduleExpression().forEach((expr) => {
            if (expr.importDeclaration()) {
                imports.push(new ask.Import(expr.importDeclaration().ASTERISK() ? "ImportNamespace" : "ImportName", expr.importDeclaration().qualifiedName().text, parseLocation(expr)));
            }
        });
        const expressions = unit
            .moduleExpression()
            .map((expr) => {
            if (expr.actionDeclaration()) {
                return parseActionDeclaration(expr.actionDeclaration(), context);
            }
            if (expr.dialogDeclaration()) {
                return parseDialogDeclaration(expr.dialogDeclaration(), context);
            }
            if (expr.interactionDeclaration()) {
                return parseInteractionDeclaration(expr.interactionDeclaration(), context);
            }
            if (expr.qualifiedNameDeclaration()) {
                return parseNameDeclaration(expr.qualifiedNameDeclaration(), context);
            }
            if (expr.typeDeclaration()) {
                return parseTypeDeclaration(expr.typeDeclaration(), context);
            }
            if (expr.enumDeclaration()) {
                return parseEnumDeclaration(expr.enumDeclaration(), context);
            }
            if (expr.expression()) {
                return parseExpression(expr.expression(), context);
            }
            return undefined;
        })
            .filter((e) => e !== undefined);
        const exports = expressions.map((e) => { var _a; return e.kind !== "InteractionDeclaration" && ((_a = e === null || e === void 0 ? void 0 : e.name) === null || _a === void 0 ? void 0 : _a.name); }).filter((n) => n !== undefined);
        module = new ask.Module(uri, ask.ModuleSchema, namespace, imports, exports, expressions);
    }
    catch (err) {
        module = undefined;
    }
    return [module, errors || undefined];
}
/**
 * Parse the qualified name component of a module-level declaration.
 *
 * That include:
 * - ActionDeclaration
 * - DialogDeclaration
 * - QualifiedNameDeclaration
 * - TypeDeclaration
 */
export function parseModuleLevelNameDeclaration(node, context) {
    let name = parseQualifiedName(node);
    if (name.name) {
        if (name.name.includes(".")) {
            name = new ask.Name(name.name, name.loc);
        }
        else if (context.namespace) {
            name = new ask.Name(`${context.namespace}.${name.name}`, name.loc);
        }
        else {
            name = new ask.Name(name.name, name.loc);
        }
    }
    return name;
}
export function parseEnumDeclaration(type, context) {
    return new ask.EnumDeclaration(parseModuleLevelNameDeclaration(type.qualifiedName(), context), type.enumItem().map((id) => parseEnumItem(id, context)), parseAnnotationList(type.annotationList(), context), parseLocation(type));
}
export function parseEnumItem(item, context) {
    return new ask.EnumItem(parseIdentifier(item.identifier()), parseAnnotationList(item.annotationList(), context), parseLocation(item));
}
export function parseAnnotationList(annotationList, context) {
    var _a;
    const list = ((_a = annotationList === null || annotationList === void 0 ? void 0 : annotationList.annotation()) === null || _a === void 0 ? void 0 : _a.map((annotation) => new ask.Annotation(parseCall(annotation.call(), context)), undefined)) || undefined;
    if (list === undefined || list.length === 0) {
        return undefined;
    }
    return list;
}
export function parseTypeDeclaration(type, context) {
    var _a;
    const name = parseModuleLevelNameDeclaration(type.qualifiedName(), context);
    return new ask.TypeDeclaration(name, sanitize(Try(() => type.typeProperties())
        .flatMap((typeBody) => Try(() => typeBody === null || typeBody === void 0 ? void 0 : typeBody.typeProperty()).map((typeProperties) => typeProperties === null || typeProperties === void 0 ? void 0 : typeProperties.map((typeProperty) => parseTypeProperty(typeProperty, context))))
        .resolve(context)), sanitize(parseTypeArgumentDeclarations(type.typeArgumentDeclarations(), context)), sanitize((_a = type.typeConstraint()) === null || _a === void 0 ? void 0 : _a.map((e) => parseTypeReference(e.typeReference(), context))), parseAnnotationList(type.annotationList(), context), parseLocation(type));
}
export function parseTypeArgumentDeclarations(args, context) {
    return args === null || args === void 0 ? void 0 : args.typeArgumentDeclaration().map((arg) => parseTypeArgumentDeclaration(arg, context));
}
export function parseTypeArgumentDeclaration(arg, context) {
    var _a;
    return new ask.TypeParameter(parseIdentifier(arg.identifier()), sanitize((_a = arg.typeConstraint()) === null || _a === void 0 ? void 0 : _a.map((constraint) => parseTypeReference(constraint.typeReference(), context))), parseLocation(arg));
}
export function parseTypeReference(reference, context) {
    var _a, _b;
    let loc;
    if (reference.typeArguments() === undefined) {
        loc = parseIdentifierLocation(reference.qualifiedName());
    }
    else {
        loc = parseLocation(reference);
    }
    return new ask.TypeReference(Try(() => reference.qualifiedName())
        .map((name) => parseQualifiedName(name))
        .resolve(context), sanitize((_b = (_a = reference
        .typeArguments()) === null || _a === void 0 ? void 0 : _a.typeReference()) === null || _b === void 0 ? void 0 : _b.map((ref) => parseTypeReference(ref, context))), parseAnnotationList(reference.annotationList(), context), undefined, loc);
}
export function parseTypeProperty(property, context) {
    return new ask.TypeProperty(property.identifier() ? parseIdentifier(property.identifier()) : undefined, Try(() => property.typeReference())
        .map((t) => parseTypeReference(t, context))
        .resolve(context), Try(() => property.OPTIONAL())
        .map((o) => !!o)
        .resolve(context), parseAnnotationList(property.annotationList(), context), parseLocation(property));
}
export function parseNamespaceDeclaration(namespace, context) {
    return new ask.Name(Try(() => namespace.qualifiedName())
        .map((name) => name.text)
        .resolve(context), parseLocation(namespace));
}
export function parseDialogDeclaration(dialog, context) {
    const functionDecl = parseFunctionSignature(dialog.functionSignature(), context);
    return new ask.DialogDeclaration(functionDecl.name, functionDecl.args, Try(() => dialog.dialogScope())
        .flatMap((body) => Try(() => body === null || body === void 0 ? void 0 : body.sampleDeclaration()).map((samples) => (samples === null || samples === void 0 ? void 0 : samples.map((s) => parseSampleDeclaration(s, context))) || []))
        .resolve(context), functionDecl.returnType, functionDecl.genericArguments, parseAnnotationList(dialog.annotationList(), context), parseLocation(dialog));
}
export function parseSampleDeclaration(sample, context) {
    return new ask.Sample(Try(() => sample.block())
        .map((_) => parseScope(_, context, ask.Block))
        .resolve(context), parseAnnotationList(sample.annotationList(), context), parseLocation(sample));
}
export function parseScope(body, context, ctor) {
    return Try(() => body.blockExpression())
        .map((expressions) => {
        const scopeExpressions = [];
        const scopeContext = context;
        for (const expr of expressions) {
            const parsedExpr = parseScopeExpression(expr, scopeContext);
            if (parsedExpr !== undefined) {
                scopeExpressions.push(parsedExpr); // TODO: assert
            }
        }
        return new ctor(scopeExpressions, parseLocation(body));
    })
        .resolve(context);
}
export function parseScopeExpression(expr, context) {
    if (expr.nameDeclaration()) {
        return parseNameDeclaration(expr.nameDeclaration(), context);
    }
    if (expr.expression()) {
        return parseExpression(expr.expression(), context);
    }
    return undefined;
}
export function parseInteractionDeclaration(expr, context) {
    return new ask.InteractionDeclaration(Try(() => expr.block())
        .map((_) => parseScope(_, context, ask.InteractionScope))
        .resolve(context), parseAnnotationList(expr.annotationList(), context), parseLocation(expr));
}
export function parseExpression(expr, context) {
    if (expr instanceof acdl.ParenthesizedExprContext) {
        return Try(() => expr.expression())
            .map((expr) => parseExpression(expr, context))
            .resolve(context);
    }
    if (expr instanceof acdl.LiteralExprContext || expr instanceof acdl.LiteralContext) {
        return parseLiteral(expr, context).resolve(context);
    }
    if (expr instanceof acdl.ObjectContext) {
        return Try(() => parseObject(expr, context)).resolve(context);
    }
    if (expr instanceof acdl.PropertyReferenceContext) {
        return parsePropertyReference(expr, context);
    }
    if (expr instanceof acdl.ListIndexContext) {
        return Try(() => parseListIndex(expr, context)).resolve(context);
    }
    if (expr instanceof acdl.CallExprContext) {
        return Try(() => parseCall(expr.call(), context)).resolve(context);
    }
    if (expr instanceof acdl.BinaryExprContext) {
        return parseBinaryExpression(expr, context).resolve(context);
    }
    if (expr instanceof acdl.NameDeclarationContext || expr instanceof acdl.QualifiedNameDeclarationContext) {
        return Try(() => parseNameDeclaration(expr, context)).resolve(context);
    }
    if (expr instanceof acdl.ConditionExprContext) {
        return Try(() => parseCondition(expr.condition(), context)).resolve(context);
    }
    if (expr instanceof acdl.CorrectionExprContext) {
        return Try(() => parseCorrection(expr.correction(), context)).resolve(context);
    }
    if (expr instanceof acdl.IdentifierExprContext) {
        return parseNameReference(expr, context);
    }
    if (expr instanceof acdl.IsExprContext) {
        return parseIsOperator(expr, context);
    }
    if (expr instanceof acdl.InExprContext) {
        return parseInOperator(expr, context);
    }
    const errorFactory = expr.text
        ? ValidationErrorFactory.UnexpectedOperatorWithText
        : ValidationErrorFactory.UnexpectedOperator;
    const error = errorFactory({
        expr: {
            uri: context.uri,
            loc: parseLocation(expr),
        },
        attributes: {
            expressionText: expr.text,
            constructorName: expr.constructor.name,
        },
    });
    context.addError(error);
    return undefined;
}
export function parseNameReference(expr, context) {
    return new ask.NameReference(parseIdentifier(expr.identifier()), undefined, parseIdentifierLocation(expr.identifier()));
}
export function parsePropertyReference(expr, context) {
    var _a, _b;
    const child = parseExpression(expr.expression(), context); // TODO: type check
    if (child === undefined) {
        return undefined;
    }
    const id = parseIdentifier(expr.identifier());
    const loc = parseLocation(expr);
    if (loc) {
        loc.end = (_b = (_a = id === null || id === void 0 ? void 0 : id.loc) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : loc.end;
    }
    const prop = new ask.PropertyReference(id, child, undefined, loc);
    return prop;
}
export function parseCondition(expr, context) {
    var _a, _b, _c, _d;
    const loc = parseLocation(expr);
    let elseScope;
    if (((_a = expr.otherwise()) === null || _a === void 0 ? void 0 : _a.condition()) !== undefined) {
        const elseIfCondition = parseCondition((_b = expr.otherwise()) === null || _b === void 0 ? void 0 : _b.condition(), context);
        elseScope = new ask.ElseScope(elseIfCondition ? [elseIfCondition] : undefined);
    }
    else if (((_c = expr.otherwise()) === null || _c === void 0 ? void 0 : _c.block()) !== undefined) {
        elseScope = parseScope((_d = expr.otherwise()) === null || _d === void 0 ? void 0 : _d.block(), context, ask.ElseScope);
    }
    return new ask.Condition(new ask.When(Try(() => expr.expression())
        .map((when) => parseExpression(when, context))
        .resolve(context)), // TODO: check,
    Try(() => expr.block())
        .map((body) => (body ? parseScope(body, context, ask.ThenScope) : undefined))
        .resolve(context), elseScope, undefined, loc);
}
export function parseCorrection(expr, context) {
    return new ask.Correction(Try(() => expr.block(0))
        .map((blockContext) => parseScope(blockContext, context, ask.CorrectionScope))
        .resolve(context), Try(() => expr.block(1))
        .map((blockContext) => parseScope(blockContext, context, ask.CorrectionScope))
        .resolve(context), parseLocation(expr));
}
export function parseBinaryExpression(expr, context) {
    const loc = parseLocation(expr);
    return Try(() => {
        if (expr._left) {
            return new ask.Call(new ask.Name(parseBooleanOperator(expr, context)), [asArgumentValue(expr._left, "left"), asArgumentValue(expr._right, "right")], undefined, undefined, loc);
        }
        if (expr.NOT()) {
            return new ask.Call(new ask.Name(AlexaConversations.Not), [asArgumentValue(expr._right, "right")], undefined, undefined, loc);
        }
        throw [
            ValidationErrorFactory.UnexpectedBooleanExpression({
                expr: {
                    loc,
                },
                attributes: {
                    expressionText: expr.text,
                },
            }),
        ];
    });
    function asArgumentValue(expr, name) {
        return new ask.Argument(new ask.Name(name), undefined, parseExpression(expr, context), parseLocation(expr));
    }
}
export function parseBooleanOperator(expr, context) {
    var _a, _b, _c, _d, _e, _f;
    const loc = parseLocation(expr);
    if (expr.AND()) {
        return AlexaConversations.And;
    }
    if (expr.OR()) {
        return AlexaConversations.Or;
    }
    if ((_a = expr.relational()) === null || _a === void 0 ? void 0 : _a.GE()) {
        return AlexaConversations.Gte;
    }
    if ((_b = expr.relational()) === null || _b === void 0 ? void 0 : _b.GT()) {
        return AlexaConversations.Gt;
    }
    if ((_c = expr.relational()) === null || _c === void 0 ? void 0 : _c.LE()) {
        return AlexaConversations.Lte;
    }
    if ((_d = expr.relational()) === null || _d === void 0 ? void 0 : _d.LT()) {
        return AlexaConversations.Lt;
    }
    if ((_e = expr.equality()) === null || _e === void 0 ? void 0 : _e.EQUAL()) {
        return AlexaConversations.Eq;
    }
    if ((_f = expr.equality()) === null || _f === void 0 ? void 0 : _f.NOTEQUAL()) {
        return AlexaConversations.Neq;
    }
    context.addError(ValidationErrorFactory.UnexpectedBooleanOperator({
        expr: {
            loc,
        },
        attributes: {
            expressionText: expr.text,
        },
    }));
    return undefined;
}
export function parseCall(expr, context) {
    var _a, _b;
    const name = Try(() => expr.qualifiedName())
        .map((fqn) => parseQualifiedName(fqn))
        .resolve(context);
    const args = Try(() => expr.callArguments())
        .flatMap((list) => Try(() => list === null || list === void 0 ? void 0 : list.callArgument()).map((argumentList) => argumentList === null || argumentList === void 0 ? void 0 : argumentList.map((a, i) => parseArgumentValue(a, context, i))))
        .resolve(context);
    const genericArguments = sanitize((_b = (_a = expr
        .typeArguments()) === null || _a === void 0 ? void 0 : _a.typeReference()) === null || _b === void 0 ? void 0 : _b.map((ref) => parseTypeReference(ref, context)));
    return new ask.Call(name, args, genericArguments, undefined, parseLocation(expr));
}
export function parseArgumentValue(argument, context, index) {
    const name = Try(() => argument.identifier())
        .map((i) => (i ? parseIdentifier(i) : undefined))
        .resolve(context);
    const value = Try(() => argument.expression())
        .map((expr) => parseExpression(expr, context))
        .resolve(context); // TODO: type-check
    const loc = name && name.loc && (value === null || value === void 0 ? void 0 : value.loc) ? ask.appendLocation(name.loc, value.loc) : value === null || value === void 0 ? void 0 : value.loc;
    return new ask.Argument(name, index, value, loc);
}
export function parseLiteral(literal, context) {
    const literalValue = literal.text;
    const litLoc = parseLocation(literal);
    const loc = {
        begin: litLoc.begin,
        end: {
            line: litLoc.begin.line,
            character: litLoc.begin.character + literal.text.length,
        },
    };
    return Try(() => {
        var _a, _b;
        if (literal.null()) {
            return createLiteral(AlexaSchema.Void, null, loc);
        }
        if (literal.nothing()) {
            return createLiteral(AlexaSchema.Nothing, null, loc);
        }
        if (literal.string()) {
            const vars = (_a = literal.string()) === null || _a === void 0 ? void 0 : _a.var();
            const text = literalValue.slice(1, literalValue.length - 1);
            let value = text;
            if (vars && vars.length > 0) {
                value = new ask.Utterance(text, vars.map((v) => parseQualifiedName(v.qualifiedName())), parseLocation(literal));
            }
            return createLiteral(AlexaSchema.String, value, loc);
        }
        if (literal.number()) {
            const num = !literalValue.includes(".") ? parseInt(literalValue, 10) : parseFloat(literalValue);
            return createLiteral(AlexaSchema.Number, num, loc);
        }
        if (literal.bool()) {
            return createLiteral(AlexaSchema.Boolean, ((_b = literal.bool()) === null || _b === void 0 ? void 0 : _b.text.toLocaleLowerCase()) === "true", loc);
        }
        if (literal.object()) {
            return parseObject(literal.object(), context);
        }
        if (literal.list()) {
            return parseList(literal.list(), context);
        }
        console.error(literal);
        throw new Error("unexpected node type");
    });
}
export function createLiteral(type, value, loc) {
    return new ask.Call(new ask.Name(type), value, undefined, undefined, loc);
}
export function parseIsOperator(expr, context) {
    return new ask.Call(new ask.Name(AlexaConversations.is /* TODO: map the IS token to a source location */), [new ask.Argument(new ask.Name("thing"), 0, parseExpression(expr.expression(), context))], [parseTypeReference(expr.typeReference(), context)]);
}
export function parseInOperator(expr, context) {
    return new ask.Call(new ask.Name(AlexaConversations.in), [
        new ask.Argument(new ask.Name("entity"), 0, parseExpression(expr.expression(0), context)),
        new ask.Argument(new ask.Name("entities"), 0, parseExpression(expr.expression(1), context)),
    ]);
}
export function parseObject(obj, context) {
    const objectType = Try(() => obj.typeReference())
        .map((type) => (type ? parseTypeReference(type, context) : undefined))
        .resolve(context);
    return new ask.Call(objectType === null || objectType === void 0 ? void 0 : objectType.name, Try(() => obj.objectKeyValue())
        .map((pairs) => pairs.map((pair) => parseObjectProperty(pair, context)))
        .resolve(context), objectType === null || objectType === void 0 ? void 0 : objectType.arguments, undefined, parseLocation(obj));
}
export function parseObjectProperty(member, context) {
    const name = parseIdentifier(member.identifier());
    const expr = member.expression();
    const value = (expr === undefined
        ? // if no value is explicitly provided, default to a name reference
            // name = "hello"
            // person Person { name }
            // equiv. { name = name }
            new ask.NameReference(name, undefined, name.loc)
        : parseExpression(expr, context));
    return new ask.Argument(name, undefined, value, parseLocation(member));
}
/**
 * Parse a List literal to a call
 *
 * ```
 * list = ["a", "b"]
 * // or
 * list = List<String> ["a", "b"]
 *
 * // translates to an internal representations
 * alexa.lang.expression<List<String>>(items = ["a", "b"])
 * ```
 *
 * @param expr
 * @param parent
 * @param errors
 */
export function parseList(expr, context) {
    const loc = parseLocation(expr);
    const list = new ask.ListLiteral(expr
        .expression()
        .map((expr, index) => new ask.ListItem(parseExpression(expr, context), index, parseLocation(expr))), loc);
    return new ask.Call(undefined, list, undefined, undefined, parseLocation(expr));
}
/**
 * Parse syntactic sugar for accessing a list.
 *
 * ```
 * List<String> list = ...
 *
 * // access a list by index 0
 * list[0]
 *
 * // is syntactic sugar for the `inList` action:
 * com.amazon.alexa.ask.conversations.inList(list = list, index = 0)
 * com.amazon.alexa.ask.conversations.inList(list, 0)
 * ```
 *
 * TODO: support accessing properties in a List.
 * ```
 * // how should we translate this?
 * c = list[0].a.b.c
 *
 * // perhaps generate a variable for the result of accessing the list
 * var1 = inList(list, 0)
 * // and then a name expression?
 * c = var1.a.b.c
 * ```
 *
 * @param expr syntax for the list
 * @param parent
 * @param errors
 */
export function parseListIndex(expr, context) {
    const list = parseExpression(expr.expression(), context); // TODO: type-check
    const listArg = new ask.Argument(new ask.Name("list"), 0, list, parseLocation(expr));
    const indexNumber = Try(() => parseInt(expr.number().text, 10)).resolve(context);
    const indexLiteral = createLiteral(AlexaSchema.Number, indexNumber, parseLocation(expr.number()));
    const indexArg = new ask.Argument(new ask.Name("index"), 1, indexLiteral);
    return new ask.Call(new ask.Name(AlexaConversations.getListItem), [listArg, indexArg], undefined, undefined, parseLocation(expr));
}
export function parseActionDeclaration(action, context) {
    const functionDecl = parseFunctionSignature(action.functionSignature(), context);
    return new ask.ActionDeclaration(functionDecl.name, functionDecl.args, functionDecl.returnType, functionDecl.genericArguments, parseAnnotationList(action.annotationList(), context), parseLocation(action));
}
export function parseFunctionSignature(action, context, isTopLevel = true) {
    var _a, _b;
    let returnType;
    const _void = action.void();
    if (_void !== undefined || action.typeReference() === undefined) {
        returnType = new ask.TypeReference(new ask.Name(AlexaSchema.Void), undefined, parseAnnotationList(_void === null || _void === void 0 ? void 0 : _void.annotationList(), context), undefined, _void ? parseLocation(_void) : undefined);
    }
    else {
        returnType = parseTypeReference(action.typeReference(), context);
    }
    const functionDecl = {
        name: isTopLevel
            ? parseModuleLevelNameDeclaration((_a = action.qualifiedName()) !== null && _a !== void 0 ? _a : action.identifier(), context)
            : parseQualifiedName((_b = action.qualifiedName()) !== null && _b !== void 0 ? _b : action.identifier()),
        // TODO: what to do with this?
        args: Try(() => action.argumentDeclarations())
            .map((p) => (p ? parseArgumentDeclarations(p, context) : undefined))
            .resolve(context),
        returnType,
        genericArguments: parseTypeArgumentDeclarations(action.typeArgumentDeclarations(), context),
    };
    return functionDecl;
}
export function parseArgumentDeclarations(argumentDecls, context) {
    return argumentDecls.argumentDeclaration().map((p) => parseArgumentDeclaration(p, context));
}
export function parseArgumentDeclaration(argument, context) {
    var _a, _b;
    const defaultExpression = ((_a = argument.argumentDefault()) === null || _a === void 0 ? void 0 : _a.expression())
        ? parseExpression(argument.argumentDefault().expression(), context)
        : undefined;
    const isOptional = argument.OPTIONAL() !== undefined || ((defaultExpression === null || defaultExpression === void 0 ? void 0 : defaultExpression.kind) === "Call" && ((_b = defaultExpression === null || defaultExpression === void 0 ? void 0 : defaultExpression.name) === null || _b === void 0 ? void 0 : _b.name) === AlexaSchema.Nothing);
    if (argument.functionArgumentDeclaration()) {
        return parseFunctionArgumentDeclaration(argument.functionArgumentDeclaration());
    }
    if (argument.standardArgumentDeclaration()) {
        return parseStandardArgumentDeclaration(argument.standardArgumentDeclaration());
    }
    // fatal error, only these two options should be possible.
    throw new Error(`could not parse argument declaration: ${argument.text}`);
    function parseStandardArgumentDeclaration(argDecl) {
        var _a, _b;
        let type;
        if (isOptional) {
            if ((argDecl === null || argDecl === void 0 ? void 0 : argDecl.typeReference()) !== undefined) {
                const innerType = parseTypeReference(argDecl.typeReference(), context);
                if (((_a = innerType.name) === null || _a === void 0 ? void 0 : _a.name) === AlexaSchema.Optional || (((_b = innerType.name) === null || _b === void 0 ? void 0 : _b.name) === "Optional" && context.hasOptionalImported())) {
                    // type is already Optional, flatten.
                    // innerType.parent = self;
                    type = innerType;
                }
                else {
                    type = new ask.TypeReference(new ask.Name(AlexaSchema.Optional), [innerType], undefined, // innerType.annotations?.map((a) => a.clone()),
                    undefined);
                }
            }
            else {
                type = new ask.TypeReference(new ask.Name(AlexaSchema.Optional), [new ask.TypeReference(new ask.Name(AlexaSchema.Nothing), undefined, undefined, undefined)], undefined, undefined);
            }
        }
        else if (argDecl.typeReference() !== undefined) {
            type = parseTypeReference(argDecl.typeReference(), context);
        }
        else {
            type = new ask.TypeReference(new ask.Name(AlexaSchema.Nothing), undefined, undefined);
        }
        return new ask.ArgumentDeclaration(argDecl.identifier() ? parseIdentifier(argDecl.identifier()) : undefined, type, defaultExpression, parseAnnotationList(argument.annotationList(), context), parseLocation(argument));
    }
    function parseFunctionArgumentDeclaration(fun) {
        var _a, _b, _c, _d, _e, _f, _g;
        const functionSignature = parseFunctionSignature(fun.functionSignature(), context, false);
        const functionArgumentNames = (_c = (_b = (_a = fun
            .functionSignature()
            .argumentDeclarations()) === null || _a === void 0 ? void 0 : _a.argumentDeclaration()) === null || _b === void 0 ? void 0 : _b.map((a, i) => {
            var _a, _b, _c, _d;
            // TODO: this is probably risky??? ACDL will give syntax error though ...
            const defaultArgName = `arg${i}`;
            if (a.standardArgumentDeclaration()) {
                return (_b = (_a = a.standardArgumentDeclaration().identifier()) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : defaultArgName;
            }
            if (a.functionArgumentDeclaration()) {
                return (_d = (_c = a.functionArgumentDeclaration().functionSignature().identifier()) === null || _c === void 0 ? void 0 : _c.text) !== null && _d !== void 0 ? _d : defaultArgName;
            }
            return defaultArgName;
        })) !== null && _c !== void 0 ? _c : [];
        const functionArity = functionArgumentNames.length;
        const typeRefLoc = ((_d = functionSignature.name) === null || _d === void 0 ? void 0 : _d.loc)
            ? ask.betweenLocations(parseLocation(fun), (_e = functionSignature.name) === null || _e === void 0 ? void 0 : _e.loc)
            : parseLocation(fun);
        const typeRefName = fun.ACTION()
            ? ActionTypeName(functionArity)
            : fun.DIALOG()
                ? DialogTypeName(functionArity)
                : FunctionTypeName(functionArity);
        const type = new ask.TypeReference(new ask.Name(typeRefName, typeRefLoc), [...((_g = (_f = functionSignature.args) === null || _f === void 0 ? void 0 : _f.map((arg) => arg.type /* use an object to represent undefined */)) !== null && _g !== void 0 ? _g : []), functionSignature.returnType], undefined, functionArgumentNames, typeRefLoc);
        return new ask.ArgumentDeclaration(functionSignature.name, isOptional ? new ask.TypeReference(new ask.Name(AlexaSchema.Optional, type.loc), [type]) : type, defaultExpression, parseAnnotationList(argument.annotationList(), context));
    }
}
/**
 * Parse a name initialization expression.
 *
 * ```acdl
 * a = <expr>
 * ```
 *
 * @param nameDecl name parse tree
 * @param parent parent expression
 */
export function parseNameDeclaration(nameDecl, context) {
    const name = nameDecl instanceof acdl.QualifiedNameDeclarationContext
        ? parseModuleLevelNameDeclaration(nameDecl.qualifiedName(), context)
        : parseIdentifier(nameDecl.identifier());
    const type = nameDecl.typeReference() ? parseTypeReference(nameDecl.typeReference(), context) : undefined;
    const expr = Try(() => nameDecl.expression())
        .map((expr) => parseExpression(expr, context))
        .resolve(context);
    return new ask.NameDeclaration(name, type, expr, nameDecl instanceof acdl.QualifiedNameDeclarationContext ? parseAnnotationList(nameDecl.annotationList(), context) : undefined, parseLocation(nameDecl));
}
/**
 * Parse an identifier.
 *
 * @param id identifier parse tree
 * @param context parse context
 */
export function parseIdentifier(id) {
    return new ask.Name(id.text === "<missing IDENTIFIER>" ? undefined : id.text, parseIdentifierLocation(id));
}
export function parseIdentifierLocation(id) {
    const location = parseLocation(id);
    const loc = {
        begin: {
            line: location.begin.line,
            character: location.begin.character,
        },
        end: {
            line: location.begin.line,
            character: location.begin.character + id.text.length,
        },
    };
    return loc;
}
/**
 * Parse a qualified name.
 *
 * @param name identifier or qualified name.
 * @param parent parent expression
 */
export function parseQualifiedName(name, prefix = "") {
    const fullName = name.text;
    const lastDot = fullName.indexOf(".");
    const identifier = lastDot === -1 ? fullName : fullName.substring(lastDot + 1);
    const qualifier = lastDot === -1 ? undefined : fullName.substring(0, lastDot);
    // TODO: match name with regex and report errors.
    return new ask.Name(qualifier === undefined ? `${prefix}${identifier}` : `${qualifier}.${identifier}`, parseIdentifierLocation(name));
}
/**
 * Parse the location from a node in the parse tree.
 *
 * @param node parse tree node.
 */
export function parseLocation(node) {
    var _a, _b;
    const begin = {
        line: node.start.line,
        character: node.start.charPositionInLine,
    };
    // Antlr only gives us the "start of token" position.
    // To get "end of token" position we need to add the token length,
    // plus we need to adjust the line and column if there are newlines in the token's text
    const stopTokenText = (_a = node.stop) === null || _a === void 0 ? void 0 : _a.text;
    const stopTokenLines = (stopTokenText === null || stopTokenText === void 0 ? void 0 : stopTokenText.split("\\n")) || [];
    // Stop token has no text - no adjustment is needed
    if ((Array.isArray(stopTokenLines) && stopTokenLines.length > 0) || ((_b = node.stop) === null || _b === void 0 ? void 0 : _b.type) === antlr.Token.EOF) {
        return {
            begin,
            end: {
                line: node.stop.line,
                character: node.stop.charPositionInLine + 1,
            },
        };
    }
    const lastLineLength = stopTokenLines[stopTokenLines.length - 1].length;
    const tokenEnd = stopTokenLines.length === 1 ? node.stop.charPositionInLine + stopTokenText.length : lastLineLength;
    return {
        begin,
        end: {
            line: node.stop.line + stopTokenLines.length - 1,
            character: tokenEnd + 1,
        },
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcGFyc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLEtBQUssTUFBTSxVQUFVLENBQUM7QUFDbEMsT0FBTyxLQUFLLElBQUksTUFBTSxVQUFVLENBQUM7QUFDakMsT0FBTyxLQUFLLEdBQUcsTUFBTSxPQUFPLENBQUM7QUFFN0IsT0FBTyxFQUFDLFVBQVUsRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUVyRCxPQUFPLEVBQUMsR0FBRyxFQUFXLE1BQU0sT0FBTyxDQUFDO0FBQ3BDLE9BQU8sRUFBQyxZQUFZLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUNsSCxPQUFPLEVBQUMsY0FBYyxFQUFFLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQUUsZ0JBQWdCLEVBQUMsTUFBTSxPQUFPLENBQUM7QUFDeEcsT0FBTyxFQUFDLHNCQUFzQixFQUE4QixNQUFNLGlCQUFpQixDQUFDO0FBRXBGLE1BQU0sT0FBTyxPQUFPO0lBQ2xCLFlBQW9CLFVBQWtCLENBQUM7Ozs7O21CQUFuQjs7SUFBc0IsQ0FBQztJQUVwQyxNQUFNO1FBQ1gsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUM7UUFDbEIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3RCLENBQUM7Q0FDRjtBQUVELE1BQU0sT0FBTyxZQUFZO0lBQ3ZCLFlBQ2tCLEdBQVcsRUFDWCxTQUE2QixFQUM3QixXQUFvQixFQUNwQixNQUFvQixFQUNwQixLQUF1QixFQUN2QixPQUFxQjs7Ozs7bUJBTHJCOzs7Ozs7bUJBQ0E7Ozs7OzttQkFDQTs7Ozs7O21CQUNBOzs7Ozs7bUJBQ0E7Ozs7OzttQkFDQTs7SUFDZixDQUFDO0lBRUcsbUJBQW1CO1FBQ3hCLE9BQU8sQ0FDTCxJQUFJLENBQUMsT0FB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