import * as ask from "./ast";
import { AlexaConversations } from "./ast";
import { typeError } from "./error";
import { getExpressionIfLocField, ValidationErrorFactory } from "./error-factory";
/**
 * Validates that the Dialog is deployable. A deployable dialog is one that accepts no arguments and returns `Nothing` or `Void`.
 */
export function evaluateDialogFlow(flow, state) {
    // TODO: validate that it does not accept arguments
    var _a, _b;
    return [
        evaluateFlow(flow, state).map((state) => state.errors),
        (_b = (_a = flow.expression.samples) === null || _a === void 0 ? void 0 : _a.map((sample) => validateSampleStartWithInvoke(flow.step(sample), state))) !== null && _b !== void 0 ? _b : [],
    ].flat(2);
}
/**
 * Validates that the data flow is correct.
 *
 * @param node
 * @param flow
 * @returns
 */
export function evaluateFlow(flow, state) {
    return flow.interpret(function evaluate(expr, nextState = state) {
        if (expr.isEnd()) {
            return evaluateEnd(expr, nextState.pushExpr(expr));
        }
        nextState = evaluateExpression(expr, nextState).pushExpr(expr);
        if (nextState.isCircular) {
            // detected a circular reference, stop execution.
            return nextState;
        }
        return (next) => evaluate(next, nextState);
    }, undefined);
}
export function evaluateExpression(expr, state) {
    if (expr.isExpect()) {
        return evaluateExpect(expr, state);
    }
    if (expr.isResponse()) {
        return evaluateResponse(expr, state);
    }
    if (expr.isConfirmAction()) {
        return evaluateConfirmAction(expr, state);
    }
    if (expr.isConfirmArgs()) {
        return evaluateConfirmArgs(expr, state);
    }
    if (expr.isEnsure()) {
        return evaluateEnsure(expr, state);
    }
    if (expr.isInvokeApi()) {
        return evaluateInvokeApi(expr, state);
    }
    if (expr.isConditionalBranch()) {
        return evaluateConditionalBranch(expr, state);
    }
    if (expr.isDialogExpansion()) {
        return evaluateDialogExpansion(expr, state);
    }
    return state;
}
/**
 * Called at the end of a single dialog flow. During evaluation, we often delay validation until
 * the end as an optimization. For example, checking if an argument is requested - if the ensure()
 * block is called later on in the dialog flow, we don't want to be searching forward all the time
 * because searching forward is slow. Instead, we track that in {@link EvaluationState} and then
 * peform the validation here. This reduces the time complexity significantly.
 */
export function evaluateEnd(endExpr, state) {
    return state.withError(...validateLastExpressionIsResponse(), ...evaluatePendingRequestPromptValidations());
    function isFlowExpressionResponseCall(flow) {
        var _a, _b, _c;
        return (_c = (((_a = flow === null || flow === void 0 ? void 0 : flow.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call" && ((_b = flow.checker.getApply(flow === null || flow === void 0 ? void 0 : flow.expression)) === null || _b === void 0 ? void 0 : _b.isResponse()))) !== null && _c !== void 0 ? _c : false;
    }
    // Validates the last expression in a sample is either a response call or a return value from a reusable
    // dialog that finishes with a response call.
    function validateLastExpressionIsResponse() {
        var _a, _b;
        // The last flow containing an expression in the dialog sample
        const lastFlow = endExpr.flow.prev;
        if (isFlowExpressionResponseCall(lastFlow)) {
            return [];
        }
        const isLastExprFromDialogCall = isFlowFromDialogCall(lastFlow);
        // Handle when a sample ends with a name reference and not a response call, in which case
        // we need to ensure the name reference is from a reusable dialog call that ends with response call/return value.
        if (((_a = lastFlow === null || lastFlow === void 0 ? void 0 : lastFlow.expression) === null || _a === void 0 ? void 0 : _a.kind) === "NameReference" && isLastExprFromDialogCall) {
            // The flow containing the second to last expression in the dialog sample
            let prevFlow = lastFlow === null || lastFlow === void 0 ? void 0 : lastFlow.prev;
            // Go up the flow stack until we hit the previous expression
            while (((_b = prevFlow === null || prevFlow === void 0 ? void 0 : prevFlow.expression) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                prevFlow = prevFlow === null || prevFlow === void 0 ? void 0 : prevFlow.prev;
            }
            if (isFlowExpressionResponseCall(prevFlow)) {
                return [];
            }
        }
        const errorFactory = isLastExprFromDialogCall
            ? ValidationErrorFactory.InvalidLastExpressionInSampleFromDialogCall
            : ValidationErrorFactory.InvalidLastExpressionInSample;
        return [errorFactory({ expr: lastFlow === null || lastFlow === void 0 ? void 0 : lastFlow.expression })];
    }
    /**
     * Under the right conditions produces one error message for each string in paths
     * @param expr API with error
     * @param argument argument that gave origin to the paths
     * @param paths paths where an error should be produced
     * @returns the errors for the paths
     */
    function getPendingRequestValidationError(expr, argument, paths) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
        if (expr.isInvokeApi()) {
            if (argument.argumentName !== undefined) {
                const argValue = (_a = expr.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue(argument);
                return paths.map((path) => {
                    var _a;
                    return ValidationErrorFactory.MissingRequestPromptForRequiredApiArgument({
                        expr: argValue,
                        attributes: { argumentName: path, actionName: (_a = expr.action) === null || _a === void 0 ? void 0 : _a.actionName },
                    });
                });
            }
            else {
                return [];
            }
        }
        else if (expr.isEnsure() || expr.isConfirmArgs()) {
            const errors = [];
            const requestArgs = expr.isEnsure() ? expr.requestArgs : expr.confirmArgs;
            if (requestArgs !== undefined) {
                const items = requestArgs.getItems();
                if (items !== undefined) {
                    for (let requestArgumentsIndex = 0; requestArgumentsIndex < items.length; requestArgumentsIndex++) {
                        const requestArg = items[requestArgumentsIndex];
                        const args = (_b = requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) === null || _b === void 0 ? void 0 : _b.getArgumentValueThing("arguments");
                        const argsNode = (_c = requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue("arguments");
                        if ((args === null || args === void 0 ? void 0 : args.isLiteral()) && args.isList()) {
                            const argsList = args.getItems();
                            if (argsList !== undefined) {
                                for (let argIndex = 0; argIndex < argsList.length; argIndex++) {
                                    const thisArg = argsList[argIndex];
                                    if (thisArg === argument) {
                                        const requestArgsNode = (_d = expr.apply) === null || _d === void 0 ? void 0 : _d.getArgumentValue(expr.isEnsure() ? "requestArgs" : "confirmArgs");
                                        let loc = expr.loc; // default to the entire `ensure` block
                                        loc = (_e = requestArgsNode === null || requestArgsNode === void 0 ? void 0 : requestArgsNode.loc) !== null && _e !== void 0 ? _e : loc;
                                        if ((requestArgsNode === null || requestArgsNode === void 0 ? void 0 : requestArgsNode.kind) === "Call" && ask.isListLiteral(requestArgsNode.arguments)) {
                                            // in-lined list, `ensure(RequestArguments { .. }, RequestArguments { .. }, ..)`
                                            const requestArgNode = requestArgsNode.arguments.items[requestArgumentsIndex].item;
                                            loc = (_f = requestArgNode === null || requestArgNode === void 0 ? void 0 : requestArgNode.loc) !== null && _f !== void 0 ? _f : loc;
                                            if ((requestArgNode === null || requestArgNode === void 0 ? void 0 : requestArgNode.kind) === "Call") {
                                                // this is the Requestarguments { .. } node, it is still inline so let's try and make the error even more granular
                                                loc = (_g = argsNode === null || argsNode === void 0 ? void 0 : argsNode.loc) !== null && _g !== void 0 ? _g : loc;
                                                if ((argsNode === null || argsNode === void 0 ? void 0 : argsNode.kind) === "Call" && ask.isListLiteral(argsNode.arguments)) {
                                                    loc = (_h = argsNode.arguments.items[argIndex].item) === null || _h === void 0 ? void 0 : _h.loc;
                                                }
                                            }
                                        }
                                        errors.push(...paths.map((path) => {
                                            const errorArgument = {
                                                expr: { loc: loc !== null && loc !== void 0 ? loc : expr.loc, uri: expr.uri },
                                                attributes: {
                                                    argumentName: path,
                                                },
                                            };
                                            return expr.isEnsure()
                                                ? ValidationErrorFactory.MissingRequestPromptForMultipleArguments(errorArgument)
                                                : ValidationErrorFactory.MissingRequestPromptForConfirmArgs(errorArgument);
                                        }));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return errors;
        }
        else {
            // do our best to resolve the location of the argument missing the request prompt
            let loc = (_k = (_j = expr.actNode) === null || _j === void 0 ? void 0 : _j.loc) !== null && _k !== void 0 ? _k : expr.loc;
            // options:
            // response(Request { arguments = [ Foo.arguments.arg ] })
            // response(Request { arguments = nameRef })
            // response(nameRef)
            if (((_l = expr.actNode) === null || _l === void 0 ? void 0 : _l.kind) === "Call") {
                const argsNode = (_o = (_m = expr.act) === null || _m === void 0 ? void 0 : _m.apply) === null || _o === void 0 ? void 0 : _o.getArgumentValue("arguments");
                const args = (_s = (_r = (_q = (_p = expr.act) === null || _p === void 0 ? void 0 : _p.apply) === null || _q === void 0 ? void 0 : _q.getArgumentValueThing("arguments")) === null || _r === void 0 ? void 0 : _r.asLiteralList()) === null || _s === void 0 ? void 0 : _s.getItems();
                if (args !== undefined && (argsNode === null || argsNode === void 0 ? void 0 : argsNode.kind) === "Call" && ask.isListLiteral(argsNode.arguments)) {
                    for (const [i, arg] of args.entries()) {
                        if ((arg === null || arg === void 0 ? void 0 : arg.isArgument()) && arg === argument) {
                            loc = (_u = (_t = argsNode.arguments) === null || _t === void 0 ? void 0 : _t.items) === null || _u === void 0 ? void 0 : _u[i].loc;
                            break;
                        }
                    }
                }
            }
            let errorExpr = getExpressionIfLocField(expr.actNode, expr);
            if ((_w = (_v = expr.act) === null || _v === void 0 ? void 0 : _v.apply) === null || _w === void 0 ? void 0 : _w.isConfirmArgsAct()) {
                return paths.map((path) => ValidationErrorFactory.MissingRequestPromptForConfirmArgs({
                    expr: errorExpr,
                    attributes: {
                        argumentName: path,
                    },
                }));
            }
            else if (((_y = (_x = expr.act) === null || _x === void 0 ? void 0 : _x.apply) === null || _y === void 0 ? void 0 : _y.isRequestArguments()) || ((_0 = (_z = expr.act) === null || _z === void 0 ? void 0 : _z.apply) === null || _0 === void 0 ? void 0 : _0.isRequestAct())) {
                return paths.map((path) => ValidationErrorFactory.MissingRequestPromptForMultipleArguments({
                    expr: errorExpr,
                    attributes: {
                        argumentName: path,
                    },
                }));
            }
            return [];
        }
    }
    function evaluatePendingRequestPromptValidations() {
        const returnValue = [];
        const pendingRequests = Array.from(state.pendingRequestPromptValidation.entries());
        for (const [api, argumentsMap] of pendingRequests) {
            const sortedArgumentsAndPaths = Array.from(argumentsMap.entries())
                .map((argumentAndSet) => ({ argument: argumentAndSet[0], paths: Array.from(argumentAndSet[1]) }))
                .sort((a, b) => a.argument.argumentName.localeCompare(b.argument.argumentName));
            for (const argumentAndPaths of sortedArgumentsAndPaths) {
                returnValue.push(...getPendingRequestValidationError(api, argumentAndPaths.argument, argumentAndPaths.paths));
            }
        }
        return returnValue;
    }
}
export function evaluateDialogExpansion(expr, state) {
    var _a, _b, _c;
    if (state.hasExpandedDialog(expr)) {
        const apply = expr.apply;
        for (const node of expr.flow.stack) {
            if (node.kind === "Call") {
                const prevApply = expr.flow.checker.getApply(node);
                if (apply.getName() === (prevApply === null || prevApply === void 0 ? void 0 : prevApply.getName())) {
                    const validationErrorExpr = getExpressionIfLocField((_a = apply.call) === null || _a === void 0 ? void 0 : _a.name, apply.call);
                    return state.withCircular(true).withError(apply.decl.kind === "DialogDeclaration"
                        ? ValidationErrorFactory.CircularReferenceDialog({
                            expr: validationErrorExpr,
                            attributes: {
                                dialogName: (_b = apply.decl.name) === null || _b === void 0 ? void 0 : _b.name,
                            },
                        })
                        : ValidationErrorFactory.CircularReferenceName({
                            expr: validationErrorExpr,
                            attributes: {
                                name: (_c = apply.decl.name) === null || _c === void 0 ? void 0 : _c.name,
                            },
                        }), ...collectCallStackErrors(expr.flow));
                }
            }
        }
    }
    return state;
}
function collectCallStackErrors(flow) {
    var _a, _b;
    if ((flow === null || flow === void 0 ? void 0 : flow.expression) === undefined) {
        return [];
    }
    if (flow.expression.kind === "Call") {
        const apply = flow.checker.getApply(flow.expression);
        if (apply === null || apply === void 0 ? void 0 : apply.isDialog()) {
            return [
                ValidationErrorFactory.CircularReferenceDialog({
                    expr: getExpressionIfLocField((_a = apply.call) === null || _a === void 0 ? void 0 : _a.name, apply.call),
                    attributes: {
                        dialogName: (_b = apply.decl.name) === null || _b === void 0 ? void 0 : _b.name,
                    },
                }),
                ...flow.visitPrevious(collectCallStackErrors),
            ];
        }
    }
    return flow.visitPrevious(collectCallStackErrors);
}
/**
 * Validate the prior lines to expect.
 *
 * 1. `Invoke` must be first event or follow response with `Request`, `Notify`, `Offer`, `ReqMore`, or `ReqAlt` Acts. TODO: we must verify if it is valid to follow `Request` - our tests used this case but it is documented as invalid.
 * 2. `Affirm` or `Deny` must follow response with `ConfirmArgs`, `ConfirmAction`, `Offer` Acts or `confirmAction`.
 * 3. `Inform` must follow response with `Request` or `ReqAlt` Acts.
 *
 * @param expect expect being evaluated
 * @param expectActType expect's actType
 * @param expectActValue expect's act argument value from expect.apply?.getArgumentValue("act")
 * @param stateExpressionStack expression stack from the state
 * @returns errors from lines prior tp expect
 */
function validateEventPriorToExpect(expect, expectActType, expectActValue, stateExpressionStack) {
    var _a, _b;
    for (const expr of stateExpressionStack) {
        if (expr.isInvokeApi() || expr.isExpect()) {
            const errorArguments = {
                expr: expectActValue,
                attributes: {
                    requestAct: expectActType.toString(expectActValue),
                },
            };
            if (expectActType.isInvoke()) {
                // TODO: verify if Invoke can follow 'Request' act.
                return [ValidationErrorFactory.InvalidEventInvoke(errorArguments)];
            }
            if (expectActType.isAffirm() || expectActType.isDeny()) {
                return [ValidationErrorFactory.InvalidEventAffirmOrDeny(errorArguments)];
            }
            if (expectActType.isInform()) {
                return [ValidationErrorFactory.InvalidEventInform(errorArguments)];
            }
            // catch all, we should never reach here since we first validate that actType is Invoke, Inform, Affirm or Deny
            return [ValidationErrorFactory.InvalidEvent(errorArguments)];
        }
        if (expr.isEnsure() || expr.isDialogExpansion() || expr.isConfirmArgs() || expr.isBlock() || expr.isConditionalBranch()) {
            // ignore these calls since they do not affect the user/alexa lines.
            // TODO: why ignore ConfirmArgs?
            // return [];
        }
        else if (expr.isConfirmAction()) {
            if (expectActType.isAffirm() || expectActType.isDeny()) {
                return [];
            }
            return [
                ValidationErrorFactory.InvalidEventFollowingConfirmAction({
                    expr: expectActValue,
                    attributes: {
                        requestAct: expectActType.toString(expect.node),
                    },
                }),
            ];
        }
        else if (expr.isResponse()) {
            const nextRequestActType = (_a = expr.nextAct) === null || _a === void 0 ? void 0 : _a.type;
            let requestActType = (_b = expr.act) === null || _b === void 0 ? void 0 : _b.type;
            if (nextRequestActType && !(nextRequestActType.isNothing() || nextRequestActType.isVoid())) {
                requestActType = nextRequestActType;
            }
            if (requestActType === undefined) {
                // could not resolve the request act, so ignore these validations
                return [];
            }
            if (requestActType.isOffer()) {
                // all dialog acts can follow Offer
                return [];
            }
            if (requestActType.isConfirmArgs() || requestActType.isConfirmAction()) {
                if (expectActType.isAffirm() || expectActType.isDeny()) {
                    return [];
                }
                return [invalidEventError("Affirm", "Deny")];
            }
            if (requestActType.isNotify() || requestActType.isReqMore() || requestActType.isBye()) {
                if (expectActType.isInvoke()) {
                    return [];
                }
                return [invalidEventError("Invoke")];
            }
            if (requestActType.isReqAlt()) {
                if (expectActType.isInvoke() || expectActType.isInform()) {
                    return [];
                }
                return [invalidEventError("Invoke", "Inform")];
            }
            if (requestActType.isRequest()) {
                if (expectActType.isInform()) {
                    return [];
                }
                return [invalidEventError("Inform")];
            }
            function invalidEventError(...expected) {
                const suggestions = expected.length === 1
                    ? `'${expected[0]}'`
                    : `${expected
                        .slice(0, expected.length - 1)
                        .map((e) => `'${e}'`)
                        .join(", ")} or '${expected[expected.length - 1]}'`;
                return ValidationErrorFactory.InvalidEventResponse({
                    expr: getExpressionIfLocField(expectActValue, expect),
                    attributes: {
                        responseAct: expectActType.toString(expect.node),
                        requestAct: requestActType === null || requestActType === void 0 ? void 0 : requestActType.toString(expect.node),
                        suggestions,
                    },
                });
            }
        }
    }
    if (expectActType.isInvoke()) {
        return [];
    }
    return [
        ValidationErrorFactory.InvalidFirstEvent({
            expr: expectActValue,
            attributes: {
                dialogAct: expectActType.toString(expect.node),
            },
        }),
    ];
}
/**
 * Called to peerform Inform validations if the expect's act is inform
 * @param expect expect being evaluated
 * @returns errors for expect with Inform act
 */
function validateExpectInform(expect) {
    var _a, _b, _c;
    const errors = [];
    // Each sample sentence in "inform" event should contain at least one slot.
    const eventValue = (_a = expect.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("event");
    if (!expect.checker.isNameReference(eventValue)) {
        // this case should already be caught by other validation
        return errors;
    }
    const nameDecl = expect.checker.resolveNameReference(eventValue);
    if (ask.isCall(nameDecl)) {
        const apply = expect.checker.getApply(nameDecl);
        if ((apply === null || apply === void 0 ? void 0 : apply.getName()) === AlexaConversations.utterances) {
            let items = [];
            const value = apply.getArgumentValue("samples");
            if (expect.checker.isNameReference(value)) {
                const found = expect.checker.resolveNameReference(value);
                const foundType = expect.checker.getType(value);
                if (ask.isCall(found) && ask.isListLiteral(found.arguments) && (foundType === null || foundType === void 0 ? void 0 : foundType.isList())) {
                    items = found.arguments.items;
                }
            }
            else if ((value === null || value === void 0 ? void 0 : value.kind) === "Call" && ask.isListLiteral(value.arguments)) {
                items = value.arguments.items;
            }
            for (const item of items) {
                if (item.item === undefined || item.item.kind !== "Call") {
                    // do nothing, because this case should already be caught by other validation
                }
                else if (typeof item.item.arguments === "string" ||
                    (ask.isUtterance(item.item.arguments) && ((_b = item.item.arguments.names) === null || _b === void 0 ? void 0 : _b.length) === 0)) {
                    errors.push(ValidationErrorFactory.InformUtteranceSampleMissingSlot({
                        expr: getExpressionIfLocField((_c = expect.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue("event"), expect),
                    }));
                    // only report this error once
                    break;
                }
            }
        }
    }
    return errors;
}
export const evaluateExpect = (expect, state) => {
    var _a, _b, _c, _d, _e, _f;
    // for expect action, the RequestAct could only be Invoke, Inform, Affirm or Deny
    const value = (_a = expect.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("act");
    const actType = expect.getActType();
    if (actType === undefined) {
        // don't do anything when type is undefined as it should be caught by another validator
        return state;
    }
    if (!expect.isInvoke() && !expect.isInform() && !expect.isAffirm() && !expect.isDeny()) {
        return state.withError(ValidationErrorFactory.InvalidRequestAct({
            expr: value,
            attributes: { actName: actType === null || actType === void 0 ? void 0 : actType.toString(value) },
        }));
    }
    if ((actType.isAffirm() || actType.isDeny()) && ((_c = (_b = expect.event) === null || _b === void 0 ? void 0 : _b.apply) === null || _c === void 0 ? void 0 : _c.isUtterances())) {
        const utteranceType = (_f = (_e = (_d = expect.event) === null || _d === void 0 ? void 0 : _d.apply) === null || _e === void 0 ? void 0 : _e.getReturnType()) === null || _f === void 0 ? void 0 : _f.getUtteranceEventType();
        if (!(utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.isNothing()) && !(utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.isThing())) {
            return state.withError(ValidationErrorFactory.ExpectedEmptyRequestActType({
                expr: value,
                attributes: { typeName: utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.shortName, actType: actType === null || actType === void 0 ? void 0 : actType.toString(value) },
            }));
        }
        if (actType.isDeny()) {
            // resets pending offer if action is not affirmed
            state = state.clearPendingOffer();
        }
    }
    if (actType.isInform()) {
        return state.withError(...validateEventPriorToExpect(expect, actType, value, state.expressionStack), ...validateExpectInform(expect));
    }
    return state.withError(...validateEventPriorToExpect(expect, actType, value, state.expressionStack));
};
/**
 * Validate Response action used in dialog sample
 * including specific validations to the four args (Response, ResponseAct, next ResponseAct, Payload)
 * and make sure those args are used in allowed combination
 */
export const evaluateResponse = (response, state) => validateResponseAct(response, state.withRequestedArguments(false, ...response.getIndividuallyRequestedArguments())).withError(
// 2. validations for the nextAct
...validateNextAct(response, state), 
// 3. validations for the payload
...validatePayload(response, state), 
// 4. validations for the prompt
...validatePrompt(response.apply), ...validatePriorResponseCall(response));
/**
 * Validate the act used in response action
 * 1. The act could only be one of valid ResponseAct: 'Request', 'ConfirmArgs', 'ConfirmAction', 'Notify', 'Offer', 'ReqAlt', 'Bye', 'ReqMore'
 * 2. ReqAlt cannot be the first act
 * 3. for ConfirmArgs, make sure the items in the "arguments" list should be from the same Action
 * 4. for ConfirmArgs, make sure the payload property exist in argument list
 */
export const validateResponseAct = (response, state) => {
    var _a, _b;
    const { act } = response;
    const actNode = response.apply.getArgumentValue("act");
    if (act === undefined || !act.isLiteral()) {
        // don't do anything when actType is undefined as it should be caught by another validator
        return state;
    }
    // 1. The act could only be one of valid ResponseAct
    if (!act.type.isResponseAct()) {
        state = state.withError(ValidationErrorFactory.InvalidDialogActArgument({
            expr: actNode,
            attributes: {
                dialogAct: act.type.toString(actNode),
            },
        }));
    }
    if (act.type.isConfirmAction()) {
        state = evaluateConfirmAction(response, state);
    }
    // 2. ReqAlt cannot be the first act
    if (act.type.isReqAlt()) {
        state = state.withError(ValidationErrorFactory.InvalidReqAltFirstAct({
            expr: actNode,
        }));
    }
    // 3. for ConfirmArgs, make sure the items in the "arguments" list should be from the same Action
    if (act.isObject() && act.type.isConfirmArgs()) {
        const preErrorCount = state.errors.length;
        state = validateConfirmArgsAct(response, state);
        // 4. for ConfirmArgs, make sure the payload property exist in argument list
        if (preErrorCount === state.errors.length) {
            if (act.isObject()) {
                const args = act.getProperty("arguments");
                const nameSet = new Set();
                if ((args === null || args === void 0 ? void 0 : args.isList()) && args.isLiteral()) {
                    args.apply.call.arguments.items.forEach((item) => {
                        var _a, _b, _c, _d, _e;
                        if (response.checker.isNameReference(item.item)) {
                            const nameDecl = response.checker.resolveNameReference(item.item);
                            if ((nameDecl === null || nameDecl === void 0 ? void 0 : nameDecl.kind) !== undefined && nameDecl.kind === "PropertyReference" && ((_a = nameDecl.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined) {
                                nameSet.add(nameDecl.name.name);
                            }
                        }
                        else if (((_b = item.item) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                            if (((_d = (_c = item.item) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name) !== undefined) {
                                nameSet.add((_e = item.item) === null || _e === void 0 ? void 0 : _e.name.name);
                            }
                        }
                    });
                }
                const payloadValue = response.apply.getPayloadValue();
                if ((payloadValue === null || payloadValue === void 0 ? void 0 : payloadValue.kind) === "Call") {
                    const payloadApply = response.checker.getApply(payloadValue);
                    if (payloadApply !== undefined && payloadApply.call.arguments !== undefined && Array.isArray(payloadApply.call.arguments)) {
                        for (const args of payloadApply.call.arguments) {
                            const name = typeof args.name === "string" ? args.name : (_a = args.name) === null || _a === void 0 ? void 0 : _a.name;
                            if (name !== undefined) {
                                if (!nameSet.has(name)) {
                                    state = state.withError(ValidationErrorFactory.MismatchedConfirmArgsPayloadProperty({
                                        expr: payloadValue,
                                        attributes: {
                                            propertyName: name,
                                        },
                                    }));
                                }
                                else {
                                    nameSet.delete(name);
                                }
                            }
                        }
                        if (nameSet.size > 0) {
                            for (const name of nameSet) {
                                state = state.withError(ValidationErrorFactory.MissingConfirmedArgsInPayload({
                                    expr: payloadValue,
                                    attributes: {
                                        argumentName: name,
                                    },
                                }));
                            }
                        }
                    }
                }
            }
        }
    }
    // 4. OfferAct arguments should belong to the Offered actionName
    if (act.isObject() && act.type.isOffer()) {
        const offerActionName = act.getProperty("actionName");
        const offerArguments = act.getProperty("arguments");
        const offerArgumentsNode = act.apply.getArgumentValue("arguments");
        if (offerArguments === undefined || offerActionName === undefined || !offerActionName.isAction()) {
            if (offerActionName) {
                return addPendingOfferIfAction(act, state);
            }
            return state; // should not happen as actionName for Offer act is required
        }
        // return errors; // should not happen as the arguments for Offer act must be a List Call
        if (offerArguments.isList() && offerArguments.isLiteral()) {
            offerArguments.apply.call.arguments.items.forEach((arg, i) => {
                var _a, _b, _c, _d, _e;
                const argItem = response.checker.isNameReference(arg.item)
                    ? response.checker.resolveNameReference(arg.item)
                    : arg.item;
                if (!ask.isPropRef(argItem)) {
                    return; // TODO: check if "Call" can be assigned to argument(s)
                }
                // determine the precise location for this error
                let expr = response;
                if ((actNode === null || actNode === void 0 ? void 0 : actNode.kind) === "Call") {
                    expr = getExpressionIfLocField(actNode, expr);
                    if ((offerArgumentsNode === null || offerArgumentsNode === void 0 ? void 0 : offerArgumentsNode.kind) === "Call") {
                        expr = getExpressionIfLocField(offerArgumentsNode, expr);
                        if (ask.isListLiteral(offerArgumentsNode.arguments)) {
                            expr = getExpressionIfLocField((_b = (_a = offerArgumentsNode.arguments) === null || _a === void 0 ? void 0 : _a.items[i]) === null || _b === void 0 ? void 0 : _b.item, expr);
                        }
                    }
                }
                const argValueStr = argItem.printPropertyChainThroughRoot();
                const argThing = response.checker.getThing(arg);
                if (((_d = (_c = argThing === null || argThing === void 0 ? void 0 : argThing.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.isAction()) && !argThing.parent.parent.equals(offerActionName)) {
                    state = state.withError(ValidationErrorFactory.MismatchedActionArgumentsListValue({
                        expr,
                        attributes: {
                            argumentValue: argValueStr,
                            actionName: (_e = offerActionName.origin.name) === null || _e === void 0 ? void 0 : _e.name,
                        },
                    }));
                }
            });
        }
        // Offer.carryOverArguments
        const offerCarryoverArguments = act.getProperty("carryOverArguments");
        const offerCarryoverArgumentsNode = act.apply.getArgumentValue("carryOverArguments");
        if (offerCarryoverArguments === undefined || !offerCarryoverArguments.isList() || !offerCarryoverArguments.isLiteral()) {
            return state; // should not happen as the arguments for Offer act must be a List Call
        }
        (_b = offerCarryoverArguments.getItems()) === null || _b === void 0 ? void 0 : _b.forEach((carryOverArgument, i) => {
            var _a, _b, _c, _d, _e, _f;
            if ((carryOverArgument === null || carryOverArgument === void 0 ? void 0 : carryOverArgument.isObject()) && carryOverArgument.isLiteral()) {
                const arg = carryOverArgument.getProperty("argument");
                if ((arg === null || arg === void 0 ? void 0 : arg.type.isArgument()) && ((_b = (_a = arg.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.isAction())) {
                    if (!arg.parent.parent.equals(offerActionName)) {
                        const carryOverValueStr = ask.isPropRef((_c = arg.origin) === null || _c === void 0 ? void 0 : _c.context) ? arg.origin.context.printPropertyChainThroughRoot() : "todo";
                        // determine the most precise location for the argument's error.
                        // TODO: this is gross, refactor it
                        let expr = response;
                        if ((actNode === null || actNode === void 0 ? void 0 : actNode.kind) === "Call") {
                            expr = getExpressionIfLocField(actNode, expr);
                            if ((offerCarryoverArgumentsNode === null || offerCarryoverArgumentsNode === void 0 ? void 0 : offerCarryoverArgumentsNode.kind) === "Call") {
                                expr = getExpressionIfLocField(offerCarryoverArgumentsNode, expr);
                                if (ask.isListLiteral(offerCarryoverArgumentsNode.arguments)) {
                                    const carryOverArgNode = (_e = (_d = offerCarryoverArgumentsNode.arguments) === null || _d === void 0 ? void 0 : _d.items[i]) === null || _e === void 0 ? void 0 : _e.item;
                                    if (carryOverArgNode !== undefined) {
                                        expr = getExpressionIfLocField(carryOverArgNode, expr);
                                        if (carryOverArgNode.kind === "Call") {
                                            expr = getExpressionIfLocField(carryOverArgument.apply.getArgumentValue("argument"), expr);
                                        }
                                    }
                                }
                            }
                        }
                        state = state.withError(ValidationErrorFactory.MismatchedActionCarryOverArguments({
                            expr,
                            attributes: {
                                carryOverValue: carryOverValueStr,
                                actionName: (_f = offerActionName.origin.name) === null || _f === void 0 ? void 0 : _f.name,
                            },
                        }));
                    }
                }
            }
        });
        return state;
    }
    // 5. validate ConfirmAction Act
    // if (act.type.isConfirmAction()) {
    //   errors.push(...validateConfirmAction(apply, checker));
    // }
    // 6. validate Request Act
    if (act.type.isRequest()) {
        const args = act.getProperty("arguments");
        if ((args === null || args === void 0 ? void 0 : args.isList()) && args.isLiteral()) {
            state = state.withError(...validateArgumentList(act.apply.getArgumentValue("arguments"), act.getProperty("arguments")));
        }
        // If the argList contains multiple args, make sure each arg has request prompt
        state = validateRequestPromptInArgsList(response, act, state);
    }
    // 7. For Notify Act, it can only use the last API action name and an API call can only be notified once
    if (act.type.isNotify() && act.isObject() && act.isLiteral()) {
        // const actValueApply = act.apply;
        const actionDecl = act.getProperty("actionName");
        if (actionDecl === null || actionDecl === void 0 ? void 0 : actionDecl.isAction()) {
            const validateNotify = (expr) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j;
                if (expr === undefined) {
                    return [
                        ValidationErrorFactory.InvalidNotifyActionNameUnusedAction({
                            expr: response,
                            attributes: {
                                actionName: (_a = actionDecl.name) === null || _a === void 0 ? void 0 : _a.name,
                            },
                        }),
                    ];
                }
                if (expr.isInvokeApi()) {
                    const actionName = (_b = expr.action) === null || _b === void 0 ? void 0 : _b.actionName;
                    if (actionName && actionName !== ((_c = actionDecl.name) === null || _c === void 0 ? void 0 : _c.name)) {
                        return [
                            ValidationErrorFactory.InvalidNotifyActionNameLastAction({
                                expr: getExpressionIfLocField((actNode === null || actNode === void 0 ? void 0 : actNode.kind) === "Call" ? (_e = (_d = response.apply.getArgumentValueThing("act")) === null || _d === void 0 ? void 0 : _d.apply) === null || _e === void 0 ? void 0 : _e.getArgumentValue("actionName") : actNode, response),
                                attributes: {
                                    currentActionName: (_f = actionDecl.name) === null || _f === void 0 ? void 0 : _f.name,
                                    previousActionName: actionName,
                                },
                            }),
                        ];
                    }
                    return [];
                }
                if (expr.isResponse()) {
                    const actionName = (_g = actionDecl.name) === null || _g === void 0 ? void 0 : _g.name;
                    const { act } = expr;
                    if ((act === null || act === void 0 ? void 0 : act.type.isNotify()) && act.isObject() && act.isLiteral()) {
                        const actionNameProp = act.getProperty("actionName");
                        if ((actionNameProp === null || actionNameProp === void 0 ? void 0 : actionNameProp.isAction()) && actionName === ((_h = actionNameProp.origin.name) === null || _h === void 0 ? void 0 : _h.name)) {
                            return [
                                ValidationErrorFactory.InvalidNotifyActionNameAlreadyNotified({
                                    expr: response,
                                    attributes: {
                                        actionName: (_j = actionDecl.name) === null || _j === void 0 ? void 0 : _j.name,
                                    },
                                }),
                            ];
                        }
                    }
                }
                return validateNotify(expr.prev);
            };
            state = addPendingOfferIfAction(response.nextAct, state.withError(...validateNotify(response.prev)));
        }
    }
    return state;
};
/**
 * Modifies pending offer state if actionName is provided in Offer
 */
export const addPendingOfferIfAction = (act, state) => {
    var _a, _b, _c, _d;
    if (act === null || act === void 0 ? void 0 : act.type.isOffer()) {
        const action = (_a = act.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValueThing("actionName");
        if (((_b = action === null || action === void 0 ? void 0 : action.origin) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" && ((_d = (_c = action === null || action === void 0 ? void 0 : action.origin) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name)) {
            return state.withPendingOffer(action.origin.name.name);
        }
    }
    return state;
};
/**
 * Validate nextAct used in response action
 * 1. next Act could only be Offer, ReqMore, ReqAlt, or Bye.
 * 2. nextAct could only follow Notify act
 * 3. the ReqAlt act can only be the next Act to a Notify Act with "success = false"
 * 4. for ReqAlt, the items in the "arguments" list should be from the same Action
 * 5. for ReqAlt, actionName used in Notify and ReqAlt argument list should be consistent
 */
export const validateNextAct = (response, state) => {
    var _a, _b, _c, _d, _e, _f;
    const errors = [];
    const { act } = response;
    const actArg = response.apply.getArgumentValue("act");
    const actionName = act === null || act === void 0 ? void 0 : act.getProperty("actionName");
    const actType = act === null || act === void 0 ? void 0 : act.type;
    if (actArg === undefined || act === undefined || actType === undefined || !act.isLiteral()) {
        // don't do anything when actType is undefined as it should be caught by another validator
        return [];
    }
    const { nextAct } = response;
    const nextActArg = response.apply.getArgument("nextAct");
    const nextActType = nextAct === null || nextAct === void 0 ? void 0 : nextAct.type;
    if (nextActArg === undefined || nextAct === undefined || nextActType === undefined || nextActType.isNothing() || nextActType.isVoid()) {
        // don't do anything when type is undefined as it is an optional argument
    }
    else if (!nextActType.isOffer() && !nextActType.isBye() && !nextActType.isReqAlt() && !nextActType.isReqMore()) {
        // 1. next Act could only be Offer, ReqMore, ReqAlt, or Bye.
        errors.push(ValidationErrorFactory.InvalidNextAct({
            expr: nextActArg,
            attributes: {
                responseAct: nextActType.toString(nextActArg),
            },
        }));
    }
    else {
        // 2. nextAct could only follow Notify act
        if (!actType.isNotify()) {
            errors.push(ValidationErrorFactory.InvalidNextActNotify({
                expr: actArg,
                attributes: {
                    responseAct: actType.toString(actArg),
                },
            }));
        }
        else {
            // validations for ReqAlt act
            if (nextAct.type.isReqAlt()) {
                const successValue = act.getProperty("success");
                if (successValue === undefined || !successValue.isBoolean()) {
                    // should be caught by other validation
                    return errors;
                }
                if (successValue.literal === true) {
                    // 3. The ReqAlt act can only be the next Act to a Notify Act with "success = false"
                    errors.push(ValidationErrorFactory.InvalidReqAltNextAct({
                        expr: nextActArg,
                    }));
                }
                if (nextAct.isObject() && nextAct.isLiteral()) {
                    const reqAlt = nextAct.getProperty("arguments");
                    const reqAltNode = nextAct.apply.getArgumentValue("arguments");
                    if ((reqAlt === null || reqAlt === void 0 ? void 0 : reqAlt.isList()) && reqAlt.isLiteral()) {
                        const argumentListErrors = validateArgumentList(reqAltNode, reqAlt);
                        if (argumentListErrors.length > 0) {
                            errors.push(...argumentListErrors);
                        }
                        else {
                            // 5. actionName used in Notify and ReqAlt argument list should be consistent
                            // could rely on the first item to retrieve rootExpr cause we already checked the items in the list are from the same Action
                            const item = reqAlt.getItem(0);
                            if (((_b = (_a = item === null || item === void 0 ? void 0 : item.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.isAction()) && (actionName === null || actionName === void 0 ? void 0 : actionName.isAction())) {
                                if (((_c = item.parent.parent.origin.name) === null || _c === void 0 ? void 0 : _c.name) !== ((_d = actionName.origin.name) === null || _d === void 0 ? void 0 : _d.name)) {
                                    errors.push(ValidationErrorFactory.MismatchedArgsInReqAlt({
                                        expr: reqAltNode,
                                        attributes: {
                                            reqAltActionName: (_e = item.parent.parent.origin.name) === null || _e === void 0 ? void 0 : _e.name,
                                            notifyActionName: (_f = actionName.origin.name) === null || _f === void 0 ? void 0 : _f.name,
                                        },
                                    }));
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return errors;
};
/**
 * Validate confirmAction action used in dialog sample
 */
export const evaluateConfirmAction = (confirm, state) => {
    var _a, _b, _c, _d, _e;
    let action;
    // location of the ConfirmAction act on which we will attach errors.
    let errorExpr;
    // let actionNameLoc: ask.SourceLocation | undefined;
    if (confirm.isResponse()) {
        if (!((_a = confirm.act) === null || _a === void 0 ? void 0 : _a.type.isConfirmAction())) {
            // why?
            return state;
        }
        const actionName = confirm.act.getProperty("actionName");
        if (actionName === null || actionName === void 0 ? void 0 : actionName.isAction()) {
            action = actionName;
            errorExpr =
                ((_b = confirm.actNode) === null || _b === void 0 ? void 0 : _b.kind) === "Call"
                    ? getExpressionIfLocField((_c = confirm.act.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue("actionName"), confirm.actNode, confirm)
                    : getExpressionIfLocField(confirm.actNode, confirm);
        }
        else {
            return state;
        }
    }
    else if (confirm.isConfirmAction()) {
        action = confirm.actionName;
        errorExpr = getExpressionIfLocField((_d = confirm.actionNameNode) === null || _d === void 0 ? void 0 : _d.value, confirm);
    }
    const confirmedPayload = confirm.payload;
    if (action === undefined) {
        return state;
    }
    if (!action.isAction()) {
        return state;
    }
    const actionName = (_e = action.origin.name) === null || _e === void 0 ? void 0 : _e.name;
    return state.withError(...[
        validatePayload(confirm, state),
        confirm.flow.interpret((expr) => interpret(expr, state), confirm).map((state) => state.errors),
    ].flat(2));
    function interpret(expr, state, foundEvent = false) {
        var _a;
        const errorArguments = {
            expr: errorExpr,
            attributes: {
                actionName,
            },
        };
        const missingApiInvocationError = ValidationErrorFactory.MissingApiInvocationAfterConfirmAction(errorArguments);
        const missingAffirmOrDenyError = ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmAction(errorArguments);
        if (expr.isEnd()) {
            return state.withError(missingApiInvocationError);
        }
        if (expr.isInvokeApi()) {
            if ((_a = expr.action) === null || _a === void 0 ? void 0 : _a.equals(action)) {
                if (!foundEvent) {
                    return state.withError(missingAffirmOrDenyError);
                }
                if (confirmedPayload) {
                    return validateConfirmPayload(state, confirm, expr);
                }
                return state;
            }
        }
        else if (expr.isResponse() || expr.isConfirmAction()) {
            return foundEvent ? state.withError(missingApiInvocationError) : state.withError(missingAffirmOrDenyError, missingApiInvocationError);
        }
        else if (expr.isExpect()) {
            const type = expr.getActType();
            if (type !== undefined) {
                if (type.isAffirm() || (type === null || type === void 0 ? void 0 : type.isDeny())) {
                    if (type.isDeny()) {
                        // it's ok for an api call to not proceed a deny.
                        return state;
                    }
                    return (next) => interpret(next, state.pushExpr(expr), true);
                }
                return state.withError(missingAffirmOrDenyError);
            }
        }
        return (next) => interpret(next, state.pushExpr(expr), foundEvent);
    }
};
/**
 * Validate confirmArgs action used in dialog sample
 * traverse the confirmArgs list and do the following validations
 * 1. Make sure each response contain APL-A
 * 2. Make sure all arguments in the argument list refer to the same action
 * 3. Make sure all arguments in the argument list has request prompt
 */
export const evaluateConfirmArgs = (confirm, state) => {
    var _a, _b;
    if (confirm.node === undefined) {
        return state;
    }
    const errors = [];
    // const confirmArgs = act.getArgumentValueThing("confirmArgs");
    if (((_a = confirm.confirmArgs) === null || _a === void 0 ? void 0 : _a.isList()) && confirm.confirmArgs.isLiteral()) {
        if (confirm.isResponse())
            errors.push(...validateConfirmArgsFlow(confirm, state));
        for (const arg of (_b = confirm.confirmArgs.getItems()) !== null && _b !== void 0 ? _b : []) {
            if ((arg === null || arg === void 0 ? void 0 : arg.type.isConfirmArguments()) && arg.isObject() && arg.isLiteral()) {
                errors.push(...validatePrompt(arg.apply));
                const confirmedArgs = arg.getProperty("arguments");
                const confirmedArgsNode = arg.apply.getArgumentValue("arguments");
                if ((confirmedArgs === null || confirmedArgs === void 0 ? void 0 : confirmedArgs.isList()) && (confirmedArgs === null || confirmedArgs === void 0 ? void 0 : confirmedArgs.isLiteral())) {
                    // the items in the "arguments" list should be from the same Action
                    errors.push(...validateArgumentList(confirmedArgsNode, confirmedArgs));
                    // Make sure all arguments in the argument list has request prompt
                    state = validateRequestPromptInArgsList(confirm, arg, state);
                }
            }
        }
    }
    return state.withError(...errors);
};
/**
 * Validate the ConfirmArgs act used in response action
 * 1. make sure the items in the "arguments" list should be from the same Action
 * 2. make sure all arguments in the argument list has request prompt
 * 3. make sure there exist Affirm or Deny event after ConfirmArgs Act
 * 4. make sure the next api call is consistent with the action whose arguments are been confirmed
 * @param response
 * @param confirmArgsAct
 * @param branch
 */
export const validateConfirmArgsAct = (confirm, state) => {
    var _a, _b;
    const errors = [];
    const args = (_a = confirm.act) === null || _a === void 0 ? void 0 : _a.getProperty("arguments");
    const argsNode = (_b = confirm.apply) === null || _b === void 0 ? void 0 : _b.getArgumentValue("act");
    if ((args === null || args === void 0 ? void 0 : args.isList()) && args.isLiteral()) {
        const argumentListErrors = validateArgumentList(argsNode, args);
        errors.push(...argumentListErrors);
        // when all arguments in the list are from the same action
        // make sure the next api call is consistent with the action whose arguments are been confirmed
        if (argumentListErrors.length === 0) {
            errors.push(...validateConfirmArgsFlow(confirm, state));
        }
        // Make sure all arguments in the argument list has request prompt
        state = validateRequestPromptInArgsList(confirm, confirm.act, state);
    }
    return state.withError(...errors);
};
/**
 * The next api call after Confirm Args dialog act must be consistent with the action which is been confirmed.
 */
export const validateConfirmArgsFlow = (confirm, state) => {
    var _a, _b, _c;
    let actionDeclaration = undefined;
    const args = (_a = confirm.act) === null || _a === void 0 ? void 0 : _a.getProperty("arguments");
    if (args === null || args === void 0 ? void 0 : args.isList()) {
        for (const arg of (_b = args.getItems()) !== null && _b !== void 0 ? _b : []) {
            const argItem = arg === null || arg === void 0 ? void 0 : arg.asArgument();
            if (!argItem) {
                continue;
            }
            actionDeclaration = argItem.getReferencedActionArgumentActionDeclaration();
            if (actionDeclaration) {
                break;
            }
        }
    }
    else if (args === null || args === void 0 ? void 0 : args.isUnion()) {
        // TODO: validate each variation of the arguments.
        // return state;
        throw new Error("should be impossible.");
    }
    if (actionDeclaration === undefined) {
        return [];
    }
    const actionName = (_c = actionDeclaration.name) === null || _c === void 0 ? void 0 : _c.name;
    const errorExpr = getExpressionIfLocField(confirm.apply.getArgumentValue("act"), confirm);
    return confirm.flow
        .interpret((expr) => visit(expr, state), confirm)
        .map((state) => state.errors)
        .flat();
    function visit(expr, state, affirmed = false) {
        var _a;
        const { flow } = expr;
        const missingEventAfterConfirmArgsError = ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgs({
            expr: errorExpr,
            attributes: {
                actionName,
            },
        });
        if (expr.isEnd()) {
            const missingApiError = ValidationErrorFactory.MissingApiInvocationAfterConfirmArgs({
                expr: errorExpr,
                attributes: {
                    actionName,
                },
            });
            return affirmed ? state.withError(missingApiError) : state.withError(missingEventAfterConfirmArgsError, missingApiError);
        }
        if (expr.isAction()) {
            if (expr === null || expr === void 0 ? void 0 : expr.isInvokeApi()) {
                if (!affirmed) {
                    return state.withError(missingEventAfterConfirmArgsError, ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgsBeforeCall({
                        expr,
                        attributes: {
                            calledActionName: (_a = expr.action) === null || _a === void 0 ? void 0 : _a.actionName,
                            confirmedActionName: actionName,
                        },
                    }));
                }
                if (confirm.payload) {
                    return validateConfirmPayload(state, confirm, expr);
                }
                return state;
            }
            if (expr.isExpect() && !affirmed) {
                const actType = expr.getActType();
                if ((actType === null || actType === void 0 ? void 0 : actType.isAffirm()) || (actType === null || actType === void 0 ? void 0 : actType.isDeny())) {
                    if (actType.isDeny()) {
                        return state;
                    }
                    return (next) => visit(next, state.pushExpr(expr), true);
                }
                if (actType) {
                    return state.withError(missingEventAfterConfirmArgsError, ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgsBeforeExpect({
                        expr,
                        attributes: {
                            actionName,
                            requestAct: actType.toString(flow.expression),
                        },
                    }));
                }
            }
            else if (!affirmed && ((expr === null || expr === void 0 ? void 0 : expr.isResponse()) || (expr === null || expr === void 0 ? void 0 : expr.isConfirmAction()))) {
                return state.withError(ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgs({
                    expr: confirm,
                    attributes: {
                        actionName,
                    },
                }));
            }
        }
        return (next) => visit(next, state.pushExpr(expr), affirmed);
    }
};
/**
 * Validate the arguments to an API match the payload in a previous ConfirmArgs or ConfirmAction act.
 */
function validateConfirmPayload(state, confirm, api) {
    var _a;
    const confirmedPayload = confirm.isResponse() || confirm.isConfirmAction() ? confirm.payload : undefined;
    const errors = Object.entries((_a = api.arguments) !== null && _a !== void 0 ? _a : {})
        .map(([name, arg]) => {
        var _a, _b, _c, _d;
        const actualArg = confirmedPayload === null || confirmedPayload === void 0 ? void 0 : confirmedPayload.getProperty(name);
        if (actualArg === undefined || actualArg.equals(arg)) {
            return [];
        }
        // return a pair of errors for the mis-matched argument
        return [
            ValidationErrorFactory.MismatchedPayloadPropertyValueActionArgument({
                expr: getExpressionIfLocField((_a = confirm.apply) === null || _a === void 0 ? void 0 : _a.getArgument("payload"), confirm),
                attributes: {
                    propertyName: name,
                    actionName: (_b = api.action) === null || _b === void 0 ? void 0 : _b.actionName,
                },
            }),
            ValidationErrorFactory.MismatchedPayloadPropertyValuePreviouslyConfirmed({
                expr: getExpressionIfLocField((_c = api.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue(name), arg),
                attributes: {
                    argumentName: name,
                    actionName: (_d = api.action) === null || _d === void 0 ? void 0 : _d.actionName,
                },
            }),
        ];
    })
        .reduce((a, b) => a.concat(b), []);
    return state.withError(...errors);
}
/**
 * Validate ensure action used in dialog sample
 * traverse the requestArgs list and do the following validations
 * 1. Make sure each response contain APL-A
 * 2. Make sure each all arguments in the argument list refer to the same action
 * 3. When the arguments list of RequestArguments contains multiple args, make sure each arg has request prompt
 */
export const evaluateEnsure = (ensure, state) => {
    var _a, _b;
    if (ensure.node === undefined) {
        return state;
    }
    const errors = [];
    state = state.withRequestedArguments(true, ...ensure.getIndividuallyRequestedArguments());
    // const requestArgsNode = ensure.requestArgs.origin;
    if (((_a = ensure.requestArgs) === null || _a === void 0 ? void 0 : _a.isList()) && ensure.requestArgs.isLiteral()) {
        for (const requestArg of (_b = ensure.requestArgs.getItems()) !== null && _b !== void 0 ? _b : []) {
            const args = requestArg === null || requestArg === void 0 ? void 0 : requestArg.getProperty("arguments");
            errors.push(...validateArgumentListThing(args, args === null || args === void 0 ? void 0 : args.origin));
            if (requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) {
                errors.push(...validatePrompt(requestArg.apply));
            }
            if (requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) {
                state = validateRequestPromptInArgsList(ensure, requestArg, state);
            }
        }
    }
    return state.withError(...errors);
};
/**
 * Validations of the List<Argument<Thing>> type
 * the items in the "arguments" list should be from the same Action
 * @param value
 * @param branch
 */
export function validateArgumentList(value, valueThing) {
    return validateArgumentListThing(valueThing, value);
}
export function validateArgumentListThing(list, expr) {
    var _a, _b;
    const parseErrors = [];
    if (list === undefined) {
        return parseErrors;
    }
    else if (list.isUnion()) {
        return list.things.map((t) => validateArgumentListThing(t, expr)).reduce((a, b) => a.concat(b), []);
    }
    else if ((list === null || list === void 0 ? void 0 : list.isLiteral()) && list.isList()) {
        const actionNamesSet = new Set();
        const items = (_a = list.getItems()) !== null && _a !== void 0 ? _a : [];
        if (items.length === 0) {
            parseErrors.push(ValidationErrorFactory.ExpectedNonEmptyArgumentList({ expr }));
            return parseErrors;
        }
        for (const itemThing of (_b = list.getItems()) !== null && _b !== void 0 ? _b : []) {
            if (itemThing === undefined) {
                // This will happen when referring to the arguments of a reusable dialog:
                //    ensure(RequestArguments {arguments = [saveRating.arguments.arg0], response = feedback_prompt})
                // saveRating is an argument to the reusable dialog:
                //    dialog Nothing GetFeedback(Action1<Number, Nothing> saveRating)
                // For this case, currently skipping the validations for argument reference and type below
                continue;
            }
            if (!itemThing.isArgument()) {
                continue;
            }
            const argumentInformation = itemThing.getReferencedActionArgumentTypeInformation();
            if (!argumentInformation || !argumentInformation.actionName) {
                parseErrors.push(ValidationErrorFactory.ArgumentMustReferToActionArgument({
                    expr: { loc: itemThing === null || itemThing === void 0 ? void 0 : itemThing.loc, uri: expr === null || expr === void 0 ? void 0 : expr.uri },
                    attributes: { argumentName: itemThing.argumentName },
                }));
            }
            else {
                actionNamesSet.add(argumentInformation.actionName);
                if (argumentInformation.type && !argumentInformation.type.isValidForUtterance()) {
                    parseErrors.push(ValidationErrorFactory.ArgumentMustReferToActionArgumentWithUtteranceType({
                        expr: { loc: itemThing === null || itemThing === void 0 ? void 0 : itemThing.loc, uri: expr === null || expr === void 0 ? void 0 : expr.uri },
                        attributes: { argumentName: itemThing.argumentName, typeName: argumentInformation.type.toString() },
                    }));
                }
            }
        }
        if (actionNamesSet.size > 1) {
            const actionNames = Array.from(actionNamesSet.values())
                .map((n) => "'" + n + "'")
                .join(", ");
            return [
                ValidationErrorFactory.MismatchedActionArgumentsList({
                    expr,
                    attributes: {
                        actionNames: actionNames,
                    },
                }),
            ];
        }
    }
    return parseErrors;
}
/**
 * Validate response argument in response, confirmAction, ensure and confirmArgs actions
 * The type of response should be APL-A
 *
 * Right now the type validation won't check response type cause the response type could be anything
 */
export const validatePrompt = (apply) => {
    var _a, _b, _c;
    const errors = [];
    const promptNode = apply.getArgumentValue("response");
    const prompt = apply.getArgumentValueThing("response");
    if (prompt !== undefined) {
        if (((_a = prompt.type) === null || _a === void 0 ? void 0 : _a.isApla()) || ((_b = prompt.type) === null || _b === void 0 ? void 0 : _b.isMultiModalResponse())) {
            // APLA and MultiModalResponse are valid prompt
            // TODO: we should probably check if the APLA property is set, right?
        }
        else {
            errors.push(ValidationErrorFactory.MissingAplaInResponse({
                expr: promptNode,
                attributes: {
                    type: (_c = prompt.type) === null || _c === void 0 ? void 0 : _c.toString(promptNode),
                },
            }));
        }
    }
    return errors;
};
export const validateRequestPromptInArgsList = (expr, act, state) => {
    var _a, _b, _c, _d;
    if (act === undefined) {
        return state;
    }
    if (act.isUnion()) {
        // return args.things.map((thing) => validateRequestPromptInArgsList(thing, state)).reduce((a, b) => a.concat(b), []);
        throw new Error("this should be impossible.");
    }
    else if (expr.isConfirmArgs() || act.type.isRequest() || act.type.isRequestArguments() || act.type.isConfirmArgs()) {
        const args = (_c = (_b = (_a = act.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValueThing("arguments")) === null || _b === void 0 ? void 0 : _b.asLiteralList()) === null || _c === void 0 ? void 0 : _c.getItems();
        if (args && args.length > 1) {
            for (const arg of args) {
                const argName = (_d = arg === null || arg === void 0 ? void 0 : arg.origin) === null || _d === void 0 ? void 0 : _d.name;
                if ((arg === null || arg === void 0 ? void 0 : arg.isArgument()) && argName !== undefined) {
                    if ((expr.isResponse() || expr.isEnsure() || expr.isConfirmArgs()) && !state.isArgumentRequested(arg)) {
                        state = state.withPendingRequestPromptValidation(expr, arg);
                    }
                }
            }
        }
    }
    return state;
};
/**
 * Validate the user Defined api call inside dialog sample
 * 1. make sure the argument is api result or event result
 * 2. make sure the required argument has Request Prompt
 * 3. make sure the argument(event result) has not been reset
 */
export const evaluateInvokeApi = (api, state) => {
    var _a;
    if (api.node === undefined) {
        return state;
    }
    const actionName = (_a = api.action) === null || _a === void 0 ? void 0 : _a.actionName;
    const errors = [...validateLoadContextIsCalledOnce(), ...validateArguments(), ...validateOfferedApiInvocation()];
    return state.withError(...errors).clearPendingOffer();
    function validateArguments() {
        var _a, _b, _c, _d;
        return ((_d = (_c = (_b = (_a = api.action) === null || _a === void 0 ? void 0 : _a.getArguments()) === null || _b === void 0 ? void 0 : _b.getArgumentsList()) === null || _c === void 0 ? void 0 : _c.map((arg) => {
            const argValueNode = api.apply.getArgumentValue(arg);
            const argValue = api.apply.getArgumentValueThing(arg);
            if (argValue !== undefined) {
                return validateArgValue(argValueNode, argValue, arg);
            }
            return [];
        }).reduce((a, b) => a.concat(b), [])) !== null && _d !== void 0 ? _d : []);
    }
    function validateOfferedApiInvocation() {
        var _a, _b;
        const invokedAction = (_b = (_a = api.apply) === null || _a === void 0 ? void 0 : _a.decl.name) === null || _b === void 0 ? void 0 : _b.name;
        if (state.pendingOffer && state.pendingOffer != invokedAction) {
            return [
                ValidationErrorFactory.InvokedActionNotOffered({
                    expr: api,
                    attributes: {
                        offeredAction: state.pendingOffer,
                        invokedAction: invokedAction,
                    },
                }),
            ];
        }
        return [];
    }
    /**
     * validate argument value
     * 1. make sure the argument value is api result or event result
     * 2. when the argValue is event result, make sure it has request prompt
     * @param argValue the argument value
     * @param argDecl the declaration of the argument, we could know the argument name, type and whether the argument is optional based on it
     * @returns
     */
    function validateArgValue(argValue, argValueThing, argDecl) {
        var _a, _b;
        const argDeclType = argDecl.type.getArgumentType();
        const invalidApiArgumentError = ValidationErrorFactory.InvalidApiArgument({
            expr: argValue,
        });
        if (argValueThing === undefined || argValueThing.isNothing()) {
            return [];
        }
        if (argValueThing.isLiteral()) {
            if (argValueThing.isList()) {
                return ((_b = (_a = argValueThing
                    .getItems()) === null || _a === void 0 ? void 0 : _a.map(validateArgValueThing).reduce((a, b) => a.concat(b), [])) !== null && _b !== void 0 ? _b : []);
            }
            else {
                return [];
            }
            return [invalidApiArgumentError];
        }
        return validateArgValueThing(argValueThing);
        function validateArgValueThing(argValueThing) {
            var _a;
            const origin = getOriginType(argValueThing);
            if (argValueThing === undefined || argValueThing.isNothing()) {
                return [];
            }
            if (argValueThing.isUnion()) {
                return argValueThing.things.map(validateArgValueThing).reduce((a, b) => a.concat(b), []);
            }
            if (argValueThing.parent === undefined) {
                // if we're directly referencing a value, it must be an API cal
                if (isFromOrigin(origin, "api") === false) {
                    return [invalidApiArgumentError];
                }
            }
            else if (isFromOrigin(origin, "event", "api") === false) {
                // if we're indexing an object, it can be from an event or an API call.
                return [invalidApiArgumentError];
            }
            if (isFromOrigin(origin, "event")) {
                if (!state.isArgumentRequested(argDecl, argValueThing)) {
                    if (!((argDeclType === null || argDeclType === void 0 ? void 0 : argDeclType.isOptional()) || (argDeclType === null || argDeclType === void 0 ? void 0 : argDeclType.isArgs()))) {
                        // if this is a required argument and it has not been requested in this dialog flow, we must keep track of it
                        // and only error if we don't find an `ensure` block later in the dialog flow.
                        // const arg = api.action?.getArgument(argDecl);
                        state = state.withPendingRequestPromptValidation(api, argDecl);
                    }
                }
            }
            // Both the eventResult and apiResult follow the same reset rule
            if (api.flow.isArgumentReset(argValueThing, api.apply.decl)) {
                const argumentName = (argValue === null || argValue === void 0 ? void 0 : argValue.kind) === "PropertyReference" ? argValue.printPropertyChainThroughRoot() : (_a = argValue === null || argValue === void 0 ? void 0 : argValue.name) === null || _a === void 0 ? void 0 : _a.name;
                return [
                    ValidationErrorFactory.ResetArgument({
                        expr: argValue,
                        attributes: {
                            argumentName,
                        },
                    }),
                ];
            }
            return [];
        }
    }
    /**
     * A call to the configured loadContext action must be called at most once per dialog sample.
     *
     * @see https://github.com/alexa/ask-ac/issues/225
     */
    function validateLoadContextIsCalledOnce() {
        var _a, _b, _c;
        if (actionName && ((_c = (_b = (_a = state.skillContext) === null || _a === void 0 ? void 0 : _a.loadContext) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name) === actionName) {
            return api.flow.visitPrevious(function walk(flow) {
                var _a;
                if ((flow === null || flow === void 0 ? void 0 : flow.expression) === undefined) {
                    return [];
                }
                if (((_a = flow === null || flow === void 0 ? void 0 : flow.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call") {
                    const apply = flow.checker.getApply(flow.expression);
                    if (apply === null || apply === void 0 ? void 0 : apply.isUserDefinedApi()) {
                        const thisName = apply === null || apply === void 0 ? void 0 : apply.getName();
                        if (thisName) {
                            if (thisName === actionName) {
                                return [
                                    ValidationErrorFactory.InvalidLoadContextMultipleCall({
                                        expr: api,
                                        attributes: {
                                            actionName,
                                        },
                                    }),
                                ];
                            }
                            return [
                                ValidationErrorFactory.InvalidLoadContextNotFirstCall({
                                    expr: api,
                                    attributes: {
                                        actionName,
                                    },
                                }),
                            ];
                        }
                    }
                }
                return flow.visitPrevious(walk);
            });
        }
        return [];
    }
};
/**
 * Validate payload argument in response and confirmAction action
 *
 * 1. the expression assigned to payload is either null, Thing, or an ObjectLiteral
 * 2. the value assigned to payload property can only be a name directly referring to an api result or a type used in an event
 * 3. validate payload against next api call
 *
 * The Simulator can only understand payload values to be either a slot in the event or the return value of an api invocation
 */
export const validatePayload = (response, state) => {
    var _a;
    if (response.payload === undefined) {
        return [];
    }
    const errors = [];
    const expr = getExpressionIfLocField((_a = response.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("payload"), response);
    validatePayloadThing(response.payload);
    return errors;
    function validatePayloadThing(payload) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (payload.isUnion()) {
            throw new Error("this should be impossible.");
            // payload.things.forEach(validatePayloadThing);
        }
        else if (payload.isPrimitive()) {
            if (payload.isLiteral() && (payload.isVoid() || payload.isNothing())) {
                // null and nothing literals are allowed.
            }
            else {
                // TODO: i need to properly handle Optional -> which is AnyThing right now
                errors.push(ValidationErrorFactory.InvalidPayloadType({
                    expr,
                }));
            }
        }
        else if (!payload.isLiteral()) {
            errors.push(ValidationErrorFactory.InvalidPayloadType({
                expr,
            }));
        }
        else {
            // now we have an object literal `{ prop = value }`
            Object.entries((_a = payload.getProperties()) !== null && _a !== void 0 ? _a : {}).forEach(([name, propThing]) => {
                if (propThing !== undefined) {
                    const origin = getOriginType(propThing);
                    if (propThing.parent === undefined) {
                        // if we're directly referencing a value, it must be an API cal
                        if (isFromOrigin(origin, "api") === false) {
                            errors.push(ValidationErrorFactory.InvalidPayloadPropertyValue({
                                expr,
                            }));
                        }
                    }
                    else if (isFromOrigin(origin, "event", "api") === false) {
                        // if we're indexing an object, it can be from an event or an API call.
                        errors.push(ValidationErrorFactory.InvalidPayloadPropertyValue({
                            expr,
                        }));
                    }
                }
            });
        }
        // payload type should be consistent with response type
        if (((_c = (_b = response.response) === null || _b === void 0 ? void 0 : _b.type) === null || _c === void 0 ? void 0 : _c.genericArguments) && ((_e = (_d = response.response) === null || _d === void 0 ? void 0 : _d.type) === null || _e === void 0 ? void 0 : _e.genericArguments.length) > 0) {
            const responseGenericType = (_g = (_f = response.response) === null || _f === void 0 ? void 0 : _f.type) === null || _g === void 0 ? void 0 : _g.genericArguments[0];
            if (responseGenericType !== undefined && !payload.type.extends(responseGenericType)) {
                errors.push(typeError(payload.type, responseGenericType, response.node, getExpressionIfLocField((_h = response.apply) === null || _h === void 0 ? void 0 : _h.getArgumentValue("payload"), response)));
            }
        }
    }
};
function isFromOrigin(actualOrigin, ...expectedOrigin) {
    const allowedOrigins = new Set(expectedOrigin);
    if (actualOrigin === undefined) {
        return undefined;
    }
    if (typeof actualOrigin === "string") {
        return allowedOrigins.has(actualOrigin);
    }
    let accum = true;
    for (const o of actualOrigin) {
        if (o === undefined) {
            return undefined;
        }
        accum = allowedOrigins.has(o) && accum;
    }
    return accum;
}
function getOriginType(thing) {
    var _a;
    if (thing === undefined) {
        return undefined;
    }
    if (thing.parent !== undefined) {
        // a thing is from an API call or an Event if the root is from an API or expect event
        return getOriginType(thing.parent);
    }
    if (thing.isLiteral()) {
        return "literal";
    }
    if (thing.isUnion()) {
        return thing.things
            .map((t) => getOriginType(t))
            .reduce((a, b) => {
            if (Array.isArray(a) && Array.isArray(b)) {
                return a.concat(b);
            }
            if (Array.isArray(a)) {
                return [...a, b];
            }
            if (Array.isArray(b)) {
                return [a, ...b];
            }
            return [a, b];
        }, []);
    }
    if (((_a = thing.origin) === null || _a === void 0 ? void 0 : _a.kind) === "ArgumentDeclaration") {
        // origin is an argument declaration, this relies on re-usable dialog expansion logic ....
        // for now, return false?
        return "argument";
    }
    const { apply } = thing;
    if (apply === undefined) {
        return undefined;
    }
    if (apply.isExpect()) {
        return "event";
    }
    if (apply.isUserDefinedApi()) {
        return "api";
    }
    if (apply.isOperator()) {
        return "operator";
    }
    if (apply.isNativeAction()) {
        return "native";
    }
    if (apply.isBuiltin()) {
        return "built-in";
    }
    return undefined;
}
export function validateGlobalWelcome(project, checker) {
    const welcomeCalls = project.modules
        .map((module) => {
        var _a, _b, _c;
        return (_c = (_b = (_a = module.content) === null || _a === void 0 ? void 0 : _a.expressions) === null || _b === void 0 ? void 0 : _b.map((expr) => {
            var _a;
            if (expr.kind === "Call" || (expr.kind === "NameDeclaration" && ((_a = expr.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call")) {
                const apply = checker.getApply(expr.kind === "Call" ? expr : expr.expression);
                if (apply === null || apply === void 0 ? void 0 : apply.isWelcome()) {
                    return [expr];
                }
            }
            return [];
        }).reduce((a, b) => a.concat(b), [])) !== null && _c !== void 0 ? _c : [];
    })
        .reduce((a, b) => a.concat(b), []);
    if (welcomeCalls.length > 1) {
        return welcomeCalls.map((welcome) => ValidationErrorFactory.TooManyWelcomeCalls({
            expr: welcome,
            attributes: {
                welcomeCallCount: welcomeCalls.length,
            },
        }));
    }
    return [];
}
/**
 * validate all required prompts are exist in current skill
 */
export function validateSkillLevelResponses(project) {
    var _a;
    const errors = [];
    const promptsNameSet = new Set();
    // Check if required prompts exist in current skill
    (_a = project.responseTemplates) === null || _a === void 0 ? void 0 : _a.forEach((prompt) => {
        if (prompt.isPrompt()) {
            promptsNameSet.add(prompt.name);
        }
    });
    Object.values(ask.AlexaConversationPrompts).forEach((requiredPrompt) => {
        if (!promptsNameSet.has(requiredPrompt)) {
            errors.push(ValidationErrorFactory.MissingRequiredPrompts({
                attributes: {
                    promptName: requiredPrompt,
                },
            }));
        }
    });
    return errors;
}
/**
 * Verify the expect of Invoke event exists by recursively calling the @function doesSampleStartWithInvoke
 *
 * E.G. Below is a valid example, as it has expect with Invoke event:
 * dialog void A {
 *   sample {
 *     expect(Invoke, invocationUtterances)
 *     // ... conversation flow's logic
 *     response(APLA {}, Bye {})
 *   }
 * }
 *
 * It makes sure all the branches have an Invoke event if conditional branches exist.
 * E.G. The dialog below is not a valid one as it misses Invoke in one condition branch:
 * dialog void B {
 *   sample {
 *     if (some_condition) {
 *       expect(RequestAlt, invocationUtterances)
 *     } else {
 *       expect(Invoke, invocationUtterances)
 *     }
 *     response(APLA {}, Bye {})
 *   }
 * }
 *
 * @param sample sample node to validate through the expressions to find Invoke event
 * @param flow type checker
 * @returns
 */
export const validateSampleStartWithInvoke = (flow, state) => {
    const sample = flow.expression;
    const dialogDecl = sample.context;
    return flow
        .interpret((expr) => visit(expr, state), undefined)
        .map((state) => state.errors)
        .flat();
    function visit(expr, state) {
        var _a, _b, _c;
        if (expr.isEnd()) {
            // if we reach the end then don't report any error - the sample will be flagged as not having an expressions.
            return state;
        }
        if (expr.isDialogExpansion()) {
            // skip dialog expansion (treat it as transient).
            return (next) => visit(next, state);
        }
        if (expr.isExpect()) {
            if (expr.isInvoke()) {
                return state;
            }
            // TODO: specialize error message for the wrong act typ
            // TODO: is the origin location a bad idea?
            return state.withError(ValidationErrorFactory.MissingExpectInvokeEvent({
                expr: getExpressionIfLocField((_a = expr.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("act"), expr, sample),
                attributes: {
                    dialogName: (_b = dialogDecl.name) === null || _b === void 0 ? void 0 : _b.name,
                },
            }));
        }
        if (expr.isEnsure() || expr.isConditionalBranch() || expr.isDialogExpansion() || expr.isBlock()) {
            // these blocks don't count as evaluated actions, so we  move to the next expressions
            // return expr.flow.interpret(state, EvaluationState.combine, evaluate);
            return (next) => visit(next, state.pushExpr(expr));
        }
        return state.withError(ValidationErrorFactory.MissingExpectInvokeEvent({
            expr: getExpressionIfLocField(expr, sample),
            attributes: {
                dialogName: (_c = dialogDecl.name) === null || _c === void 0 ? void 0 : _c.name,
            },
        }));
    }
};
/**
 * Returns true if conditionExpressionThing or its root parent is from the last API/from expect
 * or an operator/native action with at least one argument that is from the last API/from expect.
 * This will recursevely follow conditionExpressionThing.parent to find the root parent. Once there
 * returns true if it is either:
 *   1) the last user defined API or
 *   2) an event out of an expect call or
 *   3) an operator or native action where at least one argument is 1) or 2)
 * @param conditionExpressionThing condition expression thing
 * @param lastApiName name of the last user defined API called
 * @returns true if conditionExpressionThing or its root parent is from the last API/from expect
 * or an operator/native action with at least one argument that is from the last API/from expect.
 */
const isConditionExpressionFromLastApiOrFromExpect = (conditionExpressionThing, lastApiName) => {
    if (conditionExpressionThing === undefined) {
        return false;
    }
    if (conditionExpressionThing.parent !== undefined) {
        return isConditionExpressionFromLastApiOrFromExpect(conditionExpressionThing.parent, lastApiName);
    }
    if (!conditionExpressionThing.apply) {
        return false;
    }
    if (conditionExpressionThing.apply.isExpect()) {
        return true;
    }
    if (conditionExpressionThing.apply.isUserDefinedApi()) {
        return conditionExpressionThing.apply.getName() === lastApiName;
    }
    if (conditionExpressionThing.apply.isOperator() || conditionExpressionThing.apply.isNativeAction()) {
        for (const arg in conditionExpressionThing.apply.getArguments()) {
            const argThing = conditionExpressionThing.apply.getArgumentValueThing(arg);
            if (!argThing || isConditionExpressionFromLastApiOrFromExpect(argThing, lastApiName)) {
                return true;
            }
        }
    }
    return false;
};
/**
 * This function validates Condition.when for the following checkpoints:
 * 2. validate the when condition contains any data from the last API invocation call
 * 3. validate then when expression to have a boolean return type
 *
 * @param cond Condition.when Call | NameReference
 * @param condition type checker for querying the expressions
 * @returns type Validator<T>
 */
export const evaluateConditionalBranch = (condition, state) => {
    var _a, _b;
    state = state.withError(...validateFirstExpressionInCondition());
    const { when } = condition.flow.expression;
    if ((when === null || when === void 0 ? void 0 : when.expression) === undefined) {
        return state;
    }
    if (!isConditionExpressionFromLastApiOrFromExpect(condition.expr, (_b = (_a = state.previousApi) === null || _a === void 0 ? void 0 : _a.apply) === null || _b === void 0 ? void 0 : _b.getName())) {
        return state.withError(ValidationErrorFactory.ConditionWhenMustCompareApiResponse({
            expr: getExpressionIfLocField(when, when.context),
        }));
    }
    return state;
    // check that the first expression in each conditional block is another ConditionalBranch, API invocation, Notify Response or Confirm Action
    function validateFirstExpressionInCondition() {
        return condition.flow
            .interpret(function visit(expr, block) {
            var _a;
            if (expr.isEnd() || !isInCondition(expr)) {
                // This Expression does not exist within the ConditionalBranch, so let the "a condition must contain at least one expression" validator catch this.
                return [
                    ValidationErrorFactory.ExprRequiredInConditionBlock({
                        expr: getExpressionIfLocField(block, condition),
                    }),
                ];
            }
            if (expr.isConditionalBranch()) {
                // if the next expression is a Conditional, it's valid
                return [];
            }
            if (expr.isBlock() && block === undefined) {
                // this is the first block encountered after the Conditional Branch, we should use this as the location of the errors.
                return (next) => visit(next, expr);
            }
            if (expr.isDialogExpansion() || expr.isEnsure() || expr.isConfirmArgs() || expr.isBlock()) {
                // if we encounter another conditional branch, dialog expansion or an ambient expression such as ensure or confirmArgs - continue evaluating the dialog flow
                return (expr) => visit(expr, block);
            }
            if (expr.isInvokeApi()) {
                // we allow API invocations and ConfirmAction
                // TODO: need to confirm whether ConfirmAction is allowed in a Conditional Branch. I can't remember why ... it doesn't seem to align with requirements?
                return [];
            }
            if (expr.isResponse()) {
                if (((_a = expr.act) === null || _a === void 0 ? void 0 : _a.type.isNotify()) === false) {
                    return [
                        ValidationErrorFactory.InvalidFirstResponseInConditionBlock({
                            expr: getExpressionIfLocField(expr.actNode, expr),
                        }),
                    ];
                }
                // Notify Response is valid, no error.
                return [];
            }
            return [
                ValidationErrorFactory.InvalidFirstExprInConditionBlock({
                    expr,
                }),
            ];
        }, condition)
            .flat();
    }
    /**
     * HACK: Check if this Expression is directly in the context of the ConditionalBranch being expanded.
     *
     * We need this hack because of a short-coming of interpret (ugh!) - we don't know when an Expression
     * in the Stream originated from within a Condition or outside, making this validation difficult.
     */
    function isInCondition(expr) {
        if (expr.flow.stack.length === 0) {
            return false;
        }
        for (const prevExpr of expr.flow.stack) {
            if (prevExpr.kind === "Condition") {
                return prevExpr === condition.flow.expression;
            }
        }
        return false;
    }
};
/**
 * Returns true if the flow originated from a dialog call.
 */
function isFlowFromDialogCall(flow) {
    if ((flow === null || flow === void 0 ? void 0 : flow.stack.length) !== 1) {
        return false;
    }
    const stackNode = flow.stack[0];
    if ((stackNode === null || stackNode === void 0 ? void 0 : stackNode.kind) === "Call") {
        const apply = flow.checker.getApply(stackNode);
        return apply === null || apply === void 0 ? void 0 : apply.isDialog();
    }
    return false;
}
/**
 * Validates if response calls with 'Request' request acts are called consecutively
 */
export const validatePriorResponseCall = (response) => {
    var _a, _b, _c, _d;
    const errors = [];
    if ((_a = response.prev) === null || _a === void 0 ? void 0 : _a.isResponse()) {
        const reqAct = response.apply.getArgumentValue("act");
        const prevReqAct = response.prev.apply.getArgumentValue("act");
        if (((_b = reqAct === null || reqAct === void 0 ? void 0 : reqAct.name) === null || _b === void 0 ? void 0 : _b.name) === ((_c = prevReqAct === null || prevReqAct === void 0 ? void 0 : prevReqAct.name) === null || _c === void 0 ? void 0 : _c.name) && ((_d = prevReqAct === null || prevReqAct === void 0 ? void 0 : prevReqAct.name) === null || _d === void 0 ? void 0 : _d.name) === "Request") {
            errors.push(ValidationErrorFactory.InvalidEventInform({
                expr: response,
                attributes: {
                    requestAct: "Inform",
                },
            }));
        }
    }
    return errors;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZhbHVhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZXZhbHVhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLEdBQUcsTUFBTSxPQUFPLENBQUM7QUFJN0IsT0FBTyxFQUFvQixrQkFBa0IsRUFBQyxNQUFNLE9BQU8sQ0FBQztBQUU1RCxPQUFPLEVBQTJCLFNBQVMsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQWtCNUQsT0FBTyxFQUFDLHVCQUF1QixFQUFrQixzQkFBc0IsRUFBOEIsTUFBTSxpQkFBaUIsQ0FBQztBQVE3SDs7R0FFRztBQUNILE1BQU0sVUFBVSxrQkFBa0IsQ0FBQyxJQUFpQyxFQUFFLEtBQXNCO0lBQzFGLG1EQUFtRDs7SUFFbkQsT0FBTztRQUNMLFlBQVksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO1FBQ3RELE1BQUEsTUFBQSxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sMENBQUUsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyw2QkFBNkIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLG1DQUFJLEVBQUU7S0FDeEcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDWixDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FBQyxJQUFVLEVBQUUsS0FBc0I7SUFDN0QsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsUUFBUSxDQUFDLElBQUksRUFBRSxTQUFTLEdBQUcsS0FBSztRQUM3RCxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUNoQixPQUFPLFdBQVcsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFD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