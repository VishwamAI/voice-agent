import { guard } from "./guard";
import { Tree } from "./tree";
export const isArgumentDeclaration = guard("ArgumentDeclaration");
/**
 * The arguments for action or dialog.
 */
export class ArgumentDeclaration extends Tree {
    constructor(
    /**
     * Name of argument.
     */
    name, 
    /**
     * Type of the argument.
     */
    type, 
    /**
     * Default value for the argument, if value is not passed from caller.
     */
    defaultExpression, 
    /**
     * Annotations attached to this Argument Declaration.
     */
    annotations, loc) {
        super("ArgumentDeclaration", loc);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "defaultExpression", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: defaultExpression
        });
        Object.defineProperty(this, "annotations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: annotations
        });
        this.setAsParentOn(name);
        this.setAsParentOn(type);
        this.setAsParentOn(defaultExpression);
        this.setAsParentOn(annotations);
    }
    clone() {
        var _a, _b, _c, _d;
        return new ArgumentDeclaration((_a = this.name) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.type) === null || _b === void 0 ? void 0 : _b.clone(), (_c = this.defaultExpression) === null || _c === void 0 ? void 0 : _c.clone(), (_d = this.annotations) === null || _d === void 0 ? void 0 : _d.map((a) => a.clone()), this.loc);
    }
}
export const isArgument = guard("Argument");
/**
 * Represents named argument.
 * Left side of the expression is name of the argument and right side of the expression is expression assigned to
 * argument.
 * Example 1:
 * <code>
 *    findParkingAPI(parkingRequest = findParkingRequest)
 * </code>
 * parkingRequest is name and findParkingRequest is NameExpr assigned to parkingRequest argument.
 * Example 2:
 * <code>
 *     action Restaurant findRestaurant(City cityName)
 *
 *     findRestaurant(city)
 * </code>
 * cityName is the name and city is the NameExpr assigned to the cityName argument.
 * Type of the NamedArgumentExpr should be the same as the type of expression assigned to argument.
 */
export class Argument extends Tree {
    constructor(
    /**
     * Name of the Argument.
     */
    name, 
    /**
     * Index of the argument if provided positionally.
     */
    index, 
    /**
     * Expression for the argument value.ÃŸ
     */
    value, loc) {
        super("Argument", loc);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: index
        });
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
        });
        this.setAsParentOn(name);
        this.setAsParentOn(value);
    }
    clone() {
        var _a, _b;
        return new Argument((_a = this.name) === null || _a === void 0 ? void 0 : _a.clone(), this.index, (_b = this.value) === null || _b === void 0 ? void 0 : _b.clone(), this.loc);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJndW1lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYXN0L2FyZ3VtZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFJOUIsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLFFBQVEsQ0FBQztBQVE1QixNQUFNLENBQUMsTUFBTSxxQkFBcUIsR0FBRyxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUVsRTs7R0FFRztBQUNILE1BQU0sT0FBTyxtQkFBb0IsU0FBUSxJQUFrRTtJQUN6RztJQUNFOztPQUVHO0lBQ00sSUFBVztJQUNwQjs7T0FFRztJQUNNLElBQW9CO0lBQzdCOztPQUVHO0lBQ00saUJBQThCO0lBQ3ZDOztPQUVHO0lBQ00sV0FBMEIsRUFDbkMsR0FBb0I7UUFFcEIsS0FBSyxDQUFDLHFCQUFxQixFQUFFLEdBQUcsQ0FBQyxDQUFDOzs7OzttQkFmekI7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOzs7Ozs7bUJBSUE7O1FBSVQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFTSxLQUFLOztRQUNWLE9BQU8sSUFBSSxtQkFBbUIsQ0FDNUIsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxLQUFLLEVBQUUsRUFDbEIsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxLQUFLLEVBQUUsRUFDbEIsTUFBQSxJQUFJLENBQUMsaUJBQWlCLDBDQUFFLEtBQUssRUFBRSxFQUMvQixNQUFBLElBQUksQ0FBQyxXQUFXLDBDQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQ3ZDLElBQUksQ0FBQyxHQUFHLENBQ0QsQ0FBQztJQUNaLENBQUM7Q0FDRjtBQUVELE1BQU0sQ0FBQyxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7QUFFNUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUJHO0FBQ0gsTUFBTSxPQUFPLFFBQVMsU0FBUSxJQUFzQjtJQUNsRDtJQUNFOztPQUVHO0lBQ00sSUFBVztJQUNwQjs7T0FFRztJQUNNLEtBQWM7SUFDdkI7O09BRUc7SUFDTSxLQUFxQixFQUM5QixHQUFvQjtRQUVwQixLQUFLLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxDQUFDOzs7OzttQkFYZDs7Ozs7O21CQUlBOzs7Ozs7bUJBSUE7O1FBSVQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFFTSxLQUFLOztRQUNWLE9BQU8sSUFBSSxRQUFRLENBQUMsTUFBQSxJQUFJLENBQUMsSUFBSSwwQ0FBRSxLQUFLLEVBQUUsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLE1BQUEsSUFBSSxDQUFDLEtBQUssMENBQUUsS0FBSyxFQUFFLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBUyxDQUFDO0lBQzdGLENBQUM7Q0FDRiJ9