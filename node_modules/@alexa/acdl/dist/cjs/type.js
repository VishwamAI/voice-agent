"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Type_environment, _Type_extensions, _Type_properties, _Type_propertiesIndex, _Type_locales;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = exports.isType = void 0;
const ask = __importStar(require("./ast"));
const apply_1 = require("./apply");
const ast_1 = require("./ast");
const util_1 = require("./util");
const thing_1 = require("./thing");
const visit_1 = require("./visit");
function isType(obj) {
    return (obj === null || obj === void 0 ? void 0 : obj.kind) === "Type";
}
exports.isType = isType;
/**
 * A Type represents an instantiated Type in some context.
 *
 * Any `genericArguments` are either explicitly substituted or inferred from the surrounding context.
 *
 * This class provides a lazily-evaluated API for querying properties of the type.
 */
class Type {
    constructor(checker, 
    /**
     * Declaration of the instantiated type.
     */
    declaration, 
    /**
     * Instantiated type arguments.
     */
    genericArguments, 
    /**
     * Source node of this Type.
     */
    // readonly source?: ask.Node,
    functionArgumentNames, 
    /**
     * Name of the function (if this is an abstract function signature)
     */
    functionName) {
        Object.defineProperty(this, "checker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: checker
        });
        Object.defineProperty(this, "declaration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: declaration
        });
        Object.defineProperty(this, "genericArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: genericArguments
        });
        Object.defineProperty(this, "functionArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: functionArgumentNames
        });
        Object.defineProperty(this, "functionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: functionName
        });
        Object.defineProperty(this, "kind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Type"
        });
        // cache lazily evaluated environment - use `null` to indicate "cached, but empty".
        _Type_environment.set(this, void 0);
        // cache lazily evaluated list of base types - use `null` to indicate "cached, but empty".
        _Type_extensions.set(this, void 0);
        // cache lazily evaluated properties - use `null` to indicate "cached, but empty".
        _Type_properties.set(this, void 0);
        // cache lazily evaluated property index - use `null` to indicate "cached, but empty".
        _Type_propertiesIndex.set(this, void 0);
        // cache lazily evaluated properties - use `null` to indicate "cached, but empty".
        _Type_locales.set(this, void 0);
    }
    /**
     * String representation of this Type.
     */
    toString(context) {
        var _a, _b, _c, _d;
        const inScope = context ? this.checker.lookupName(context, this.shortName) : undefined;
        const name = (inScope === null || inScope === void 0 ? void 0 : inScope.kind) === "TypeDeclaration" && ((_a = inScope.name) === null || _a === void 0 ? void 0 : _a.name) && inScope.name.name === ((_b = this.name) === null || _b === void 0 ? void 0 : _b.name) ? this.shortName : (_c = this.name) === null || _c === void 0 ? void 0 : _c.name;
        if (this.isFunctionN() && this.functionArgumentNames !== undefined) {
            const prefix = this.isAction() ? "action" : this.isDialog() ? "dialog" : "function";
            return `${prefix} ${(_d = this.getFunctionReturnType()) === null || _d === void 0 ? void 0 : _d.toString()}${this.functionName ? ` ${this.functionName}` : ""}(${this.functionArgumentNames
                .map((name, i) => {
                let argType = this.getFunctionArgumentType(i);
                const isOptional = (argType === null || argType === void 0 ? void 0 : argType.isOptional()) === true;
                if (argType === null || argType === void 0 ? void 0 : argType.isOptional()) {
                    while (argType === null || argType === void 0 ? void 0 : argType.isOptional()) {
                        argType = argType.getOptionalType();
                    }
                }
                return `${isOptional ? "optional " : ""}${argType === null || argType === void 0 ? void 0 : argType.toString()} ${name}`;
            })
                .join(", ")})`;
        }
        return `${name}${this.genericArguments ? `<${this.genericArguments.map((a) => a === null || a === void 0 ? void 0 : a.toString(context)).join(", ")}>` : ""}`;
    }
    toTypeReference(context) {
        var _a;
        const ref = new ask.TypeReference(this.name, (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a.map((arg) => arg === null || arg === void 0 ? void 0 : arg.toTypeReference()), undefined, undefined);
        if (context) {
            ref.context = context;
        }
        return ref;
    }
    get shortName() {
        var _a, _b, _c;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) ? (0, util_1.getName)((_c = this.declaration.name) === null || _c === void 0 ? void 0 : _c.name) : undefined;
    }
    /**
     * Name of this Type.
     */
    get name() {
        var _a;
        return (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name;
    }
    get namespace() {
        var _a, _b;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) ? (0, util_1.getNamespace)((_b = this.name) === null || _b === void 0 ? void 0 : _b.name) : undefined;
    }
    /**
     * The type environment of this Type.
     *
     * Maps type aliases for Type Parameters to instantiated Types.
     */
    get environment() {
        var _a, _b;
        if (__classPrivateFieldGet(this, _Type_environment, "f") === undefined) {
            if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeDeclaration") {
                const genericArguments = this.declaration.genericArguments || [];
                __classPrivateFieldSet(this, _Type_environment, ((_b = this.genericArguments) === null || _b === void 0 ? void 0 : _b.map((arg, i) => {
                    var _a, _b;
                    const name = (_b = (_a = genericArguments === null || genericArguments === void 0 ? void 0 : genericArguments[i]) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name;
                    return name === undefined
                        ? {}
                        : {
                            [name]: arg,
                        };
                }).reduce((a, b) => ({ ...a, ...b }), {})) || null, "f");
            }
        }
        return __classPrivateFieldGet(this, _Type_environment, "f") || undefined;
    }
    /**
     * Ordered list of this Type's base types (the types it "extends").
     */
    get extensions() {
        var _a, _b;
        if (__classPrivateFieldGet(this, _Type_extensions, "f") === undefined) {
            __classPrivateFieldSet(this, _Type_extensions, (_a = this.resolveExtensions()) !== null && _a !== void 0 ? _a : null, "f");
        }
        return (_b = __classPrivateFieldGet(this, _Type_extensions, "f")) !== null && _b !== void 0 ? _b : undefined;
    }
    resolveExtensions() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        // instantiate the base types
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "SlotType") {
            // Beta 1 loads Slot Types from the interaction model - they always extend string.
            return [this.checker.string];
        }
        if (((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" || ((_c = this.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "DialogDeclaration") {
            const actionArity = (_e = (_d = this.declaration.arguments) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0;
            const typeArgs = [
                ...((_g = (_f = this.declaration.arguments) === null || _f === void 0 ? void 0 : _f.map((arg) => this.checker.getType(arg.type))) !== null && _g !== void 0 ? _g : []),
                this.checker.getType(this.declaration.returnType),
            ];
            const actionType = this.checker.instantiateTypeDeclaration(this.checker.lookupTypeDeclaration(((_h = this.declaration) === null || _h === void 0 ? void 0 : _h.kind) === "ActionDeclaration" ? (0, ast_1.ActionTypeName)(actionArity) : (0, ast_1.DialogTypeName)(actionArity)), typeArgs);
            if (actionType) {
                return [actionType];
            }
            return [this.checker.nothing];
        }
        if (((_j = this.declaration) === null || _j === void 0 ? void 0 : _j.kind) === "EnumDeclaration") {
            return [this.checker.enumeration()];
        }
        if (((_k = this.declaration) === null || _k === void 0 ? void 0 : _k.kind) === "EnumItemDeclaration") {
            const enumType = this.checker.getType(this.declaration.context);
            if (enumType) {
                return [enumType];
            }
        }
        else if (((_l = this.declaration) === null || _l === void 0 ? void 0 : _l.kind) === "TypeDeclaration" || ((_m = this.declaration) === null || _m === void 0 ? void 0 : _m.kind) === "TypeParameter") {
            const extensions = this.declaration.kind === "TypeDeclaration"
                ? this.declaration.extensions
                : this.declaration.kind === "TypeParameter"
                    ? this.declaration.constraints
                    : undefined;
            if (extensions) {
                return extensions.map((extension) => {
                    var _a;
                    // map the input typeArgs to the base-type's arguments
                    const extEnv = ((_a = extension.arguments) === null || _a === void 0 ? void 0 : _a.map((arg) => {
                        var _a;
                        return ({
                            [(_a = arg === null || arg === void 0 ? void 0 : arg.name) === null || _a === void 0 ? void 0 : _a.name]: this.checker.instantiateTypeReference(arg, this.environment),
                        });
                    }).reduce((a, b) => ({ ...a, ...b }), {})) || undefined;
                    return this.checker.instantiateTypeReference(extension, extEnv);
                });
            }
            if (((_o = this.declaration.name) === null || _o === void 0 ? void 0 : _o.name) !== ast_1.AlexaSchema.Nothing && ((_p = this.declaration.name) === null || _p === void 0 ? void 0 : _p.name) !== ast_1.AlexaSchema.Thing) {
                return [this.checker.thing];
            }
        }
        else {
            return [this.checker.nothing];
        }
        return undefined;
    }
    /**
     * Ordered list of all Properties in this Type.
     *
     * @returns list of properties if any, `null` otherwise.
     */
    get properties() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
        if (__classPrivateFieldGet(this, _Type_properties, "f") !== undefined) {
            return __classPrivateFieldGet(this, _Type_properties, "f");
        }
        const properties = [];
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "EnumItemDeclaration") {
            // enum item has no properties, this will change when we support values https://github.com/alexa/ask-ac/issues/198
        }
        else if (((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" || ((_c = this.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "DialogDeclaration" || this.isFunctionN()) {
            const typeType = this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Type);
            const actionType = this.checker.lookupTypeDeclaration(ast_1.AlexaConversations.Action);
            const argumentsType = this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Arguments);
            const returnType = (_d = this.getFunctionReturnType()) !== null && _d !== void 0 ? _d : this.checker.thing;
            if (actionType && typeType && returnType) {
                properties.push({
                    kind: "Property",
                    index: 0,
                    name: "arguments",
                    type: new Type(this.checker, argumentsType, [this]),
                }, {
                    kind: "Property",
                    index: 1,
                    name: "returnType",
                    type: this.checker.instantiateTypeDeclaration(typeType, [returnType]),
                });
            }
        }
        else if (((_e = this.declaration) === null || _e === void 0 ? void 0 : _e.kind) === "TypeDeclaration") {
            if (((_f = this.declaration.name) === null || _f === void 0 ? void 0 : _f.name) === ast_1.AlexaSchema.Type) {
                // this is the intrinsic `Type<T>` type that has varying behavior based on what type it references.
                const type = (_g = this.genericArguments) === null || _g === void 0 ? void 0 : _g[0];
                if (type) {
                    if (((_h = type.declaration) === null || _h === void 0 ? void 0 : _h.kind) === "EnumDeclaration") {
                        (_j = type.declaration.items) === null || _j === void 0 ? void 0 : _j.forEach((item, index) => {
                            var _a, _b;
                            if ((_a = item.name) === null || _a === void 0 ? void 0 : _a.name) {
                                properties.push({
                                    kind: "Property",
                                    index,
                                    name: (_b = item.name) === null || _b === void 0 ? void 0 : _b.name,
                                    declaration: item,
                                    type: this.checker.getType(item),
                                });
                            }
                        });
                    }
                    else {
                        const propertiesType = this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Properties);
                        if (propertiesType) {
                            properties.push({
                                kind: "Property",
                                index: 0,
                                name: "properties",
                                type: new Type(this.checker, propertiesType, [type]),
                            });
                        }
                    }
                }
            }
            else if (((_k = this.declaration.name) === null || _k === void 0 ? void 0 : _k.name) === ast_1.AlexaSchema.Properties || ((_l = this.declaration.name) === null || _l === void 0 ? void 0 : _l.name) === ast_1.AlexaSchema.ArgumentProperties) {
                const property = ((_m = this.declaration.name) === null || _m === void 0 ? void 0 : _m.name) === ast_1.AlexaSchema.Properties ? ast_1.AlexaSchema.Property : ast_1.AlexaSchema.ArgumentProperty;
                const typeType = this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Type);
                const propType = this.checker.lookupTypeDeclaration(property);
                const type = (_o = this.genericArguments) === null || _o === void 0 ? void 0 : _o[0];
                if (typeType && propType && (type === null || type === void 0 ? void 0 : type.properties) !== undefined) {
                    properties.push(...type.properties.map((prop) => ({
                        ...prop,
                        type: this.checker.instantiateTypeDeclaration(propType, [prop.type]),
                        declaration: undefined,
                    })));
                }
            }
            else if (((_p = this.declaration.name) === null || _p === void 0 ? void 0 : _p.name) === ast_1.AlexaConversations.ActionContextValues ||
                ((_q = this.declaration.name) === null || _q === void 0 ? void 0 : _q.name) === ast_1.AlexaSchema.ArgumentValues ||
                ((_r = this.declaration.name) === null || _r === void 0 ? void 0 : _r.name) === ast_1.AlexaSchema.Arguments) {
                // Arguments<F>, ArgumentValues<F> and ActionContextValues<A> all compute a type based on the arguments
                const targetType = (_s = this.genericArguments) === null || _s === void 0 ? void 0 : _s[0];
                const containerType = ((_t = this.declaration.name) === null || _t === void 0 ? void 0 : _t.name) === ast_1.AlexaConversations.ActionContextValues
                    ? this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Optional)
                    : this.declaration.name.name === ast_1.AlexaSchema.Arguments
                        ? this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Argument)
                        : undefined;
                properties.push(...((_v = (_u = targetType === null || targetType === void 0 ? void 0 : targetType.getFunctionArgumentDeclarations()) === null || _u === void 0 ? void 0 : _u.map((arg, index) => {
                    var _a, _b, _c, _d;
                    const innerType = this.checker.instantiateTypeReference(arg.type);
                    const prop = {
                        kind: "Property",
                        index,
                        name: (_a = arg.name) === null || _a === void 0 ? void 0 : _a.name,
                        type: ((_b = containerType === null || containerType === void 0 ? void 0 : containerType.name) === null || _b === void 0 ? void 0 : _b.name) === ast_1.AlexaSchema.Optional && (innerType === null || innerType === void 0 ? void 0 : innerType.isOptional())
                            ? innerType
                            : containerType
                                ? this.checker.instantiateTypeDeclaration(containerType, [innerType])
                                : ((_d = (_c = this.declaration) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name) === ast_1.AlexaSchema.ArgumentValues
                                    ? innerType
                                    : undefined,
                        declaration: arg,
                    };
                    return prop;
                })) !== null && _v !== void 0 ? _v : []));
            }
            else if (((_w = this.declaration.name) === null || _w === void 0 ? void 0 : _w.name) === ast_1.AlexaSchema.Optional) {
                // Optional<T> type would contain all the properties of `T`.
                const argumentType = (_x = this.genericArguments) === null || _x === void 0 ? void 0 : _x[0];
                if (argumentType && argumentType.properties) {
                    properties.push(...argumentType.properties);
                }
            }
            else {
                properties.push(...(((_z = (_y = this.declaration) === null || _y === void 0 ? void 0 : _y.properties) === null || _z === void 0 ? void 0 : _z.map((prop, index) => {
                    var _a;
                    let type = prop.type !== undefined ? this.checker.instantiateTypeReference(prop.type, this.environment) : undefined;
                    if (prop.optional === true && (type === null || type === void 0 ? void 0 : type.isOptional()) === false) {
                        const optionalType = this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Optional);
                        if (optionalType) {
                            type = this.checker.instantiateTypeDeclaration(optionalType, [type]);
                        }
                    }
                    return {
                        kind: "Property",
                        declaration: prop,
                        index,
                        name: (_a = prop.name) === null || _a === void 0 ? void 0 : _a.name,
                        type,
                    };
                })) || []));
            }
        }
        const seen = new Set();
        const _properties = [];
        addProperties(properties);
        if (this.extensions) {
            for (const ext of this.extensions) {
                if (ext === null || ext === void 0 ? void 0 : ext.properties) {
                    addProperties(ext.properties);
                }
            }
        }
        __classPrivateFieldSet(this, _Type_properties, _properties || null, "f");
        return __classPrivateFieldGet(this, _Type_properties, "f") || undefined;
        function addProperties(properties) {
            if (properties) {
                for (const property of properties) {
                    if (!seen.has(property.name)) {
                        _properties.push(property);
                        seen.add(property.name);
                    }
                }
            }
        }
    }
    /**
     * Index of all Properties by name.
     */
    get propertiesIndex() {
        var _a;
        if (__classPrivateFieldGet(this, _Type_propertiesIndex, "f") === undefined) {
            __classPrivateFieldSet(this, _Type_propertiesIndex, ((_a = this.properties) === null || _a === void 0 ? void 0 : _a.map((p) => ({
                [p.name]: p,
            })).reduce((a, b) => ({ ...a, ...b }), {})) || null, "f");
        }
        return __classPrivateFieldGet(this, _Type_propertiesIndex, "f") || undefined;
    }
    /**
     * Apply a Call to this Type.
     *
     *
     * @param call expression of input to the Action.
     */
    apply(call, checker = this.checker) {
        return new apply_1.Apply(checker, call, this);
    }
    /**
     * Instantiate a new Thing of this Type.
     *
     * @param node AST node this Thing value originates from.
     * @returns a Thing instance representing this distinct Thing
     */
    getThing(token, origin, parent, apply) {
        var _a;
        // use the environment of the Application or default to this environment
        const checker = (_a = apply === null || apply === void 0 ? void 0 : apply.checker) !== null && _a !== void 0 ? _a : this.checker;
        if (this.isPrimitive()) {
            if (this.isStringLike()) {
                return new thing_1.StringThing(checker, token, this, apply, origin, parent);
            }
            if (this.isBoolean()) {
                return new thing_1.BooleanThing(checker, token, this, apply, origin, parent);
            }
            if (this.isNumber()) {
                return new thing_1.NumberThing(checker, token, this, apply, origin, parent);
            }
            if (this.isVoid()) {
                return new thing_1.VoidThing(checker, token, this, apply, origin, parent);
            }
            if (this.isNothing()) {
                return new thing_1.NothingThing(checker, token, this, apply, origin, parent);
            }
        }
        else if (this.isAction()) {
            return new thing_1.ActionThing(checker, token, this, this.declaration); // TODO
        }
        else if (this.isDialog()) {
            return new thing_1.DialogThing(checker, token, this, this.declaration); // TODO
        }
        else if (this.isFunction()) {
            return new thing_1.FunctionThing(checker, token, this, (origin === null || origin === void 0 ? void 0 : origin.kind) === "ArgumentDeclaration" ? origin : undefined);
        }
        else if (this.isList()) {
            return new thing_1.ListThing(checker, token, this, apply, origin, parent);
        }
        else if (this.isArgument()) {
            return new thing_1.ArgumentThing(checker, token, this, apply, origin, parent);
        }
        else if (this.isArguments()) {
            return new thing_1.ArgumentsThing(checker, token, this, origin, parent === null || parent === void 0 ? void 0 : parent.asFunction());
        }
        else if (this.isObject()) {
            return new thing_1.ObjectThing(checker, token, this, apply, origin, parent);
        }
        return new thing_1.AnyThing(checker, token, this, apply, origin, parent);
    }
    /**
     * Get the type of a property enclosed by this Type.
     *
     * @param argument name or index
     */
    getPropertyType(argument) {
        var _a;
        return (_a = this.getProperty(argument)) === null || _a === void 0 ? void 0 : _a.type;
    }
    /**
     * Get a property enclosed by this Type.
     *
     * @param argument name or index
     */
    getProperty(argument) {
        var _a, _b, _c;
        if (argument === undefined) {
            return undefined;
        }
        if (ask.isArgument(argument)) {
            if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
                return this.getProperty(argument.name.name);
            }
            if (typeof argument.index === "number") {
                return this.getProperty(argument.index);
            }
        }
        else if (typeof argument === "number") {
            return (_b = this.properties) === null || _b === void 0 ? void 0 : _b[argument];
        }
        else {
            const prop = (_c = this.propertiesIndex) === null || _c === void 0 ? void 0 : _c[argument];
            if (prop) {
                return prop;
            }
            if (this.extensions) {
                for (const ext of this.extensions) {
                    const prop = ext === null || ext === void 0 ? void 0 : ext.getProperty(argument);
                    if (prop) {
                        return prop;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Get the Nodes referenced by this Type.
     */
    getReferences() {
        var _a;
        const references = new Set();
        (_a = this.properties) === null || _a === void 0 ? void 0 : _a.forEach((prop) => {
            var _a, _b;
            if (!(((_a = prop.type) === null || _a === void 0 ? void 0 : _a.isList()) || ((_b = prop.type) === null || _b === void 0 ? void 0 : _b.isOptional()))) {
                findReferences(prop.type);
            }
        });
        return references;
        function findReferences(type) {
            var _a, _b, _c;
            if ((type === null || type === void 0 ? void 0 : type.declaration) !== undefined && !references.has(type.declaration)) {
                references.add(type.declaration);
                (_a = type.genericArguments) === null || _a === void 0 ? void 0 : _a.forEach(findReferences);
                (_b = type.extensions) === null || _b === void 0 ? void 0 : _b.forEach(findReferences);
                (_c = type.properties) === null || _c === void 0 ? void 0 : _c.forEach((prop) => {
                    var _a, _b;
                    if (!(((_a = prop.type) === null || _a === void 0 ? void 0 : _a.isList()) || ((_b = prop.type) === null || _b === void 0 ? void 0 : _b.isOptional()))) {
                        findReferences(prop.type);
                    }
                });
            }
        }
    }
    /**
     * Scan this type for any type arguments or super-types that consist of TypeParameters.
     */
    hasTypeParameters() {
        var _a, _b, _c;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
            return true;
        }
        return (((_b = this.genericArguments) === null || _b === void 0 ? void 0 : _b.find((t) => t === null || t === void 0 ? void 0 : t.hasTypeParameters())) !== undefined ||
            ((_c = this.extensions) === null || _c === void 0 ? void 0 : _c.find((e) => e.hasTypeParameters())) !== undefined);
    }
    /**
     * A type has a catalog if it is a built-in or a custom slot type found in the interaction model.
     *
     * TODO: support catalog associations in ACDL https://github.com/alexa/ask-ac/issues/29
     */
    hasCatalog() {
        var _a, _b, _c;
        return (_c = (((_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(ast_1.BuiltinsNamespace)) || ((_b = this.namespace) === null || _b === void 0 ? void 0 : _b.startsWith(ast_1.SlotTypesNamespace)))) !== null && _c !== void 0 ? _c : false;
    }
    /**
     * A custom type is one that is not defined in:
     * 1. com.amazon.alexa.schema
     * 2. com.amazon.alexa.ask.conversations
     * 3. com.amazon.ask.types.builtins.AMAZON
     *
     * TODO: validate that users can't use these namespaces: https://github.com/alexa/ask-ac/issues/3
     */
    isCustom() {
        return !(this.isBuiltIn() || this.isAlexaSchema() || this.isCoreType());
    }
    /**
     * Checks if this is a built in type provided by the platform.
     *
     * Namespace:
     * `com.amazon.ask.types.builtins.AMAZON`
     *
     * TODO: should we also consider Alexa Schema as built-in?
     */
    isBuiltIn() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(ast_1.BuiltinsNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * @returns true if the type can be used as the result type of an utterance
     */
    isValidForUtterance() {
        return this.isBuiltIn() || this.isCoreType() || this.isAlexaSchema() || this.isSlotType();
    }
    /**
     * Checks if this is a valid UtteranceEvent wrapper type
     */
    isValidUtteranceWrapper() {
        return (!this.isPrimitive() || this.isNothing()) && !this.isBuiltIn();
    }
    /**
     * Checks if this type is defined in an interaction model.
     *
     * Namespace:
     * `com.amazon.ask.types.builtins.AMAZON`
     */
    isSlotType() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(ast_1.SlotTypesNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Checks if this type is defined in the AC core library.
     *
     * Namespace:
     * `com.amazon.alexa.ask.conversations`
     */
    isCoreType() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(ast_1.AlexaConversationsNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Checks if this type is defined in Alexa Schema.
     *
     * Namespace:
     * `com.amazon.alexa.schema`
     */
    isAlexaSchema() {
        var _a, _b;
        return (_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.startsWith(ast_1.AlexaSchemaNamespace)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Check if this type is the top-level Skill type.
     */
    isSkill() {
        var _a, _b;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === ast_1.AlexaConversations.Skill;
    }
    /**
     * Check if this type is the SkillLevelResponses type.
     */
    isSkillLevelResponses() {
        var _a, _b;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === ast_1.AlexaConversations.SkillLevelResponses;
    }
    /**
     * Check if this type is the InvocationName type.
     */
    isInvocationName() {
        var _a, _b;
        return ((_b = (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name) === ast_1.AlexaConversations.InvocationName;
    }
    /**
     * A complex type is one with at least one property.
     */
    isObject() {
        var _a, _b;
        return ((_b = (_a = this.properties) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0;
    }
    /**
     * Check if a name is (inclusively) found in this type's hierarchy.
     *
     * @param name name of type to find
     */
    isNameInHierarchy(name) {
        return this.findNameInHierarchy(name) !== undefined;
    }
    /**
     * Find a type by name in this type's hierarchy.
     *
     * E.g.
     * ```
     * looking for UtteranceEvent<T>
     *
     * // type is the one we're looking for
     * UtteranceEvent<T> => UtteranceEvent<T>
     *
     * // search the type's hierarchy.
     * type A : UtteranceEvent<String> => UtteranceEvent<String>
     *
     * // type does not exist
     * type B => undefined
     * ```
     *
     *
     * @param name name of the type to find
     */
    findNameInHierarchy(name) {
        var _a, _b, _c;
        if (name !== undefined) {
            if (((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined && typeof name === "function" ? name((_b = this.name) === null || _b === void 0 ? void 0 : _b.name) : ((_c = this.name) === null || _c === void 0 ? void 0 : _c.name) === name) {
                return this;
            }
            if (this.extensions) {
                for (const ext of this.extensions) {
                    const found = ext.findNameInHierarchy(name);
                    if (found) {
                        return found;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Check if this is the intrinsic `Properties<T>` type that computes the properties of some type, `T`.
     */
    isProperties() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Properties;
    }
    /**
     * Check if this is the intrinsic `Property<T>`.
     */
    isProperty() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Property;
    }
    /**
     * If this is a type `Property<T>`, return the inner type, `T`.
     */
    getPropertyTypeType() {
        var _a;
        if (this.isProperty()) {
            return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        }
        return undefined;
    }
    /**
     * Check if this is the `Type<T>` type.
     *
     * ```
     * type Person {
     *   String name
     * }
     *
     * // Type<Person>
     * person = Person
     * ```
     */
    isType() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Type;
    }
    /**
     * Get the type of the `Type<T>` type - in this case, `T`.
     *
     * ```
     * Type<Person> => Person
     * ```
     */
    getTypeType() {
        var _a, _b;
        if (this.isType()) {
            return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        }
        return (_b = this.findNameInHierarchy(ast_1.AlexaSchema.Type)) === null || _b === void 0 ? void 0 : _b.getTypeType();
    }
    /**
     * Is the `ReturnValue<T>` intrinsic type.
     */
    isReturnValue() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.ReturnValue;
    }
    /**
     * Get the type parameter of the `ReturnValue<T>`.
     */
    getReturnValueType() {
        var _a;
        return this.isReturnValue() ? (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0] : undefined;
    }
    /**
     * Is this Type `alexa.schema.Nothing` (the Bottom Type)?
     */
    isNothing() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Nothing;
    }
    /**
     * Is this Type `alexa.schema.Thing` (the Bottom Type)?
     */
    isThing() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Thing;
    }
    /**
     * Is this type `Nothing`, `Void`, `Boolean`, `Number`, `String`, `Date` or `Time`.
     */
    isPrimitive() {
        return this.isNothing() || this.isVoid() || this.isBoolean() || this.isNumber() || this.isStringLike();
    }
    /**
     * Is this type one of 'Request', 'ConfirmArgs', 'ConfirmAction', 'Notify', 'Offer', 'ReqAlt', 'Bye', 'ReqMore'.
     */
    isResponseAct() {
        return (this.isRequest() ||
            this.isConfirmArgs() ||
            this.isConfirmAction() ||
            this.isNotify() ||
            this.isOffer() ||
            this.isReqAlt() ||
            this.isBye() ||
            this.isReqMore());
    }
    /**
     * Is this the Void type, `com.amazon.alexa.schema.Void`?
     *
     * @version 1.0.0-beta2
     */
    isVoid() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Void;
    }
    /**
     * Is this type, `Optional<T>`?
     *
     * Also known as a union, `T | Void`.
     */
    isOptional() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Optional;
    }
    /**
     * Is this boolean type, `com.amazon.alexa.schema.Boolean`?
     */
    isBoolean() {
        return this.isNameInHierarchy(ast_1.AlexaSchema.Boolean);
    }
    /**
     * Is this boolean type, `com.amazon.alexa.schema.Boolean`?
     */
    isNumber() {
        return this.isNameInHierarchy(ast_1.AlexaSchema.Number);
    }
    /**
     * Is this a String-like Type?
     *
     * TODO: should Date and Time really be considered String-like?
     */
    isStringLike() {
        return this.isString() || this.isUtterance();
    }
    /**
     * is this type String or a sub-type of String.
     */
    isString() {
        return this.isNameInHierarchy(ast_1.AlexaSchema.String);
    }
    /**
     * Is this the core `com.amazon.alexa.ask.conversations.UtteranceEvent` type?
     */
    isUtteranceEvent() {
        return this.isNameInHierarchy(ast_1.AlexaConversations.UtteranceEvent);
    }
    /**
     * Get the UtteranceEvent's inner type.
     *
     * E.g.
     *
     * ```
     * UtteranceEvent<Person> => Person
     * ```
     */
    getUtteranceEventType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(ast_1.AlexaConversations.UtteranceEvent)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Is this the intrinsic `Utterance` type, representing a type-safe sample utterance string.
     *
     * ```
     * // UtteranceEvent<Person>
     * u = utterances<Person>(
     *   // List<Utterance<Person>>
     *   [
     *     // Utterance<Person>
     *     "i am {name}"
     *   ]
     * )
     * ```
     */
    isUtterance() {
        return this.isNameInHierarchy(ast_1.AlexaConversations.Utterance);
    }
    /**
     * Is this the intrinsic com.amazon.alexa.ask.conversations.Argument type representing an argument on some action.
     *
     * ```
     * action A(String arg)
     *
     * // Argument<String>
     * a = A.arguments.arg
     * ```
     */
    isArgument() {
        return this.isNameInHierarchy(ast_1.AlexaSchema.Argument);
    }
    /**
     * @returns the type `T` in `Argument<T>`.
     */
    getArgumentType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(ast_1.AlexaSchema.Argument)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Is this the intrinsic com.amazon.alexa.ask.conversations.Arguments type representing the arguments of some Action.
     *
     * ```
     * action A(String arg)
     *
     * // Arguments<A>
     * a = A.arguments
     * ```
     */
    isArguments() {
        return this.isNameInHierarchy(ast_1.AlexaSchema.Arguments);
    }
    /**
     * Get the item type of a parameterized List.
     *
     * ```
     * Utterance<Person> => (type) Person
     * utterances<Person>([
     *   "hello" => (type) Person
     * ])
     * ```
     *
     * @returns the item Type if this is a List, otherwise `undefined`.
     */
    getUtteranceType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(ast_1.AlexaConversations.Utterance)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Get the type of an Optional.
     *
     * ```
     * Optional<String> => (type) String
     * Optional<T> => (type parameter) T
     * ```
     */
    getOptionalType() {
        var _a;
        if (this.isOptional()) {
            return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0];
        }
        return undefined;
    }
    /**
     * If this is Optional<T> returns T else returns this
     * @returns
     */
    getNonOptionalType() {
        var _a;
        return this.isOptional() && ((_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[0]) ? this.genericArguments[0] : this;
    }
    /**
     * Checks if this type is the `Locale` enum type.
     */
    isLocale() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Locale;
    }
    /**
     * Checks if this type is the `AnnotationTarget` enum type.
     */
    isAnnotationTarget() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.AnnotationTarget;
    }
    /**
     * Checks if this is a type that extends the base Function type.
     *
     * Both Action and Dialog types extend Function.
     *
     * @returns
     */
    isFunction() {
        return this.findNameInHierarchy(ast_1.AlexaSchema.Function) !== undefined;
    }
    /**
     * Checks if this Type extends one of `FunctionN` functions where `N` is a numerical value representing
     * the number of arguments in the Function.
     */
    isFunctionN() {
        return this.getFunctionN() !== undefined;
    }
    /**
     * Gets the `FunctionN` type in this Type's hierarchy if this is of type `FunctionN` where `N` is a
     * numerical value representing the number of arguments in the Function.
     */
    getFunctionN() {
        return this.findNameInHierarchy((s) => s.startsWith(ast_1.AlexaSchema.Function) && s !== ast_1.AlexaSchema.Function);
    }
    /**
     * If this Type is a Function (Dialog or Action) then
     * @returns
     */
    getFunctionReturnType() {
        var _a, _b, _c, _d;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" || ((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "DialogDeclaration") {
            return this.checker.instantiateTypeReference(this.declaration.returnType);
        }
        if (this.isFunctionN()) {
            const functionN = this.getFunctionN();
            return (_c = functionN === null || functionN === void 0 ? void 0 : functionN.genericArguments) === null || _c === void 0 ? void 0 : _c[((_d = functionN === null || functionN === void 0 ? void 0 : functionN.genericArguments) === null || _d === void 0 ? void 0 : _d.length) - 1];
        }
        return undefined;
    }
    getFunctionArgumentType(index) {
        var _a, _b;
        return (_b = (_a = this.getFunctionN()) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[index];
    }
    getFunctionArgumentTypes() {
        var _a, _b, _c, _d, _e;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" || ((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "DialogDeclaration") {
            return (_c = this.declaration.arguments) === null || _c === void 0 ? void 0 : _c.map((arg) => this.checker.getType(arg));
        }
        if (this.isFunction()) {
            if (this.functionArgumentNames) {
                return this.functionArgumentNames.map((name, i) => { var _a; return (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[i]; });
            }
            // parse the value of N in a FunctionN/ActionN/DialogN.
            const nStr = (_d = this.shortName) === null || _d === void 0 ? void 0 : _d.replace(/[^0-9]/g, "");
            if (nStr) {
                const n = parseInt(nStr, 10);
                const args = [];
                for (let i = 0; i < n; i++) {
                    args.push((_e = this.genericArguments) === null || _e === void 0 ? void 0 : _e[i]);
                }
                return args;
            }
        }
        return undefined;
    }
    /**
     * Get the ArgumentDeclarations for this Type if the Type is a Function.
     */
    getFunctionArgumentDeclarations() {
        var _a, _b, _c, _d, _e, _f;
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" || ((_b = this.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "DialogDeclaration") {
            return this.declaration.arguments;
        }
        if (this.isFunction()) {
            if (this.functionArgumentNames) {
                return this.functionArgumentNames.map((name, i) => {
                    var _a, _b, _c;
                    const decl = new ask.ArgumentDeclaration(new ask.Name(name), (_b = (_a = this.genericArguments) === null || _a === void 0 ? void 0 : _a[i]) === null || _b === void 0 ? void 0 : _b.toTypeReference());
                    (_c = this.declaration) === null || _c === void 0 ? void 0 : _c.setAsParentOn(decl);
                    return decl;
                });
            }
            const nStr = (_c = this.shortName) === null || _c === void 0 ? void 0 : _c.replace(/[^0-9]/g, "");
            if (nStr) {
                const n = parseInt(nStr, 10);
                const args = [];
                for (let i = 0; i < n; i++) {
                    // BUG: we are moving the TypeReference to the TypeDeclaration so it has the wrong lexical scope.
                    const decl = new ask.ArgumentDeclaration(new ask.Name(`arg${i}`), (_e = (_d = this.genericArguments) === null || _d === void 0 ? void 0 : _d[i]) === null || _e === void 0 ? void 0 : _e.toTypeReference());
                    (_f = this.declaration) === null || _f === void 0 ? void 0 : _f.setAsParentOn(decl);
                    args.push(decl);
                }
                return args;
            }
        }
        return undefined;
    }
    /**
     * Takes two Function types and creates a mapping between their respective argument names based on position.
     *
     * This is the foundation on which we allow functions passed around as arguments to be compatible even
     * when they don't have the same argument names. We do not wish for argument names to be relevant for
     * the compatibility of functions.
     *
     * Ex. `foo.getFunctionArgumentDeclarationMappings(Foo)`:
     * ```
     * action String Foo(String arg)
     *
     * dialog Bar(
     *   action String foo(String str)
     * ) {
     *   sample {
     *     // here, foo's `str` will be mapped to Foo's `arg`.
     *     foo(str = "hello")
     *   }
     * }
     * ```
     *
     * @param other the other type we are mapping this argument's names to.
     * @returns resulting mappings will map from `this`'s argument names to `other`'s argument names.
     */
    getFunctionArgumentDeclarationMappings(other) {
        var _a;
        if (other === undefined || !(other.isFunction() && this.isFunction())) {
            return undefined;
        }
        const thisArgs = this.getFunctionArgumentDeclarations();
        if (thisArgs === undefined) {
            return undefined;
        }
        return (_a = other
            .getFunctionArgumentDeclarations()) === null || _a === void 0 ? void 0 : _a.map((arg, i) => {
            var _a, _b;
            const argDecl = thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs[i];
            if (((_a = argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === null || _a === void 0 ? void 0 : _a.name) && ((_b = arg.name) === null || _b === void 0 ? void 0 : _b.name)) {
                return {
                    [argDecl.name.name]: arg.name.name,
                };
            }
            return {};
        }).reduce((a, b) => ({ ...a, ...b }), {});
    }
    /**
     * Checks if this type is an DialogDeclaration.
     */
    isDialogDeclaration() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "DialogDeclaration";
    }
    /**
     * Checks if this type is an DialogDeclaration.
     */
    isDialog() {
        return this.findNameInHierarchy(ast_1.AlexaConversations.Dialog) !== undefined;
    }
    /**
     * Checks if this type is a fully qualified ActionDeclaration.
     */
    isActionDeclaration() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration";
    }
    isAction() {
        return this.findNameInHierarchy(ast_1.AlexaConversations.Action) !== undefined;
    }
    /**
     * Checks if this is a type
     * @returns
     */
    isEnum() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "EnumDeclaration";
    }
    /**
     * Checks if this is a Type representing an item in an `enum`.
     * @returns
     */
    isEnumItem() {
        var _a;
        return ((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "EnumItemDeclaration";
    }
    /**
     * Is this `com.amazon.alexa.ask.conversations.Args` or a sub-type.
     *
     * This type represents var args in an Action.
     *
     * ```
     * action void A(Args<String>)
     *
     * a = A(
     *   "no need",
     *   "to surround these with",
     *   "[ and ]"
     * )
     * ```
     */
    isArgs() {
        return this.isNameInHierarchy(ast_1.AlexaConversations.Args);
    }
    /**
     * Does this Type extend `alexa.schema.List`.
     */
    isList() {
        return this.isNameInHierarchy(ast_1.AlexaSchema.List);
    }
    isTaskContextProjection() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.TaskContextProjection;
    }
    isTaskContextProjectionType() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.TaskContextProjectionType;
    }
    isTaskContextProjectionAnnotation() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.taskContextProjection;
    }
    isTaskContextProjectionInfo() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.TaskContextProjectionInfo;
    }
    /**
     * Is this type one of 'Invoke', 'Inform', 'Affirm', 'Deny', 'RequestAct'.
     */
    isRequestAct() {
        var _a;
        return this.isInvoke() || this.isInform() || this.isAffirm() || this.isDeny() || ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.RequestAct;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Invoke"
     */
    isInvoke() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Invoke;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Inform"
     */
    isInform() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Inform;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Affirm"
     */
    isAffirm() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Affirm;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Deny"
     */
    isDeny() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Deny;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Offer"
     */
    isOffer() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Offer;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqAlt"
     */
    isReqAlt() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ReqAlt;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqMore"
     */
    isReqMore() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ReqMore;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Request"
     */
    isRequest() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Request;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Request"
     */
    isRequestArguments() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.RequestArguments;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ConfirmAction"
     */
    isConfirmAction() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ConfirmAction;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqMore"
     */
    isConfirmArgs() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ConfirmArgs;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.ReqMore"
     */
    isConfirmArguments() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ConfirmArguments;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Bye"
     */
    isBye() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Bye;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.Notify"
     */
    isNotify() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Notify;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.APLA"
     */
    isApla() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.APLA;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.MultiModalResponse"
     */
    isMultiModalResponse() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.MultiModalResponse;
    }
    /**
     * Is this type "com.amazon.alexa.ask.conversations.APL"
     */
    isApl() {
        var _a;
        return ((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.APL;
    }
    /**
     * Get the item type of a parameterized List.
     *
     * ```
     * List<String> => (type) String
     * List<T> => (type parameter) T
     * ```
     *
     * @returns the item Type if this is a List, otherwise `undefined`.
     */
    getListItemType() {
        var _a, _b;
        return (_b = (_a = this.findNameInHierarchy(ast_1.AlexaSchema.List)) === null || _a === void 0 ? void 0 : _a.genericArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    /**
     * Check if this type is a sub-type (or same type) as a `baseType`.
     *
     * A type, `A` extends another type, `B` if `A & B == B`.
     *
     * In other words, the intersection of A and B should be exactly B.
     *
     * @param baseType base type
     */
    extends(baseType) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        if (baseType === undefined) {
            return false;
        }
        if (this.isNothing()) {
            // Nothing is a sub type of all Things
            return true;
        }
        if (baseType.isThing()) {
            // Thing is the base type of all Things.
            return true;
        }
        if (this.isVoid() && baseType.isOptional()) {
            return true;
        }
        if (this.isVoid() && baseType.isNothing()) {
            // for backwards compatibility, we will equate `Nothing` and `Void`.
            return true;
        }
        if ((((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration" && ((_b = baseType.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration") ||
            (((_c = this.declaration) === null || _c === void 0 ? void 0 : _c.kind) === "DialogDeclaration" && ((_d = baseType.declaration) === null || _d === void 0 ? void 0 : _d.kind) === "DialogDeclaration")) {
            // if we are comparing literal actions/dialogs, then their name must be identical regardless of compatibility
            // we still uphold nominal rules when comparing static references.
            return ((_e = this.declaration.name) === null || _e === void 0 ? void 0 : _e.name) === ((_f = baseType.declaration.name) === null || _f === void 0 ? void 0 : _f.name);
        }
        if (this.isFunctionN() && baseType.isFunctionN()) {
            if (baseType.isAction() && !this.isAction()) {
                return false;
            }
            if (baseType.isDialog() && !this.isDialog()) {
                return false;
            }
            const thisArgs = (_g = this.getFunctionN()) === null || _g === void 0 ? void 0 : _g.getFunctionArgumentTypes();
            const baseTypeArgs = (_h = baseType.getFunctionN()) === null || _h === void 0 ? void 0 : _h.getFunctionArgumentTypes();
            if (!((_k = (_j = this.getFunctionReturnType()) === null || _j === void 0 ? void 0 : _j.extends(baseType.getFunctionReturnType())) !== null && _k !== void 0 ? _k : false)) {
                // return types are co-variant, this function's return type must extend the base function's return type
                return false;
            }
            // Lengths are different, lets check the extraneous arguments in baseType and ensure they're optional
            if ((thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs.length) !== (baseTypeArgs === null || baseTypeArgs === void 0 ? void 0 : baseTypeArgs.length) && (baseTypeArgs === null || baseTypeArgs === void 0 ? void 0 : baseTypeArgs.length)) {
                const startArgPos = (_l = thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs.length) !== null && _l !== void 0 ? _l : 0;
                for (let i = startArgPos; i < baseTypeArgs.length; i++) {
                    if (!baseTypeArgs[i].isOptional() || !baseTypeArgs[i].isArgs()) {
                        return false;
                    }
                }
            }
            return ((_m = thisArgs === null || thisArgs === void 0 ? void 0 : thisArgs.map((thisArg, i) => {
                const otherArg = baseTypeArgs === null || baseTypeArgs === void 0 ? void 0 : baseTypeArgs[i];
                if (otherArg === undefined) {
                    return thisArg.isOptional() || thisArg.isArgs();
                }
                // arguments are contra-variant, the base type's argument must be a super-type of this function's argument.
                return otherArg.extends(thisArg);
            }).reduce((a, b) => a && b, true)) !== null && _m !== void 0 ? _m : false);
        }
        if (((_o = this.name) === null || _o === void 0 ? void 0 : _o.name) === ((_p = baseType.name) === null || _p === void 0 ? void 0 : _p.name)) {
            if (this.genericArguments) {
                if (this.genericArguments.length === ((_q = baseType.genericArguments) === null || _q === void 0 ? void 0 : _q.length)) {
                    return this.genericArguments.find((genericArg, i) => (genericArg === null || genericArg === void 0 ? void 0 : genericArg.extends(baseType === null || baseType === void 0 ? void 0 : baseType.genericArguments[i])) !== true) === undefined;
                }
                return false;
            }
            return true;
        }
        // Check optional types, we currently allow Optional<T> as assignable to T.
        if (baseType.isOptional()) {
            return this.extends(baseType.getOptionalType());
        }
        else if (this.isOptional()) {
            return (_s = (_r = this.getOptionalType()) === null || _r === void 0 ? void 0 : _r.extends(baseType)) !== null && _s !== void 0 ? _s : false;
        }
        return ((_t = this.extensions) === null || _t === void 0 ? void 0 : _t.find((extension) => (extension === null || extension === void 0 ? void 0 : extension.extends(baseType)) === true)) !== undefined;
    }
    /**
     * Check if two instantiated types are identical.
     *
     * @param other
     */
    equals(other) {
        var _a;
        if (this.name !== undefined && this.name === other.name) {
            if (this.genericArguments !== undefined && this.genericArguments.length === ((_a = other.genericArguments) === null || _a === void 0 ? void 0 : _a.length)) {
                for (let i = 0; i < this.genericArguments.length; i++) {
                    const _this = this.genericArguments[i];
                    const _other = other.genericArguments[i];
                    if (_this === undefined || _other === undefined) {
                        return false;
                    }
                    if (!_this.equals(_other)) {
                        return false;
                    }
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Get the union of this type and another. We only have limited support for unions at this time.
     *
     * Rules:
     * 1. Void | Void = Void
     * 2. Nothing | T = T
     * 3. Void | T = Optional<T>
     * 4. Optional<T> | T = Optional<T>
     * 5. A | B = A & B
     *
     * RE: Rule #5 - when two non-Optional or Void types are unioned, we take their intersection. I.e. we
     * reduce their type to their most common denominator. We will change this once we add full support for
     * union types.
     *
     * @param other other type to union this type with
     * @returns the unioned type.
     */
    union(other) {
        var _a, _b;
        if (other === undefined) {
            return this;
        }
        if (this.equals(other)) {
            return this;
        }
        if (this.isNothing()) {
            return other;
        }
        if (other === null || other === void 0 ? void 0 : other.isNothing()) {
            return this;
        }
        if (this.isVoid() && (other === null || other === void 0 ? void 0 : other.isVoid())) {
            return this;
        }
        if (this.isVoid()) {
            return new Type(this.checker, this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Optional), [other]);
        }
        if (other.isVoid()) {
            return new Type(this.checker, this.checker.lookupTypeDeclaration(ast_1.AlexaSchema.Optional), [this]);
        }
        if (this.isOptional()) {
            return this.checker.void.union((_a = this.getOptionalType()) === null || _a === void 0 ? void 0 : _a.union(other));
        }
        if (other.isOptional()) {
            return this.checker.void.union((_b = other.getOptionalType()) === null || _b === void 0 ? void 0 : _b.union(this));
        }
        return this.intersect(other);
        // return this.getIntersection(other);
    }
    intersect(other) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (this.isNothing() || (other === null || other === void 0 ? void 0 : other.isNothing())) {
            return this.checker.nothing;
        }
        if (other === undefined) {
            return undefined;
        }
        if (((_a = this.name) === null || _a === void 0 ? void 0 : _a.name) === ((_b = other.name) === null || _b === void 0 ? void 0 : _b.name)) {
            if (((_c = this.genericArguments) === null || _c === void 0 ? void 0 : _c.length) === 0 && ((_d = other.genericArguments) === null || _d === void 0 ? void 0 : _d.length) === 0) {
                return this;
            }
            if (((_e = this.genericArguments) === null || _e === void 0 ? void 0 : _e.length) === ((_f = other.genericArguments) === null || _f === void 0 ? void 0 : _f.length)) {
                const genericArguments = (_g = this.genericArguments) === null || _g === void 0 ? void 0 : _g.map((genericArg, i) => { var _a, _b; return (_b = genericArg === null || genericArg === void 0 ? void 0 : genericArg.intersect((_a = other.genericArguments) === null || _a === void 0 ? void 0 : _a[i])) !== null && _b !== void 0 ? _b : this.checker.thing; });
                return new Type(this.checker, this.declaration, genericArguments);
            }
        }
        else if (this.extends(other)) {
            for (const ext of (_h = this.extensions) !== null && _h !== void 0 ? _h : []) {
                if (ext.extends(other)) {
                    return ext.intersect(other);
                }
            }
        }
        else if (other.extends(this)) {
            for (const ext of (_j = other.extensions) !== null && _j !== void 0 ? _j : []) {
                if (ext.extends(this)) {
                    return ext.intersect(this);
                }
            }
        }
        else {
            for (const thisExt of (_k = this.extensions) !== null && _k !== void 0 ? _k : []) {
                for (const otherExt of (_l = other.extensions) !== null && _l !== void 0 ? _l : []) {
                    if (thisExt.extends(otherExt)) {
                        return thisExt.intersect(otherExt);
                    }
                }
            }
        }
        return this.checker.thing;
    }
    narrow(other) {
        if (other === undefined) {
            return this;
        }
        if (other.extends(this)) {
            // if the other type is more narrow, choose it
            return other;
        }
        if (this.extends(other)) {
            // if this type is more general, choose the other
            return this;
        }
        // these types have no intersection, this case is impossible.
        return this.checker.nothing;
    }
    /**
     * Find all locales this type support
     * E.G.
     * assume slotType deOnlySlot is only available in de_DE IM, sloType commonSlotType exist in both de_DE and en_US IM
     * ```
     * type myType {
     *  optional String id
     *  optional deOnlySlot german
     * }
     * getLocales() => ["de_DE"]
     * ```
     *
     * when type have nested type
     * ```
     * type complexType {
     *   myType name1
     *   optional commonSlotType name2
     * }
     *
     * getLocales() => ["de_DE"]
     * // only return de_DE cause this is the only overlap part of deOnlySlot and commonSlotType
     * ```
     * @returns
     */
    getLocales() {
        if (__classPrivateFieldGet(this, _Type_locales, "f") !== undefined) {
            return __classPrivateFieldGet(this, _Type_locales, "f");
        }
        const slotTypes = new Set();
        const seen = new Set();
        // Find all slotTypes this type depends on
        if (this.isSlotType()) {
            slotTypes.add(this.declaration);
        }
        else {
            // recursively look up the child types
            (0, visit_1.visitEachChildType)(this, function collectSlotType(type) {
                var _a;
                if (type.declaration && !seen.has(type.toString())) {
                    seen.add(type.toString());
                    if (((_a = type.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "SlotType") {
                        slotTypes.add(type.declaration);
                    }
                    (0, visit_1.visitEachChildType)(type, collectSlotType);
                }
            });
        }
        // calculate the overlap locales that all slotTypes support
        let locales;
        for (const slotType of slotTypes.values()) {
            if (!locales) {
                locales = [...slotType.locales];
            }
            else {
                locales = locales.filter((locale) => slotType.locales.includes(locale));
            }
        }
        __classPrivateFieldSet(this, _Type_locales, locales, "f");
        return __classPrivateFieldGet(this, _Type_locales, "f");
    }
    /**
     * Gets a map of required property names to properties in this.properties
     * @returns a map of required property names to properties in this.properties
     */
    getRequiredProperties() {
        var _a;
        return new Map((_a = this.properties) === null || _a === void 0 ? void 0 : _a.reduce((acc, property) => {
            var _a, _b, _c;
            if (((_a = property.type) === null || _a === void 0 ? void 0 : _a.isOptional()) || (((_b = property.declaration) === null || _b === void 0 ? void 0 : _b.kind) === "TypeProperty" && ((_c = property.declaration) === null || _c === void 0 ? void 0 : _c.optional) === true)) {
                return acc;
            }
            acc.push([property.name, property]);
            return acc;
        }, []));
    }
    /**
     * Gets a map of property names to corresponding properties
     * @returns a map of property names to corresponding properties
     */
    getPropertyMap() {
        var _a;
        return new Map(((_a = this.properties) !== null && _a !== void 0 ? _a : []).map((property) => [property.name, property]));
    }
    /**
     * Retrieves generic arguments nested in a Type declaration of the form Apply<Optional<T>,K>.
     * For such type this will return an array with two elements, a type object corresponding to T
     * and a type object corresponding to K.
     */
    getNestedGenericArguments() {
        var _a, _b;
        // This is the recursion termination case for when we reach T in  Action1<Optional<T>, Nothing>
        if (((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
            return [this];
        }
        const typeGenericArguments = (_b = this.genericArguments) !== null && _b !== void 0 ? _b : [];
        if (typeGenericArguments.length === 0) {
            // This is a special case found in Action1<Optional<T>, Nothing>. Nothing has no
            // nested generic arguments so we just return a type object corresponding to Nothing
            return [this];
        }
        // Call getNestedGenericArguments recursively on each of this.genericArguents
        const returnValue = [];
        for (const typeGenericArgument of typeGenericArguments) {
            if (!typeGenericArgument) {
                continue;
            }
            returnValue.push(...typeGenericArgument.getNestedGenericArguments());
        }
        return returnValue;
    }
}
exports.Type = Type;
_Type_environment = new WeakMap(), _Type_extensions = new WeakMap(), _Type_properties = new WeakMap(), _Type_propertiesIndex = new WeakMap(), _Type_locales = new WeakMap();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90eXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTZCO0FBRTdCLG1DQUE4QjtBQUM5QiwrQkFTZTtBQUdmLGlDQUE2QztBQUU3QyxtQ0FlaUI7QUFFakIsbUNBQTJDO0FBRTNDLFNBQWdCLE1BQU0sQ0FBQyxHQUFRO0lBQzdCLE9BQU8sQ0FBQSxHQUFHLGFBQUgsR0FBRyx1QkFBSCxHQUFHLENBQUUsSUFBSSxNQUFLLE1BQU0sQ0FBQztBQUM5QixDQUFDO0FBRkQsd0JBRUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFhLElBQUk7SUFHZixZQUNXLE9BQW9CO0lBQzdCOztPQUVHO0lBQ00sV0FRWTtJQUNyQjs7T0FFRztJQUNNLGdCQUF1QztJQUNoRDs7T0FFRztJQUNILDhCQUE4QjtJQUNyQixxQkFBZ0M7SUFDekM7O09BRUc7SUFDTSxZQUFxQjs7Ozs7bUJBekJyQjs7Ozs7O21CQUlBOzs7Ozs7bUJBWUE7Ozs7OzttQkFLQTs7Ozs7O21CQUlBOztRQTVCWDs7OzttQkFBd0IsTUFBTTtXQUFDO1FBd0YvQixtRkFBbUY7UUFDbkYsb0NBQWlDO1FBMkJqQywwRkFBMEY7UUFDMUYsbUNBQXVDO1FBeUV2QyxrRkFBa0Y7UUFDbEYsbUNBQWdDO1FBNktoQyxzRkFBc0Y7UUFDdEYsd0NBQThEO1FBcXFDOUQsa0ZBQWtGO1FBQ2xGLGdDQUFvQztJQXQvQ2pDLENBQUM7SUFFSjs7T0FFRztJQUNJLFFBQVEsQ0FBQyxPQUE4Qjs7UUFDNUMsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFDdkYsTUFBTSxJQUFJLEdBQ1IsQ0FBQSxP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