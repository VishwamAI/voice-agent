"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PropertyNode = void 0;
const _1 = require(".");
/**
 * Node in a tree useful to validate property paths in an utterance. See buildPropertyTree for details.
 */
class PropertyNode {
    /**
     *
     * @param property a Property in a type
     * @param propertyType the corresponding propertyType
     * @param children nodes corresponding to propertyType.Properties
     */
    constructor(property, propertyType, children = new Map()) {
        Object.defineProperty(this, "property", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: property
        });
        Object.defineProperty(this, "propertyType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: propertyType
        });
        Object.defineProperty(this, "children", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: children
        });
    }
    /**
     * Out of a string in Utterances<MealOrderType> like:
     *  'I want a {pizzaOrder.size} {pizzaOrder.pizzaType} pizza and a {drinkOrder.size} {drinkOrder.drinkType} drink'
     * This will build a tree like seen below where each Parenthesis is a Property with the given name and type:
     *
     *                                                    ('', MealOrderType)
     *
     *                 ('pizzaOrder', PizzaOrderType)                                      ('drinkOrder', DrinkOrderType)
     *
     *     ('pizzaType' ,PizzaType)          ('size', PizzaSizeType)             ('drinkType', DrinkType)        ('size', DrinkSizeType)
     *
     * In the process of building the tree 'no such property' errors can be produced.
     * With the tree, at each node, we can verify if the required properties have been specified
     * @param propertyPaths each ask.Name contains dot separate property path like 'pizzaOrder.size' plus its location for error messages.
     * @param type the type where all the first segments in propertyPaths are supposed to belong to.
     * @param context used for type's toString
     * @param getPropertyMap memoized type's getPropertyMap
     * @returns errors and the root of the tree
     */
    static buildPropertyTree(propertyPaths, type, context, getPropertyMap) {
        var _a, _b;
        const errors = [];
        const root = new PropertyNode({ name: "", type, kind: "Property", index: 0 }, type);
        for (const propertyPath of propertyPaths) {
            const segments = ((_a = propertyPath.name) !== null && _a !== void 0 ? _a : "").split(".");
            let currentType = type;
            let currentNode = root;
            let propertyFound = true;
            for (const segment of segments) {
                const propertyToTypes = getPropertyMap(currentType);
                const segmentProperty = propertyToTypes.get(segment);
                const segmentType = segmentProperty === null || segmentProperty === void 0 ? void 0 : segmentProperty.type;
                if (!segmentProperty) {
                    propertyFound = false;
                    errors.push(_1.ValidationErrorFactory.UnknownProperty({
                        expr: propertyPath,
                        attributes: {
                            propertyName: segment,
                            typeName: currentType.toString(context),
                        },
                    }));
                    continue;
                }
                if (!segmentType) {
                    propertyFound = false;
                    errors.push(_1.ValidationErrorFactory.NameNotFoundInUtteranceValue({
                        expr: propertyPath,
                        attributes: {
                            value: segment,
                        },
                    }));
                    continue;
                }
                let segmentNode = currentNode.children.get(segment);
                if (!segmentNode) {
                    segmentNode = new PropertyNode(segmentProperty, segmentType);
                    currentNode.children.set(segment, segmentNode);
                }
                currentType = segmentType.getNonOptionalType();
                currentNode = segmentNode;
            }
            const elementType = currentType.isList()
                ? currentType.getListItemType()
                : currentType.isOptional()
                    ? currentType.getNonOptionalType()
                    : currentType;
            const isTypeValid = (elementType === null || elementType === void 0 ? void 0 : elementType.isBuiltIn()) || (elementType === null || elementType === void 0 ? void 0 : elementType.isCoreType()) || (elementType === null || elementType === void 0 ? void 0 : elementType.isAlexaSchema()) || (elementType === null || elementType === void 0 ? void 0 : elementType.isSlotType());
            if (propertyFound && !(elementType === null || elementType === void 0 ? void 0 : elementType.isValidForUtterance())) {
                errors.push(_1.ValidationErrorFactory.UndefinedCatalogCustomType({
                    expr: propertyPath,
                    attributes: {
                        propertyName: (_b = propertyPath.name) !== null && _b !== void 0 ? _b : "",
                        propertyType: elementType === null || elementType === void 0 ? void 0 : elementType.toString(propertyPath),
                    },
                }));
            }
        }
        return { errors, root };
    }
}
exports.PropertyNode = PropertyNode;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvcGVydHktbm9kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcm9wZXJ0eS1ub2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHdCQUFxRDtBQUtyRDs7R0FFRztBQUNILE1BQWEsWUFBWTtJQUN2Qjs7Ozs7T0FLRztJQUNILFlBQXFCLFFBQWtCLEVBQVcsWUFBa0IsRUFBVyxXQUFXLElBQUksR0FBRyxFQUF3Qjs7Ozs7bUJBQXBHOzs7Ozs7bUJBQTZCOzs7Ozs7bUJBQTZCOztJQUE2QyxDQUFDO0lBRTdIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkc7SUFDSSxNQUFNLENBQUMsaUJBQWlCLENBQzdCLGFBQXlCLEVBQ3pCLElBQVUsRUFDVixPQUE2QixFQUM3QixjQUFxRDs7UUFFckQsTUFBTSxNQUFNLEdBQWlCLEVBQUUsQ0FBQztRQUNoQyxNQUFNLElBQUksR0FBRyxJQUFJLFlBQVksQ0FBQyxFQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2xGLEtBQUssTUFBTSxZQUFZLElBQUksYUFBYSxFQUFFO1lBQ3hDLE1BQU0sUUFBUSxHQUFHLENBQUMsTUFBQSxZQUFZLENBQUMsSUFBSSxtQ0FBSSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdEQsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDO1lBQ3ZCLElBQUksV0FBVyxHQUFHLElBQUksQ0FBQztZQUN2QixJQUFJLGFBQWEsR0FBRyxJQUFJLENBQUM7WUFDekIsS0FBSyxNQUFNLE9BQU8sSUFBSSxRQUFRLEVBQUU7Z0JBQzlCLE1BQU0sZUFBZSxHQUFHLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDcEQsTUFBTSxlQUFlLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztn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