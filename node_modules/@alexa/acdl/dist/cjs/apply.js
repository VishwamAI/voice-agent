"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Apply = void 0;
const immutable_1 = __importDefault(require("immutable"));
const ask = __importStar(require("./ast"));
const ast_1 = require("./ast");
const constants_1 = require("./constants");
const type_1 = require("./type");
const responseInfo_1 = require("./responseInfo");
const util_1 = require("./util");
/**
 * An Apply represents a Call to an Action, Dialog or Type.
 *
 * This class provides a lazily-evaluated API for querying this call's AST
 * for type checking and type inference.
 */
class Apply {
    constructor(checker, call, decl, prev, returnType, argumentIndex, genericEnvironment, genericArguments) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        Object.defineProperty(this, "checker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: checker
        });
        Object.defineProperty(this, "call", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: call
        });
        Object.defineProperty(this, "decl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: decl
        });
        Object.defineProperty(this, "kind", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Apply"
        });
        Object.defineProperty(this, "argumentDeclarations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "argumentDeclIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "requiredArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "returnType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "arguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "genericEnvironment", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "genericArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (prev) {
            this.argumentDeclarations = prev.argumentDeclarations;
            this.argumentDeclIndex = prev.argumentDeclIndex;
            this.requiredArguments = prev.requiredArguments;
            this.returnType = returnType;
            this.arguments = argumentIndex;
            this.genericEnvironment = genericEnvironment;
            this.genericArguments = genericArguments;
        }
        else {
            if (decl.kind === "Type") {
                if (decl.isFunction()) {
                    this.argumentDeclarations = decl.getFunctionArgumentDeclarations();
                }
                else {
                    this.argumentDeclarations = decl.properties;
                }
            }
            else if (decl.kind === "TypeDeclaration") {
                this.argumentDeclarations = (_b = (_a = this.checker.instantiateTypeDeclaration(decl)) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.map((prop) => {
                    var _a, _b, _c;
                    const arg = new ask.ArgumentDeclaration(new ask.Name(prop.name), (_a = prop.type) === null || _a === void 0 ? void 0 : _a.toTypeReference(), undefined, (_c = (_b = prop.declaration) === null || _b === void 0 ? void 0 : _b.annotations) === null || _c === void 0 ? void 0 : _c.map((a) => a.clone()), undefined);
                    decl.setAsParentOn(arg);
                    return arg;
                });
            }
            else {
                this.argumentDeclarations = decl.arguments;
            }
            if (this.argumentDeclarations) {
                (_c = this.argumentDeclarations) === null || _c === void 0 ? void 0 : _c.map((argDecl, index) => {
                    var _a;
                    const argName = typeof (argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === "string" ? argDecl.name : (_a = argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === null || _a === void 0 ? void 0 : _a.name;
                    if (argName) {
                        this.argumentDeclIndex[argName] = argDecl;
                        this.argumentDeclIndex[index] = argDecl;
                    }
                });
            }
            const required = [];
            if (this.argumentDeclarations) {
                for (const arg of this.argumentDeclarations) {
                    const argName = typeof arg.name === "string" ? arg.name : (_d = arg.name) === null || _d === void 0 ? void 0 : _d.name;
                    if (argName && arg.type) {
                        if (arg.kind === "Property" &&
                            !arg.type.isOptional() &&
                            !arg.type.isArgs() &&
                            ((_e = arg.declaration) === null || _e === void 0 ? void 0 : _e.kind) === "TypeProperty" &&
                            ((_f = arg.declaration) === null || _f === void 0 ? void 0 : _f.optional) !== true) {
                            required.push(argName);
                        }
                        else if (arg.kind === "ArgumentDeclaration" &&
                            checker.qualifyName(arg, (_g = arg.type.name) === null || _g === void 0 ? void 0 : _g.name) !== ast_1.AlexaSchema.Optional &&
                            checker.qualifyName(arg, (_h = arg.type.name) === null || _h === void 0 ? void 0 : _h.name) !== ast_1.AlexaConversations.Args &&
                            arg.defaultExpression === undefined) {
                            required.push(argName);
                        }
                    }
                }
            }
            this.requiredArguments = [...required];
        }
    }
    /**
     * Instantiate this static Apply instance within a local TypeChecker environment.
     *
     * @param localChecker the new environment in which to instantiate the Apply.
     */
    instantiate(localChecker) {
        var _a, _b, _c;
        if (this.isList()) {
            return (_a = resolveType(this.getReturnType())) === null || _a === void 0 ? void 0 : _a.apply(this.call, localChecker);
        }
        const actionLocal = localChecker.getThing(this.checker.lookupCallDeclaration(this.call));
        if (actionLocal === undefined || actionLocal.origin === undefined || actionLocal.origin.kind === "ArgumentDeclaration") {
            // we only support instantiating actions for concrete Action/Dialog Declaration expressions.
            return undefined;
        }
        return new Apply(localChecker, this.call, actionLocal.origin, this, resolveType(this.getReturnType()), this.getArguments(), undefined, // this.getGenericEnvironment(),
        (_c = (_b = this.getGenericArguments()) === null || _b === void 0 ? void 0 : _b.map((t) => resolveType(t))) !== null && _c !== void 0 ? _c : null);
        // resolve type parameters
        function resolveType(type, hasTypeParameters = type === null || type === void 0 ? void 0 : type.hasTypeParameters()) {
            var _a, _b, _c, _d;
            if (type === undefined) {
                return undefined;
            }
            if (hasTypeParameters === false) {
                return type;
            }
            if (((_a = type.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
                return (_c = (_b = localChecker.types) === null || _b === void 0 ? void 0 : _b.get(type.declaration)) !== null && _c !== void 0 ? _c : type;
            }
            return new type_1.Type(type.checker, type.declaration, (_d = type.genericArguments) === null || _d === void 0 ? void 0 : _d.map((t) => resolveType(t, hasTypeParameters)), type.functionArgumentNames);
        }
    }
    isList() {
        return this.decl.kind === "Type" && this.decl.isList();
    }
    getListItems() {
        if (this.isList() && ask.isListLiteral(this.call.arguments)) {
            return this.call.arguments.items.map((item) => item.item);
        }
        return undefined;
    }
    isArgs() {
        return this.decl.kind === "Type" && this.decl.isArgs();
    }
    isType() {
        return (this.decl.kind === "Type" && !this.decl.isFunction()) || this.decl.kind === "TypeDeclaration";
    }
    isIs() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.is;
    }
    isIsInCatalog() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.isInCatalog;
    }
    isIn() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.in;
    }
    isWhen() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.when;
    }
    isEq() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Eq;
    }
    isNeq() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Neq;
    }
    isAnd() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.And;
    }
    isOr() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Or;
    }
    isNot() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Not;
    }
    isGt() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Gt;
    }
    isGte() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Gte;
    }
    isLt() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Lt;
    }
    isLte() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Lte;
    }
    /**
     * Check if this call is to the `com.amazon.alexa.ask.conversations.skill` action.
     */
    isSkillAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.skill;
    }
    /**
     * Check if this call is to the `com.amazon.alexa.ask.conversations.Skill` type.
     */
    isSkillType() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Skill;
    }
    /**
     * Checks if this apply is targeting the core `annotation` action.
     */
    isAnnotationAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.annotation;
    }
    /**
     * Checks if the target of this Apply is an action annotated with the `@annotation` meta-annotation?
     */
    isAnnotation() {
        var _a;
        return (this.isAction() &&
            this.decl.kind === "ActionDeclaration" &&
            ((_a = this.decl.annotations) === null || _a === void 0 ? void 0 : _a.find((a) => this.checker.qualifyName(this.decl, a.call.name) === ast_1.AlexaConversations.annotation)) !== undefined);
    }
    /**
     * Get the `allowMultiple` field from an instance of the meta-annotation, `com.amazon.alexa.ask.conversations.Annotation`.
     *
     * @returns true/false if this is an instance of `Annotation`, otherwise `undefined.
     */
    getAnnotationAllowMultiple() {
        if (this.isAnnotationAction()) {
            const allowMultiple = this.getArgumentValueAndResolveToCallIfNameRef("allowMultiple");
            if ((allowMultiple === null || allowMultiple === void 0 ? void 0 : allowMultiple.kind) === "Call" && typeof allowMultiple.arguments === "boolean") {
                return allowMultiple.arguments;
            }
            return false;
        }
        return undefined;
    }
    /**
     * Get the `targets` field if this is a call to the meta-annotation, `com.amazon.alexa.ask.conversations.Annotation`.
     *
     * Ex.
     * ```
     * // returns [AnnotationTarget.Type]
     * @Annotation(targets = [AnnotationTarget.Type])
     * ..
     * ```
     */
    getAnnotationTargets() {
        if (this.isAnnotationAction()) {
            const annotationTargets = this.getArgumentValueAndResolveToCallIfNameRef("targets");
            if ((annotationTargets === null || annotationTargets === void 0 ? void 0 : annotationTargets.kind) === "Call" && ask.isListLiteral(annotationTargets.arguments)) {
                return annotationTargets.arguments.items
                    .map((item) => {
                    var _a, _b, _c, _d;
                    if (((_a = item.item) === null || _a === void 0 ? void 0 : _a.kind) === "PropertyReference") {
                        const name = (_b = item.item.name) === null || _b === void 0 ? void 0 : _b.name;
                        const exprType = this.checker.getType(item.item.expression);
                        // if this is a reference to `enum AnnotationTarget`, then its type should be `Type<AnnotationTarget>`.
                        const isAnnotationTargetEnum = (exprType === null || exprType === void 0 ? void 0 : exprType.isType()) && ((_c = exprType.getTypeType()) === null || _c === void 0 ? void 0 : _c.isAnnotationTarget()); // getTypeType() => AnnotationTarget type
                        if (isAnnotationTargetEnum && (0, ast_1.isAnnotationTarget)(name)) {
                            // ex. AnnotationTarget.Dialog
                            // name => Dialog
                            // exprType => Type<AnnotationTarget>
                            // yields AnnotationTarget.Dialog
                            return name;
                        }
                    }
                    else if (((_d = item.item) === null || _d === void 0 ? void 0 : _d.kind) === "NameReference") {
                    }
                    return undefined;
                })
                    .filter((t) => t !== undefined);
            }
        }
        return undefined;
    }
    isAction() {
        return this.decl.kind === "ActionDeclaration" || (this.decl.kind === "Type" && this.decl.isAction());
    }
    isBuiltin() {
        var _a, _b;
        return ((_b = (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.startsWith(ast_1.AlexaConversationsNamespace)) || false;
    }
    isUserDefinedApi() {
        var _a;
        return (this.isAction() || (this.decl.kind === "Type" && ((_a = this.decl.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "ActionDeclaration")) && !this.isBuiltin();
    }
    isDialog() {
        return this.decl.kind === "DialogDeclaration" || (this.decl.kind === "Type" && this.decl.isDialog());
    }
    isBinaryOperator() {
        var _a, _b;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined && constants_1.Constants.BINARY_OPERATOR_ACTIONS_SET.has((_b = this.decl.name) === null || _b === void 0 ? void 0 : _b.name);
    }
    isOperator() {
        var _a, _b;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined && constants_1.Constants.OPERATOR_ACTIONS_SET.has((_b = this.decl.name) === null || _b === void 0 ? void 0 : _b.name);
    }
    // This method tracks the legal data binding function calls in ACDL syntax. Might need a more precise name for this function..
    isNativeAction() {
        return this.isSize() || this.isLength() || this.isExists() || this.isGetListItem() || this.isIs();
    }
    isFileAccessAction() {
        var _a, _b;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined && constants_1.Constants.FILE_ACCESS_ACTIONS_SET.has((_b = this.decl.name) === null || _b === void 0 ? void 0 : _b.name);
    }
    isGetListItem() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.getListItem;
    }
    isEnsure() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ensure;
    }
    isExpect() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.expect;
    }
    isConfirmAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.confirmAction;
    }
    isConfirmActionAct() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ConfirmAction;
    }
    /**
     * Checks if this is a call to the `confirmArgs` action.
     */
    isConfirmArgs() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.confirmArgs;
    }
    /**
     * Checks if this is a call to the `ConfirmArgs` Dialog Act Type.
     */
    isConfirmArgsAct() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ConfirmArgs;
    }
    /**
     * Checks if this is a call to the `ConfirmArgs` Dialog Act Type.
     */
    isConfirmArguments() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ConfirmArguments;
    }
    isUtterances() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.utterances;
    }
    isTouch() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.touch;
    }
    isMultiModalEvent() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.multiModalEvent;
    }
    isEventDecl() {
        return this.isUtterances() || this.isTouch() || this.isMultiModalEvent();
    }
    isUtterance() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Utterance;
    }
    isAlexaLine() {
        return this.isResponse() || this.isConfirmAction();
    }
    isResponse() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.response;
    }
    isReceived() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.received;
    }
    isRequestArguments() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.RequestArguments;
    }
    isResetAllArguments() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ResetAllArguments;
    }
    isResetArguments() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.ResetArguments;
    }
    isEnsureArgOrder() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.EnsureArgOrder;
    }
    isRequestAct() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Request;
    }
    isLength() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.length;
    }
    isAlexaSchemaNamespace() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.startsWith(ast_1.AlexaSchemaNamespace)) !== null && _c !== void 0 ? _c : false;
    }
    isAlexaConversationsNamespace() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.startsWith(ast_1.AlexaConversationsNamespace)) !== null && _c !== void 0 ? _c : false;
    }
    isAlexaBuiltinsNamespace() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.startsWith(ast_1.BuiltinsNamespace)) !== null && _c !== void 0 ? _c : false;
    }
    isSize() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.size;
    }
    isUserSays() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.userSays;
    }
    isExists() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.exists;
    }
    isEvents() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.events;
    }
    isWelcome() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.welcome;
    }
    isLocaleAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.locale;
    }
    isVarArgs() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.Args;
    }
    isValidateArg() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.validateArg;
    }
    isVariations() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.variations;
    }
    isAplaAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.apla;
    }
    isAplAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.apl;
    }
    isReferableAction() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaConversations.referable;
    }
    getName() {
        var _a;
        return (_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name;
    }
    getShortName() {
        var _a;
        return ((_a = this.decl.name) === null || _a === void 0 ? void 0 : _a.name) ? (0, util_1.getName)(this.decl.name.name) : undefined;
    }
    /**
     * Gets a Thing representing an Argument Value.
     *
     * @param name name of the argument value.
     * @returns a Thing representing the value (if it can be determined) or `undefined`.
     */
    getArgumentValueThing(name) {
        return this.checker.getThing(this.getArgumentValue(name));
    }
    /**
     * Gets a List of Thing representing all the argument values
     * @returns a List of Thing representing all the argument values
     */
    getArgumentValueThingList() {
        return this.getArgumentsList().map((argument) => this.checker.getThing(argument.value));
    }
    /**
     * Get the specific argument value by name
     * @param name name string or ask.Name
     */
    getArgumentValue(name) {
        var _a;
        return (_a = this.getArgument(name)) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * Get the specific argument by name
     * @param name name string or ask.Name
     */
    getArgument(name) {
        var _a, _b, _c, _d;
        const args = this.getArguments();
        const nameStr = name === undefined
            ? undefined
            : typeof name === "string"
                ? name
                : name.kind === "Name"
                    ? name.name
                    : ((_b = (_a = name.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.isAction()) && name.argumentName
                        ? (_d = (_c = name.parent.parent.concreteToAbstractArgumentNames) === null || _c === void 0 ? void 0 : _c[name.argumentName]) !== null && _d !== void 0 ? _d : name.argumentName
                        : name.argumentName;
        if (args !== undefined && nameStr !== undefined) {
            // return args[this.argumentNameMappings?.[nameStr] ?? nameStr];
            return args[nameStr];
        }
        return undefined;
    }
    /**
     * Get the specific argument value by name, if it's a nameReference, resolve it
     * @param name name string or ask.Name
     * @returns
     */
    getArgumentValueAndResolveIfNameRef(name) {
        const value = this.getArgumentValue(name);
        if (this.checker.isNameReference(value)) {
            return this.checker.resolveNameReference(value);
        }
        return value;
    }
    /**
     * Get the specific argument value by name, if the value kind is nameReference, resolve it to the call
     *
     * E.G.
     * ```
     * apla = APLA {}
     * temp = apla
     * response(temp, Bye {})
     *
     * if we have the response apply
     * apply.getArgumentValueAndResolveToCallIfNameRef('response') => APLA {}
     * ```
     * @param name name string or ask.Name
     */
    getArgumentValueAndResolveToCallIfNameRef(name) {
        const value = this.getArgumentValue(name);
        if (this.checker.isNameReference(value)) {
            return this.checker.resolveNameReferenceToCall(value);
        }
        return value;
    }
    getArgumentsList() {
        var _a;
        return Object.values((_a = this.getArguments()) !== null && _a !== void 0 ? _a : {});
    }
    getArgumentsThing() {
        var _a;
        return Object.entries((_a = this.getArguments()) !== null && _a !== void 0 ? _a : {})
            .map(([name, arg]) => ({
            [name]: this.checker.getThing(arg),
        }))
            .reduce((a, b) => ({ ...a, ...b }), {});
    }
    /**
     * Get a map or argument name to the ArgumentValue node passed to this call.
     */
    getArguments() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (this.arguments === undefined) {
            this.arguments = {};
            if (this.call.arguments === undefined || Array.isArray(this.call.arguments)) {
                let isPositionalAllowed = true;
                let i = 0;
                let loc;
                for (const argument of this.call.arguments || []) {
                    if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
                        isPositionalAllowed = false;
                        this.arguments[argument.name.name] = argument;
                    }
                    else if (argument.index !== undefined) {
                        if (isPositionalAllowed) {
                            const argDecl = (_b = this.argumentDeclarations) === null || _b === void 0 ? void 0 : _b[i];
                            const isVarArgs = argDecl !== undefined &&
                                ((_c = argDecl.type) === null || _c === void 0 ? void 0 : _c.name) &&
                                this.checker.qualifyName(argDecl.type.name, argDecl.type.name.name) === ast_1.AlexaConversations.Args;
                            const argName = typeof (argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === "string" ? argDecl.name : (_d = argDecl === null || argDecl === void 0 ? void 0 : argDecl.name) === null || _d === void 0 ? void 0 : _d.name;
                            // argName = argName ? this.argumentNameMappings?.[argName] ?? argName : argName;
                            if (argName) {
                                if (isVarArgs) {
                                    // if this is a var-args, construct a list literal call
                                    let arg = this.arguments[argName];
                                    let listCall = arg === null || arg === void 0 ? void 0 : arg.value;
                                    let list = listCall === null || listCall === void 0 ? void 0 : listCall.arguments;
                                    if (list === undefined) {
                                        list = new ask.ListLiteral([]);
                                        listCall = new ask.Call(new ask.Name(ast_1.AlexaConversations.Args), list, undefined);
                                        arg = new ask.Argument(undefined, argument.index, listCall);
                                        this.call.setAsParentOn(arg);
                                        this.arguments[argName] = arg;
                                    }
                                    const item = new ask.ListItem((_e = argument === null || argument === void 0 ? void 0 : argument.value) === null || _e === void 0 ? void 0 : _e.clone(), list.items.length);
                                    list.setAsParentOn(item);
                                    list.items.push(item);
                                    if (loc && ((_f = argument.loc) === null || _f === void 0 ? void 0 : _f.end)) {
                                        loc.end = (_g = argument === null || argument === void 0 ? void 0 : argument.loc) === null || _g === void 0 ? void 0 : _g.end;
                                    }
                                    else {
                                        loc = argument.loc;
                                    }
                                    listCall.loc = loc;
                                }
                                else {
                                    this.arguments[argName] = argument;
                                    i += 1; // increment the declaration index only if we're not var-args
                                }
                            }
                        }
                    }
                }
            }
        }
        return this.arguments || undefined;
    }
    /**
     * Get the return type of this call.
     *
     * Infers generic arguments and computing generic return type if necessary
     *
     * @returns the return type if it is known, otherwise `undefined`.
     */
    getReturnType(seen) {
        var _a, _b;
        if (this.returnType === undefined) {
            this.returnType = (_a = this.resolveReturnType(seen)) !== null && _a !== void 0 ? _a : null;
        }
        return (_b = this.returnType) !== null && _b !== void 0 ? _b : undefined;
    }
    resolveReturnType(seen) {
        if (this.decl.kind === "Type") {
            if (this.decl.isFunctionN()) {
                return this.decl.getFunctionReturnType();
            }
            if (this.decl.isFunction()) {
                return this.checker.thing;
            }
            return this.decl;
        }
        if (this.decl.genericArguments === undefined) {
            if (this.decl.kind === "TypeDeclaration") {
                return this.checker.instantiateTypeDeclaration(this.decl);
            }
            return this.checker.instantiateTypeReference(this.decl.returnType);
        }
        if (this.decl.kind === "TypeDeclaration") {
            const args = this.getGenericArguments(seen);
            if (args !== undefined) {
                return this.checker.instantiateTypeDeclaration(this.decl, args);
            }
        }
        else {
            // ActionDeclaration and DialogDeclaration
            const env = this.getGenericEnvironment(seen);
            if (env !== undefined) {
                return this.checker.instantiateTypeReference(this.decl.returnType, env);
            }
        }
        return undefined;
    }
    /**
     * Get the type of an argument or property
     */
    getType(arg, context) {
        var _a, _b, _c;
        if (arg === undefined) {
            // `undefined` refers to a primitive expression's arguments, e.g. `null`, `string`, `[]`.
            if (this.decl.kind === "Type") {
                return this.decl;
            }
        }
        else if (arg.kind === "Argument") {
            const argDecl = ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) ? this.argumentDeclIndex[arg.name.name] : (_b = this.argumentDeclarations) === null || _b === void 0 ? void 0 : _b[arg.index];
            if (argDecl) {
                return this.getType(argDecl, context);
            }
        }
        else {
            const name = typeof arg.name === "string" ? arg.name : (_c = arg.name) === null || _c === void 0 ? void 0 : _c.name;
            const decl = this.argumentDeclIndex[name];
            if (decl.kind === "ArgumentDeclaration") {
                return this.checker.instantiateTypeReference(decl.type, this.getGenericEnvironment());
            }
            return decl.type;
        }
        return undefined;
    }
    /**
     * Retuns a mapping of generic argument names to their inferred type. For instance consider the action declaration:
     *
     *    action Nothing getWeather<T,K>(T something, K somethingElse)
     *
     * For the call/apply below:
     *    sample {
     *      ...
     *      getWeather('x', 1)
     *      ...
     *    }
     * The return value will be: { "T" : <Type object refering to string>, "K": <Type object refering to number>}
     *
     * For anonymous functions the generic arguments are also types as opposed to something like T or K above.
     * For instance consider the reusable dialog declaration containing an anonymous function receiving Optional<T>
     * and returning Nothing:
     *     dialog Nothing reusableDialog<T>( Action1<Optional<T>, Nothing> anonAction, T value) {
     *        sample {
     *            ...
     *            anonAction(value);
     *            ...
     *        }
     *     }
     * for the call/apply inside the sample the generic arguments are the types Optional<T> and Nothing
     * seen in Action1<Optional<T>, Nothing> anonAction
     * The return value for this call is {"T": <Type object refering to T>, "Nothing": <Type object refering to Nothing>}
     * @param seen used  to prevent infinite recursion in type lookups
     */
    getGenericEnvironment(seen) {
        var _a, _b;
        if (this.genericEnvironment === undefined) {
            this.genericEnvironment = this.genericEnvironment = (_a = this.resolveGetGenericEnvironment(seen)) !== null && _a !== void 0 ? _a : null;
        }
        return (_b = this.genericEnvironment) !== null && _b !== void 0 ? _b : undefined;
    }
    /**
     * Does the actual work in getGenericEnvironment.
     * @param seen used  to prevent infinite recursion in type lookups
     */
    resolveGetGenericEnvironment(seen) {
        var _a;
        const genericArgumentTypes = this.getGenericArguments(seen);
        return (_a = this.decl.genericArguments) === null || _a === void 0 ? void 0 : _a.map((declGenericArgument, i) => {
            var _a;
            if ((declGenericArgument === null || declGenericArgument === void 0 ? void 0 : declGenericArgument.kind) === "TypeParameter") {
                const type = genericArgumentTypes === null || genericArgumentTypes === void 0 ? void 0 : genericArgumentTypes[i];
                return type ? { [(_a = declGenericArgument === null || declGenericArgument === void 0 ? void 0 : declGenericArgument.name) === null || _a === void 0 ? void 0 : _a.name]: type } : {};
            }
            else if ((declGenericArgument === null || declGenericArgument === void 0 ? void 0 : declGenericArgument.kind) === "Type") {
                // The generic argument here might look like Apply<Optional<T>,K>. We need to find nested generic arguments T and K.
                // Because of that, one generic argument like Apply<Optional<T>,K> might turn into many: [T,K]. The map below will
                // add a nested dimension to the array that will be flatened below.
                const nestedGenericArguments = declGenericArgument.getNestedGenericArguments();
                return nestedGenericArguments.map((nestedGenericArgument) => {
                    var _a;
                    return { [(_a = nestedGenericArgument === null || nestedGenericArgument === void 0 ? void 0 : nestedGenericArgument.name) === null || _a === void 0 ? void 0 : _a.name]: nestedGenericArgument };
                });
            }
            else {
                return {};
            }
        }).flat().reduce((a, b) => ({ ...a, ...b }), {});
    }
    getGenericArguments(seen) {
        var _a, _b;
        if (this.genericArguments === undefined) {
            this.genericArguments = (_a = this.resolveGenericArguments(seen)) !== null && _a !== void 0 ? _a : null;
        }
        return (_b = this.genericArguments) !== null && _b !== void 0 ? _b : undefined;
    }
    resolveGenericArguments(seen) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (this.decl.kind === "Type" && this.decl.genericArguments !== undefined) {
            // TODO: infer
            return this.decl.genericArguments;
        }
        if (this.decl.genericArguments === undefined) {
            return undefined;
        }
        if (((_a = this.call.genericArguments) === null || _a === void 0 ? void 0 : _a.length) === this.decl.genericArguments.length) {
            return this.call.genericArguments.map((a) => { var _a; return (_a = this.checker.instantiateTypeReference(a)) !== null && _a !== void 0 ? _a : this.checker.thing; });
        }
        if (this.call.genericArguments === undefined) {
            // infer the arguments from the values
            if (ask.isListLiteral(this.call.arguments) && this.decl.kind === "TypeDeclaration") {
                // we're instantiating a List declaration
                const listValueType = this.checker.getType(this.call.arguments, false, seen);
                const listDeclType = this.checker.instantiateTypeDeclaration(this.decl, this.decl.genericArguments.map((arg) => this.checker.instantiateTypeParameter(arg)));
                if (listValueType && listDeclType) {
                    // the list could be a complex sub type
                    // e.g. type MyList<A> : List<List<A>>
                    // e.g. type MyList2<A> : MyList<List<A>> : List<List<List<A>>
                    // ... so we first reduce it to the value's type
                    return this.decl.genericArguments.map((genericArg) => { var _a, _b; return (_b = inferTypeParameter((_a = genericArg.name) === null || _a === void 0 ? void 0 : _a.name, listDeclType, listValueType)) !== null && _b !== void 0 ? _b : this.checker.thing; });
                }
            }
            else {
                const declarations = this.decl.kind === "Type" ? this.decl.properties : this.argumentDeclarations;
                const args = this.getArguments();
                // store a mapping of Type Parameter to:
                // 1. `string` - another type parameter in the parameter list
                // 2. Type - a type inferred from the values
                const inferredTypes = {};
                // first pass over the generic arguments, infer what we can from the values
                for (const genericArg of this.decl.genericArguments) {
                    let inferredType;
                    if (args !== undefined && declarations !== undefined) {
                        for (const argDecl of declarations) {
                            const argName = typeof argDecl.name === "string" ? argDecl.name : (_b = argDecl.name) === null || _b === void 0 ? void 0 : _b.name;
                            const arg = args[argName];
                            if (arg === undefined || argDecl.type === undefined) {
                                continue;
                            }
                            const argType = this.checker.getType(arg.value, false, seen);
                            if (argType === undefined) {
                                continue;
                            }
                            const argDeclType = argDecl.kind === "ArgumentDeclaration" ? this.checker.instantiateTypeReference(argDecl.type) : argDecl.type;
                            if (argDeclType) {
                                const inferred = inferTypeParameter((_c = genericArg === null || genericArg === void 0 ? void 0 : genericArg.name) === null || _c === void 0 ? void 0 : _c.name, argDeclType, argType);
                                inferredType = (_d = inferredType === null || inferredType === void 0 ? void 0 : inferredType.union(inferred)) !== null && _d !== void 0 ? _d : inferred;
                            }
                        }
                    }
                    if (inferredType) {
                        // we found a value in the arguments that informs this generic argument
                        inferredTypes[(_e = genericArg === null || genericArg === void 0 ? void 0 : genericArg.name) === null || _e === void 0 ? void 0 : _e.name] = inferredType;
                    }
                    else if ((genericArg === null || genericArg === void 0 ? void 0 : genericArg.kind) === "TypeParameter") {
                        // we did not find a value for the argument, let's see if there are default types
                        if (genericArg.constraints === undefined || genericArg.constraints.length === 0) {
                            // this parameter has no constraints, default to Thing.
                            inferredTypes[(_f = genericArg.name) === null || _f === void 0 ? void 0 : _f.name] = this.checker.thing;
                        }
                        else if (genericArg.constraints.length > 1) {
                            // this generic arg has multiple constraints, e.g. T : A : B
                            // we don't yet support this case, for now we will default it to Thing.
                            inferredTypes[(_g = genericArg.name) === null || _g === void 0 ? void 0 : _g.name] = this.checker.thing;
                        }
                        else if (genericArg.constraints.length === 1) {
                            // this generic arg has a single constrain, e.g. T : V
                            // default to that type
                            const defaultType = this.checker.getType(genericArg.constraints[0], undefined, seen);
                            if (((_h = defaultType === null || defaultType === void 0 ? void 0 : defaultType.declaration) === null || _h === void 0 ? void 0 : _h.kind) === "TypeParameter") {
                                // if the constraint is another type parameter, e.g. <T : V, V>
                                // then use that name as a place-holder and attempt to resolve it in the final pass.
                                inferredTypes[(_j = genericArg.name) === null || _j === void 0 ? void 0 : _j.name] = (_k = defaultType.declaration.name) === null || _k === void 0 ? void 0 : _k.name;
                            }
                            else if (defaultType !== undefined) {
                                // this is a concrete type
                                inferredTypes[(_l = genericArg.name) === null || _l === void 0 ? void 0 : _l.name] = defaultType;
                            }
                        }
                    }
                }
                // second pass over generic arguments where we resolve the inference results
                return this.decl.genericArguments.map((genericArg) => { var _a, _b; return (_b = resolveInferredArg((_a = genericArg === null || genericArg === void 0 ? void 0 : genericArg.name) === null || _a === void 0 ? void 0 : _a.name)) !== null && _b !== void 0 ? _b : this.checker.thing; });
                /**
                 * Resolves a named argument from the results of the first pass.
                 */
                function resolveInferredArg(name, seen = immutable_1.default.Set()) {
                    if (name === undefined) {
                        return undefined;
                    }
                    const inferred = inferredTypes[name];
                    if (inferred === undefined) {
                        return undefined;
                    }
                    if (typeof inferred === "string") {
                        // the type is a place-holder referring to the inferred type of another generic argument
                        if (seen.has(inferred)) {
                            // encountered a loop, so the type is undefined.
                            return undefined;
                        }
                        // try and resolve the place-holder
                        return resolveInferredArg(inferred, seen.add(inferred));
                    }
                    if (inferred.genericArguments === undefined || inferred.genericArguments.length === 0) {
                        // this is a concrete type, terminate inference
                        return inferred;
                    }
                    // this is a generic type, we need to recursively resolve generic arguments that may be
                    // referencing other inferred generic arguments
                    // e.g foo<T : List<V>, V>(V value)
                    // foo("string")
                    // once we have inferred V => String
                    // we must then resolve T => List<V> => List<String>
                    return (function resolveType(type) {
                        if (type === undefined) {
                            return undefined;
                        }
                        if (type.genericArguments === undefined || type.genericArguments.length === 0) {
                            return type;
                        }
                        return new type_1.Type(type.checker, type.declaration, type.genericArguments.map((arg) => {
                            var _a, _b;
                            if (((_a = arg === null || arg === void 0 ? void 0 : arg.declaration) === null || _a === void 0 ? void 0 : _a.kind) === "TypeParameter") {
                                const resolvedType = resolveInferredArg((_b = arg.declaration.name) === null || _b === void 0 ? void 0 : _b.name, seen);
                                if (resolvedType !== undefined) {
                                    return resolvedType;
                                }
                            }
                            return resolveType(arg);
                        }));
                    })(inferred);
                }
            }
        }
        return undefined;
    }
    /**
     * a util function help retrieve payload argumentDeclarations
     * @param apply
     */
    getPayloadValue() {
        if (this.isResponse() || this.isConfirmAction()) {
            let payloadValue = this.getArgumentValue("payload");
            if (payloadValue !== undefined) {
                payloadValue = this.checker.isNameReference(payloadValue)
                    ? this.checker.resolveNameReferenceToCall(payloadValue)
                    : payloadValue;
                return payloadValue;
            }
        }
        return undefined;
    }
    /**
     * get detailed response info for an Alexa response
     *
     * In current acdl, there's four response actions and eight response acts, it's hard to retrieve property in different kind of responses
     * This function try to collect all info an Alexa Response may have and represent them as ResponseInfo interface,
     * this new layer make it easier to get a specific property in an Alexa response
     *
     * E.G.
     * ```
     * ensure(
     *      RequestArguments {arguments = [getPerson.arguments.name], response = greeting_apla},
     *      RequestArguments {arguments = [getPerson.arguments.age], response = bye_apla}
     * )
     *
     * =>
     *
     * [
     *   {
     *     purpose: 'request',
     *     arguments: [getPerson.arguments.name],
     *     prompt: greeting_apla
     *   },
     *   {
     *     purpose: 'request',
     *     arguments: [getPerson.arguments.age],
     *     prompt: bye_apla
     *   }
     * ]
     * ```
     *
     * @returns
     */
    getResponseInfo() {
        const responseInfo = [];
        if (this.isConfirmAction()) {
            responseInfo.push({
                purpose: responseInfo_1.ResponsePurpose.ConfirmAction,
                actionName: this.getArgument("actionName"),
                prompt: this.getArgument("response"),
                payload: this.getArgument("payload"),
            });
        }
        else if (this.isConfirmArgs() || this.isEnsure()) {
            const argsValue = this.isConfirmArgs()
                ? this.getArgumentValueAndResolveToCallIfNameRef("confirmArgs")
                : this.getArgumentValueAndResolveToCallIfNameRef("requestArgs");
            if ((argsValue === null || argsValue === void 0 ? void 0 : argsValue.kind) === "Call" && ask.isListLiteral(argsValue.arguments)) {
                for (const confirmArguments of argsValue.arguments.items) {
                    let itemValue = confirmArguments.item;
                    if (this.checker.isNameReference(itemValue)) {
                        itemValue = this.checker.resolveNameReferenceToCall(itemValue);
                    }
                    // The expected value is ConfirmArguments Object Literal or RequestArguments Object Literal
                    if ((itemValue === null || itemValue === void 0 ? void 0 : itemValue.kind) === "Call") {
                        const argsApply = this.checker.getApply(itemValue, undefined);
                        responseInfo.push({
                            purpose: this.isConfirmArgs() ? responseInfo_1.ResponsePurpose.ConfirmArgs : responseInfo_1.ResponsePurpose.Request,
                            arguments: argsApply === null || argsApply === void 0 ? void 0 : argsApply.getArgument("arguments"),
                            prompt: argsApply === null || argsApply === void 0 ? void 0 : argsApply.getArgument("response"),
                        });
                    }
                }
            }
        }
        else if (this.isResponse()) {
            const sourceActValue = this.getArgumentValue("act");
            const actValue = this.checker.isNameReference(sourceActValue)
                ? this.checker.resolveNameReferenceToCall(sourceActValue)
                : sourceActValue;
            const actType = this.checker.getType(actValue);
            if ((actValue === null || actValue === void 0 ? void 0 : actValue.kind) === "Call") {
                const actApply = this.checker.getApply(actValue, undefined);
                responseInfo.push({
                    purpose: (actType === null || actType === void 0 ? void 0 : actType.isRequest())
                        ? responseInfo_1.ResponsePurpose.Request
                        : (actType === null || actType === void 0 ? void 0 : actType.isConfirmArgs())
                            ? responseInfo_1.ResponsePurpose.ConfirmArgs
                            : (actType === null || actType === void 0 ? void 0 : actType.isConfirmAction())
                                ? responseInfo_1.ResponsePurpose.ConfirmAction
                                : (actType === null || actType === void 0 ? void 0 : actType.isNotify())
                                    ? responseInfo_1.ResponsePurpose.Notify
                                    : (actType === null || actType === void 0 ? void 0 : actType.isOffer())
                                        ? responseInfo_1.ResponsePurpose.Offer
                                        : (actType === null || actType === void 0 ? void 0 : actType.isReqAlt())
                                            ? responseInfo_1.ResponsePurpose.ReqAlt
                                            : (actType === null || actType === void 0 ? void 0 : actType.isReqMore())
                                                ? responseInfo_1.ResponsePurpose.ReqMore
                                                : (actType === null || actType === void 0 ? void 0 : actType.isBye())
                                                    ? responseInfo_1.ResponsePurpose.Bye
                                                    : undefined,
                    arguments: actApply === null || actApply === void 0 ? void 0 : actApply.getArgument("arguments"),
                    actionName: actApply === null || actApply === void 0 ? void 0 : actApply.getArgument("actionName"),
                    carryOverArguments: actApply === null || actApply === void 0 ? void 0 : actApply.getArgument("carryOverArguments"),
                    success: actApply === null || actApply === void 0 ? void 0 : actApply.getArgument("success"),
                    prompt: this.getArgument("response"),
                    payload: this.getArgument("payload"),
                });
            }
        }
        return responseInfo;
    }
}
exports.Apply = Apply;
/**
 * Infer a TypeParameter's type by searching for it within an instantiated type.
 *
 * e.g. inferring T from passed in arguments.
 * ```
 * action T myAction(List<T> list)
 * List<String> list
 *
 * t = myAction(list)
 *
 * // declarationType: List<T>
 * // instantiatedType: List<String>
 * ```
 *
 * The declarationType is `List<T>` and the instantiatedType is List<String>. Searching
 * for `T` will find `String`.
 *
 * `T` is inferred as `String` from the passed in `List<String>`.
 *
 * @param parameter  type parameter to infer
 * @param declarationType  declaration signature of this type, e.g. List<T>
 * @param valueType  type of the value e.g. List<String>
 */
function inferTypeParameter(parameter, declaration, valueType) {
    var _a, _b, _c;
    if (valueType === undefined || declaration === undefined) {
        return undefined;
    }
    if (parameter === ((_a = declaration === null || declaration === void 0 ? void 0 : declaration.name) === null || _a === void 0 ? void 0 : _a.name)) {
        return valueType;
    }
    if (((_b = valueType.name) === null || _b === void 0 ? void 0 : _b.name) === ((_c = declaration.name) === null || _c === void 0 ? void 0 : _c.name)) {
        if (declaration.genericArguments !== undefined && valueType.genericArguments !== undefined) {
            for (let i = 0; i < declaration.genericArguments.length; i++) {
                const argumentDeclaration = declaration.genericArguments[i];
                const instantiated = valueType.genericArguments[i];
                if (instantiated !== undefined) {
                    const found = inferTypeParameter(parameter, argumentDeclaration, instantiated);
                    if (found) {
                        return found;
                    }
                }
            }
        }
    }
    else if (valueType.isOptional()) {
        // we currently have the problem where Optional<T> must be assignable to T
        // for this case, we will reduce an Optional<T> value to T and infer from that.
        return inferTypeParameter(parameter, declaration, valueType.getOptionalType());
    }
    else if (declaration.isOptional()) {
        // Optional<T> is effectively a union type, we want to traverse its type parameters (the items in its set) and not its extensions
        return inferTypeParameter(parameter, declaration.getOptionalType(), valueType);
    }
    else if (valueType.extensions) {
        for (const extension of valueType.extensions) {
            const found = inferTypeParameter(parameter, declaration, extension);
            if (found) {
                return found;
            }
        }
    }
    return undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwbHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXBwbHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwwREFBa0M7QUFDbEMsMkNBQTZCO0FBRTdCLCtCQVNlO0FBQ2YsMkNBQXNDO0FBRXRDLGlDQUE0QjtBQUc1QixpREFBNkQ7QUFFN0QsaUNBQStCO0FBTS9COzs7OztHQUtHO0FBQ0gsTUFBYSxLQUFLO0lBOEJoQixZQUNXLE9BQW9CLEVBQ3BCLElBQWMsRUFDZCxJQUFnRixFQUN6RixJQUFZLEVBQ1osVUFBb0MsRUFDcEMsYUFBK0QsRUFDL0Qsa0JBQW1ELEVBQ25ELGdCQUE0Qzs7Ozs7O21CQVBuQzs7Ozs7O21CQUNBOzs7Ozs7bUJBQ0E7O1FBaENYOzs7O21CQUF5QixPQUFPO1dBQUM7UUFFakM7Ozs7O1dBQWtGO1FBRWxGOzs7O21CQUFpRixFQUFFO1dBQUM7UUFFcEY7Ozs7O1dBQThDO1FBRTlDOzs7OztXQUE0QztRQUU1Qzs7Ozs7V0FBbUU7UUFFbkU7Ozs7O1dBQTJEO1FBRTNEOzs7OztXQUFrRTtRQXlCaEUsSUFBSSxJQUFJLEVBQUU7WUFDUixJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDO1lBQ3RELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUM7WUFDaEQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztZQUNoRCxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztZQUM3QixJQUFJLENBQUMsU0FBUyxHQUFHLGFBQWEsQ0FBQztZQUMvQixJQUFJLENBQUMsa0JBQWtCLEdBQUcsa0JBQWtCLENBQUM7WUFDN0MsSUFBSSxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDO1NBQzFDO2FBQU07WUFDTCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssTUFB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QUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLElBQUksQ0FBQztJQUMxRCxDQUFDO0lBRU0sSUFBSTs7UUFDVCxPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEVBQUUsQ0FBQztJQUN4RCxDQUFDO0lBRU0sS0FBSzs7UUFDVixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEdBQUcsQ0FBQztJQUN6RCxDQUFDO0lBRU0sS0FBSzs7UUFDVixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEdBQUcsQ0FBQztJQUN6RCxDQUFDO0lBRU0sSUFBSTs7UUFDVCxPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEVBQUUsQ0FBQztJQUN4RCxDQUFDO0lBRU0sS0FBSzs7UUFDVixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEdBQUcsQ0FBQztJQUN6RCxDQUFDO0lBRU0sSUFBSTs7UUFDVCxPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEVBQUUsQ0FBQztJQUN4RCxDQUFDO0lBRU0sS0FBSzs7UUFDVixPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEdBQUcsQ0FBQztJQUN6RCxDQUFDO0lBRU0sSUFBSTs7UUFDVCxPQUFPLENBQUEsTUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksMENBQUUsSUFBSSxNQUFLLHdCQUFrQixDQUFDLEVBQUUsQ0FB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