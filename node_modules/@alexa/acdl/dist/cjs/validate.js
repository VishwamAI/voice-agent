"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateCorrection = exports.validateInteractionDeclaration = exports.validateEnsureArgOrder = exports.validateConditionBlock = exports.validateCondition = exports.validateUtterance = exports.validateBinaryOperator = exports.validateNamedArguments = exports.validateRequireCall = exports.validateValidateArgAnnotation = exports.validateCallContext = exports.validateVariations = exports.validateCall = exports.validateUtteranceTypeWrapper = exports.validatePropertyReference = exports.validateTypeReference = exports.validateTypeReferences = exports.validateTypeParameter = exports.validateTypeParameters = exports.validateTypeDeclarationProperties = exports.validateTypeDeclaration = exports.validateEnumDeclaration = exports.validateArgumentDeclaration = exports.validateArgumentDeclarations = exports.validateAnnotatedActionDeclaration = exports.validateActionDeclaration = exports.validateName = exports.validateNameReference = exports.validateNameDeclaration = exports.validateDuplicateNames = exports.validateSample = exports.validateDialogDeclaration = exports.validateExpression = exports.validateAnnotation = exports.validateDialogDeclarationAnnotations = exports.validateTypeDeclarationAnnotations = exports.validateNameDeclarationAnnotations = exports.validateAnnotations = exports.validateCircularReferences = exports.validateImports = exports.validateNamespace = exports.validateBlock = exports.validateModule = exports.validateProject = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const ask = __importStar(require("./ast"));
const error_1 = require("./error");
const ast_1 = require("./ast");
const util_1 = require("./util");
const constants_1 = require("./constants");
const evaluate_1 = require("./evaluate");
const flow_1 = require("./flow");
const validate_skill_1 = require("./validate-skill");
const evaluation_state_1 = require("./evaluation-state");
const visit_1 = require("./visit");
const error_factory_1 = require("./error-factory");
const property_node_1 = require("./property-node");
const lazy_1 = require("./lazy");
/**
 * Validate the entire project for correctness and return and errors.
 *
 * @param project project to validate.
 * @param isSkill whether the project is a skill
 * @param skipSemanticValidations skip semantic validations
 * @returns array of all errors if detected.
 */
function validateProject(project, isSkill, skipSemanticValidations) {
    var _a, _b, _c;
    const checker = project.getTypeChecker();
    const errors = [];
    const skills = checker.project.findSkills();
    errors.push(...project.sourceModules.flatMap((srcModule) => {
        var _a;
        return [
            // syntax errors from module errors
            ...((_a = srcModule.errors) !== null && _a !== void 0 ? _a : []),
            // syntax errors from validateRootExpressions
            ...(srcModule.content ? validateRootExpressions(srcModule.content, checker) : []),
            // semantic errors from validateModule
            ...(srcModule.content && !skipSemanticValidations ? (0, exports.validateModule)(srcModule.content, checker) : []),
        ];
    }));
    if (skipSemanticValidations) {
        return errors;
    }
    errors.push(...(0, evaluate_1.validateGlobalWelcome)(project, checker));
    // now that type checking has passed, let's pass over the AST and create a tree with all types resolved.
    // project = resolveProject(project);
    // checker = project.getTypeChecker();
    const isParsingSkill = isSkill !== null && isSkill !== void 0 ? isSkill : (project.isSkill() || skills.length > 0);
    if (!isParsingSkill) {
        // if we're not parsing a skill, then we should treat all dialogs as deployable
        // FIXME: this logic is wrong, we should validateDialogFlow of all dialogs and handle cases where the dialog "could be called"
        // e.g don't error when there is no prior expect event for a dialog that may be called.
        // This can be improved as part of our re-usability QA drive.
        (_a = checker.project
            .getRootDialogs()) === null || _a === void 0 ? void 0 : _a.forEach((dialog) => errors.push(...(0, evaluate_1.evaluateDialogFlow)(new flow_1.Flow(checker, dialog, undefined, []), new evaluation_state_1.EvaluationState(undefined))));
    }
    else {
        if (skills.length > 1) {
            errors.push(...skills.map((skill) => error_factory_1.ValidationErrorFactory.TooManySkillDeclarations({
                expr: (0, error_factory_1.getExpressionIfLocField)(skill.declaration.name, skill.declaration),
                attributes: {
                    skillNames: skills
                        .filter((s) => s !== skill)
                        .map((skill) => { var _a; return `'${(_a = skill.declaration.name) === null || _a === void 0 ? void 0 : _a.name}'`; })
                        .join(", "),
                },
            })));
        }
        if (project.config.skill === undefined) {
            // no `package.json` or `ask.json` configuration, attempt to derive it from the context
            if (skills.length === 0) {
                // this skill contains no `skill()` declarations, so look for deployable dialogs and global `response/prompts` responses.
                errors.push(...validateDeployableDialogs(checker));
                errors.push(...(0, evaluate_1.validateSkillLevelResponses)(project));
                (_b = checker.project
                    .getRootDialogs()) === null || _b === void 0 ? void 0 : _b.forEach((dialog) => errors.push(...(0, evaluate_1.evaluateDialogFlow)(new flow_1.Flow(checker, dialog, undefined, []), new evaluation_state_1.EvaluationState(undefined))));
            }
            else {
                // skill declarations exist, validate each one.
                skills.forEach((skill) => errors.push(...(0, validate_skill_1.validateSkill)(skill.apply, checker)));
            }
        }
        else {
            // the skill is configured in `package.json` or `ask.json`, let's validate it.
            const skill = checker.lookupQualifiedName(project.config.skill);
            if (skill === undefined) {
                errors.push(error_factory_1.ValidationErrorFactory.SkillNotFound({
                    attributes: {
                        skillName: project.config.skill,
                    },
                }));
            }
            else if (skill.kind === "NameDeclaration" && ((_c = skill.expression) === null || _c === void 0 ? void 0 : _c.kind) === "Call") {
                const apply = checker.getApply(skill.expression);
                if (apply) {
                    if (apply.isSkillAction()) {
                        errors.push(...(0, validate_skill_1.validateSkill)(apply, checker));
                    }
                    else {
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidSkillExpression({
                            expr: skill,
                            attributes: {
                                skillName: project.config.skill,
                            },
                        }));
                    }
                }
            }
            else {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidSkillExpression({
                    expr: skill,
                    attributes: {
                        skillName: project.config.skill,
                    },
                }));
            }
        }
    }
    return (0, error_1.sortErrors)((0, error_1.filterDuplicateErrors)(errors));
}
exports.validateProject = validateProject;
/**
 * validate the skill has deployable dialog
 * This function should be used when there's no skill action call
 */
function validateDeployableDialogs(checker) {
    const deployableDialogs = checker.project.getRootDialogs();
    if (deployableDialogs === undefined || deployableDialogs.length === 0) {
        return [error_factory_1.ValidationErrorFactory.NoDeployableDialog()];
    }
    return [];
}
/**
 * Validate all expressions in a module in the context of a Project.
 *
 * @param module ACDL file or ASK Module to validate.
 * @param checker type checker for querying the expressions.
 */
const validateModule = (module, checker) => [
    ...(0, exports.validateImports)(module, checker),
    ...(0, exports.validateNamespace)(module, checker),
    ...(0, exports.validateBlock)(module, checker),
];
exports.validateModule = validateModule;
/**
 * Returns errors for root expressions (expressions directly at the module level) that are not allowed in the ASKIR schema
 * @param module module we are validating
 * @param checker unused
 * @returns errors for root expressions that are not allowed in the ASKIR schema
 */
const validateRootExpressions = (module, checker) => {
    var _a;
    const errors = [];
    // As seen on https://github.com/alexa/ask-expressions/blob/9a88ebd49ea69dd49ecd2952d2cd6682d41d6b85/packages/%40alexa/ask-expressions-spec/schemas/Module.json#L37
    const validRootExpressions = new Set([
        "ActionDeclaration",
        "DialogDeclaration",
        "InteractionDeclaration",
        "EnumDeclaration",
        "NameDeclaration",
        "TypeDeclaration",
    ]);
    for (const expression of module.expressions || []) {
        if (!validRootExpressions.has(expression.kind)) {
            errors.push(error_factory_1.ValidationErrorFactory.DeclarationExpected({
                expr: expression,
                attributes: {
                    text: expression.kind === "InteractionDeclaration" ? "" : ((_a = expression.name) === null || _a === void 0 ? void 0 : _a.name) || "",
                },
            }));
        }
    }
    return errors;
};
const validateBlock = (scope, checker) => {
    var _a;
    return [
        ...(0, exports.validateDuplicateNames)(scope, checker),
        ...((_a = scope.expressions) !== null && _a !== void 0 ? _a : []).map((expr) => (0, exports.validateExpression)(expr, checker)).reduce((a, b) => a.concat(b), []),
    ];
};
exports.validateBlock = validateBlock;
const validateNamespace = (module, checker) => {
    var _a;
    const nameSpace = (_a = module.namespace) === null || _a === void 0 ? void 0 : _a.name;
    // make sure the namespace doesn't contain reserved prefix
    const errors = [];
    if (nameSpace !== undefined) {
        constants_1.Constants.RESERVED_PREFIXES.forEach((prefix) => {
            if (nameSpace.startsWith(prefix)) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidNamespace({
                    expr: module.namespace,
                    attributes: {
                        prefix,
                    },
                }));
            }
        });
    }
    return errors;
};
exports.validateNamespace = validateNamespace;
/**
 * Validate the imports in a module.
 *
 * @param module ACDL file or ASK Module to validate.
 * @param checker type checker for querying the expressions.
 */
const validateImports = (module, checker) => {
    var _a;
    return ((_a = module.imports) === null || _a === void 0 ? void 0 : _a.map((imprt) => {
        if (imprt.kind === "ImportName") {
            if (checker.lookupQualifiedName(imprt.name) === undefined) {
                return [
                    error_factory_1.ValidationErrorFactory.InvalidImport({
                        expr: imprt,
                        attributes: {
                            importName: imprt.name,
                        },
                    }),
                ];
            }
        }
        else {
            const namespace = checker.listNamespace(imprt.name);
            if (namespace === undefined) {
                return [
                    error_factory_1.ValidationErrorFactory.InvalidImportNamespace({
                        expr: imprt,
                        attributes: {
                            importName: imprt.name,
                        },
                    }),
                ];
            }
        }
        return [];
    }).reduce((a, b) => a.concat(b), [])) || [];
};
exports.validateImports = validateImports;
const validateCircularReferences = (source, checker) => {
    var _a, _b, _c, _d, _e, _f, _g;
    if (source.kind === "TypeReference" || source.kind === "TypeDeclaration") {
        const type = source.kind === "TypeReference" ? checker.getType(source) : (_a = checker.getType(source)) === null || _a === void 0 ? void 0 : _a.getTypeType();
        if (type !== undefined) {
            if ((type === null || type === void 0 ? void 0 : type.properties) && type.declaration) {
                for (const prop of type.properties) {
                    if (prop.type === undefined || ((_b = prop.type) === null || _b === void 0 ? void 0 : _b.isOptional()) || ((_c = prop.type) === null || _c === void 0 ? void 0 : _c.isList()) || prop.type.isNothing()) {
                        continue;
                    }
                    else if (prop.type.extends(type) || prop.type.getReferences().has(type.declaration)) {
                        return [
                            error_factory_1.ValidationErrorFactory.CircularReferenceType({
                                expr: source.name,
                                attributes: {
                                    typeName: (_d = type.toString(source)) !== null && _d !== void 0 ? _d : source.name,
                                },
                            }),
                        ];
                    }
                }
            }
        }
    }
    else if ((_e = checker.getReferences(source)) === null || _e === void 0 ? void 0 : _e.has(source)) {
        const expr = source.name;
        return [
            source.kind === "DialogDeclaration"
                ? error_factory_1.ValidationErrorFactory.CircularReferenceDialog({
                    expr,
                    attributes: {
                        dialogName: (_f = source.name) === null || _f === void 0 ? void 0 : _f.name,
                    },
                })
                : error_factory_1.ValidationErrorFactory.CircularReferenceName({
                    expr,
                    attributes: {
                        name: (_g = source.name) === null || _g === void 0 ? void 0 : _g.name,
                    },
                }),
        ];
    }
    return [];
};
exports.validateCircularReferences = validateCircularReferences;
/**
 * Validates all annotations on a node.
 */
const validateAnnotations = (node, checker) => {
    var _a, _b;
    return [
        ...(0, exports.validateNameDeclarationAnnotations)(node, checker),
        ...(0, exports.validateTypeDeclarationAnnotations)(node, checker),
        ...(0, exports.validateDialogDeclarationAnnotations)(node, checker),
        ...((_b = (_a = node.annotations) === null || _a === void 0 ? void 0 : _a.flatMap((ann) => (0, exports.validateAnnotation)(ann, checker))) !== null && _b !== void 0 ? _b : []),
    ];
};
exports.validateAnnotations = validateAnnotations;
/**
 * Validates annotations on name declarations.
 *
 * There are two cases:
 *
 * 1. When the value is a `NameReference`, we should not allow any annotations.
 * 2. When the value is a `variations` call, we should not allow `locale` annotations.
 */
const validateNameDeclarationAnnotations = (node, checker) => {
    var _a, _b, _c;
    const errors = [];
    if (!ask.isNameDeclaration(node)) {
        return errors;
    }
    if (ask.isNameReference(node.expression)) {
        errors.push(...((_b = (_a = node.annotations) === null || _a === void 0 ? void 0 : _a.map((ann) => error_factory_1.ValidationErrorFactory.InvalidAnnotationNameDeclarationNameReference({
            expr: ann,
        }))) !== null && _b !== void 0 ? _b : []));
    }
    if (((_c = node.expression) === null || _c === void 0 ? void 0 : _c.kind) === "Call") {
        const apply = checker.getApply(node.expression);
        if ((apply === null || apply === void 0 ? void 0 : apply.isVariations()) && (node === null || node === void 0 ? void 0 : node.annotations)) {
            for (const ann of node === null || node === void 0 ? void 0 : node.annotations) {
                if (ann.kind === "Annotation" && ann.call && ann.call.kind === "Call") {
                    const annApply = checker.getApply(ann.call);
                    if (annApply === null || annApply === void 0 ? void 0 : annApply.isLocaleAction()) {
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationNameDeclarationVariations({
                            expr: ann,
                        }));
                    }
                }
            }
        }
    }
    return errors;
};
exports.validateNameDeclarationAnnotations = validateNameDeclarationAnnotations;
/**
 * Validates annotations on type declarations, and the properties of the type.
 *
 * There is one case:
 *
 * 1. We should not allow `referable` annotation on type properties that aren't catalogs.
 */
const validateTypeDeclarationAnnotations = (node, checker) => {
    var _a, _b, _c, _d;
    const errors = [];
    if (!ask.isTypeDeclaration(node)) {
        return errors;
    }
    for (const property of (_a = node.properties) !== null && _a !== void 0 ? _a : []) {
        for (const ann of (_b = property.annotations) !== null && _b !== void 0 ? _b : []) {
            const apply = checker.getApply(ann.call);
            if (apply === null || apply === void 0 ? void 0 : apply.isReferableAction()) {
                const type = checker.getType(property.type);
                if (!(type === null || type === void 0 ? void 0 : type.hasCatalog())) {
                    errors.push(error_factory_1.ValidationErrorFactory.InvalidReferableAnnotation({
                        expr: ann,
                        attributes: {
                            typeName: (_c = node.name) === null || _c === void 0 ? void 0 : _c.name,
                            propertyName: (_d = property.name) === null || _d === void 0 ? void 0 : _d.name,
                        },
                    }));
                }
            }
        }
    }
    return errors;
};
exports.validateTypeDeclarationAnnotations = validateTypeDeclarationAnnotations;
/**
 * Validates annotations on dialog declarations.
 *
 * There are two cases:
 *
 * 1. When dialog is reusable, we should not allow the dialog to have a `locale` annotation.
 * 2. When dialog is reusable, we should not allow the dialog samples to have a `locale` annotation.
 */
const validateDialogDeclarationAnnotations = (node, checker) => {
    var _a;
    const errors = [];
    if (!ask.isDialogDeclaration(node)) {
        return errors;
    }
    // locale annotation is not allowed on reusable dialog
    if (!checker.project.isRootDialog(node)) {
        if (node.annotations && node.annotations.length > 0) {
            for (const ann of node === null || node === void 0 ? void 0 : node.annotations) {
                if (ann.kind === "Annotation" && ann.call && ann.call.kind === "Call") {
                    const annApply = checker.getApply(ann.call);
                    if (annApply === null || annApply === void 0 ? void 0 : annApply.isLocaleAction()) {
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationReusableDialog({
                            expr: ann,
                        }));
                    }
                }
            }
        }
        // locale annotation is not allowed on reusable dialogs' samples
        (_a = node.samples) === null || _a === void 0 ? void 0 : _a.forEach((sample) => {
            if (sample.annotations && sample.annotations.length > 0) {
                for (const ann of sample === null || sample === void 0 ? void 0 : sample.annotations) {
                    if (ann.kind === "Annotation" && ann.call && ann.call.kind === "Call") {
                        const annApply = checker.getApply(ann.call);
                        if (annApply === null || annApply === void 0 ? void 0 : annApply.isLocaleAction()) {
                            errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationReusableDialogSample({
                                expr: ann,
                            }));
                        }
                    }
                }
            }
        });
        if (errors.length > 0)
            return errors;
    }
    return errors;
};
exports.validateDialogDeclarationAnnotations = validateDialogDeclarationAnnotations;
/**
 * Validate an Annotation's Call data structure:
 *
 * 1. the annotation type must also be annotated with the meta-annotation `@com.amazon.alexa.ask.conversations.Annotation`.
 * 2. the list of supported targets for the annotation must include the target this annotation is being applied to,
 */
const validateAnnotation = (annotation, checker) => {
    var _a, _b, _c;
    const errors = (0, exports.validateCall)(annotation.call, checker);
    const annotationTarget = ast_1.AnnotationTarget.from(annotation.context.kind);
    const target = checker.getApply(annotation.call);
    const decl = (target === null || target === void 0 ? void 0 : target.decl.kind) === "Type" ? target.decl.declaration : target === null || target === void 0 ? void 0 : target.decl;
    if ((decl === null || decl === void 0 ? void 0 : decl.kind) === "ActionDeclaration") {
        const annotationDescription = (_a = decl.annotations) === null || _a === void 0 ? void 0 : _a.map((a) => checker.getApply(a.call)).find((a) => a === null || a === void 0 ? void 0 : a.isAnnotationAction());
        if (annotationDescription) {
            const allowMultiple = annotationDescription.getAnnotationAllowMultiple();
            if (allowMultiple === false) {
                const duplicates = (_b = annotation.context.annotations) === null || _b === void 0 ? void 0 : _b.filter((an) => { var _a, _b, _c, _d; return ((_c = (_b = (_a = checker.getApply(an.call)) === null || _a === void 0 ? void 0 : _a.decl) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name) === ((_d = decl.name) === null || _d === void 0 ? void 0 : _d.name); });
                if (duplicates && duplicates.length > 1) {
                    errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationMultiple({
                        expr: annotation,
                        attributes: {
                            annotatedType: target === null || target === void 0 ? void 0 : target.getName(),
                        },
                    }));
                }
            }
            const targets = annotationDescription.getAnnotationTargets();
            if ((targets === null || targets === void 0 ? void 0 : targets.find((a) => a === annotationTarget)) === undefined) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationTarget({
                    expr: annotation,
                    attributes: {
                        annotatedType: target === null || target === void 0 ? void 0 : target.getName(),
                        annotationTarget,
                        expectedAnnotationTargets: (_c = targets === null || targets === void 0 ? void 0 : targets.map((t) => `'AnnotationTarget.${t}'`).join(", ")) !== null && _c !== void 0 ? _c : "",
                    },
                }));
            }
        }
        else {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationMetaAnnotation({
                expr: annotation,
                attributes: {
                    annotationType: target === null || target === void 0 ? void 0 : target.getName(),
                },
            }));
        }
    }
    return errors;
};
exports.validateAnnotation = validateAnnotation;
const validateExpression = (expr, checker) => {
    if (expr === undefined) {
        return [];
    }
    if (expr.kind === "Module") {
        // return validateModule(expr, checker);
    }
    else if (expr.kind === "InteractionDeclaration") {
        return (0, exports.validateInteractionDeclaration)(expr, checker);
    }
    else if (expr.kind === "Correction") {
        return (0, exports.validateCorrection)(expr, checker);
    }
    else if (expr.kind === "ActionDeclaration") {
        return (0, exports.validateActionDeclaration)(expr, checker);
    }
    else if (expr.kind === "Argument") {
        return (0, exports.validateExpression)(expr.value, checker);
    }
    else if (expr.kind === "Call") {
        return (0, exports.validateCall)(expr, checker);
    }
    else if (expr.kind === "Condition") {
        return (0, exports.validateCondition)(expr, checker);
    }
    else if (expr.kind === "DialogDeclaration") {
        return (0, exports.validateDialogDeclaration)(expr, checker);
    }
    else if (expr.kind === "EnumDeclaration") {
        return (0, exports.validateEnumDeclaration)(expr, checker);
    }
    else if (expr.kind === "NameDeclaration") {
        return (0, exports.validateNameDeclaration)(expr, checker);
    }
    else if (expr.kind === "NameReference") {
        return (0, exports.validateNameReference)(expr, checker);
    }
    else if (expr.kind === "Sample") {
        return (0, exports.validateSample)(expr, checker);
    }
    else if (expr.kind === "TypeDeclaration") {
        return (0, exports.validateTypeDeclaration)(expr, checker);
    }
    else if (expr.kind === "Block") {
        return (0, exports.validateBlock)(expr, checker);
    }
    else if (expr.kind === "PropertyReference") {
        return (0, exports.validatePropertyReference)(expr, checker);
    }
    else if (expr.kind === "When") {
        return (0, exports.validateExpression)(expr.expression, checker);
    }
    console.warn(`can not validate expression kind '${expr.kind}'`);
    return [];
};
exports.validateExpression = validateExpression;
const validateDialogDeclaration = (dialog, checker) => {
    var _a, _b, _c;
    return [
        ...(dialog.samples === undefined || dialog.samples.length === 0
            ? [
                error_factory_1.ValidationErrorFactory.EmptyDialog({
                    expr: dialog,
                    attributes: {
                        dialogName: (_a = dialog.name) === null || _a === void 0 ? void 0 : _a.name,
                    },
                }),
            ]
            : []),
        ...(0, exports.validateTypeReference)(dialog.returnType, checker),
        ...(0, exports.validateTypeParameters)(dialog.genericArguments, checker),
        ...(dialog.arguments ? validateArgumentDeclarations(dialog.arguments, checker, true) : []),
        ...(0, exports.validateAnnotations)(dialog, checker),
        ...((_c = (_b = dialog.samples) === null || _b === void 0 ? void 0 : _b.map((sample) => (0, exports.validateSample)(sample, checker)).reduce((a, b) => a.concat(b), [])) !== null && _c !== void 0 ? _c : []),
        ...(0, exports.validateCircularReferences)(dialog, checker),
    ];
};
exports.validateDialogDeclaration = validateDialogDeclaration;
const validateSample = (sample, checker) => {
    var _a, _b;
    if (sample.scope === undefined) {
        return [];
    }
    const dialog = sample.context;
    const errors = [...(0, exports.validateBlock)(sample.scope, checker), ...(0, exports.validateAnnotations)(sample, checker)];
    if (errors.length > 0) {
        return errors; // return if basic parse errors exist for each sample, before checking from entire sample scope
    }
    if (sample.scope.expressions === undefined || sample.scope.expressions.length === 0) {
        errors.push(error_factory_1.ValidationErrorFactory.EmptySample({
            expr: sample,
            attributes: {
                dialogName: (_a = dialog.name) === null || _a === void 0 ? void 0 : _a.name,
            },
        }));
    }
    const expectedType = checker.getType(dialog.returnType) || checker.void;
    const actualType = checker.getType(sample.scope) || checker.void;
    if (!expectedType.isVoid() && !expectedType.isNothing() && !actualType.extends(expectedType)) {
        const last = sample.scope.expressions[sample.scope.expressions.length - 1];
        if (last) {
            errors.push(error_factory_1.ValidationErrorFactory.TypeErrorDialogLastExpr({
                expr: last,
                attributes: {
                    dialogName: (_b = dialog.name) === null || _b === void 0 ? void 0 : _b.name,
                    expectedType: expectedType.toString(sample),
                    actualType: actualType.toString(sample),
                },
            }));
        }
    }
    return errors;
};
exports.validateSample = validateSample;
function hasName(expr) {
    var _a;
    return ((expr.kind === "NameDeclaration" ||
        expr.kind === "TypeDeclaration" ||
        expr.kind === "ActionDeclaration" ||
        expr.kind === "DialogDeclaration") &&
        ((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined);
}
const validateDuplicateNames = (scope, checker) => {
    var _a, _b, _c;
    const errors = [];
    if (scope.kind === "Module") {
        const moduleUri = checker.getUri(scope);
        (_a = scope.expressions) === null || _a === void 0 ? void 0 : _a.forEach((expr) => {
            var _a;
            if (expr.kind !== "InteractionDeclaration" && ((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name)) {
                const declarations = checker.global.scope.get(expr.name.name);
                if (Array.isArray(declarations)) {
                    const files = Array.from(new Set(declarations
                        .map((d) => checker.getUri(d))
                        .filter((uri) => uri !== undefined && uri !== moduleUri)
                        .map((uri) => path_1.default.relative(checker.project.config.rootDir, uri))
                        .map((uri) => `'${(0, util_1.trimScheme)(uri)}'`)));
                    errors.push(error_factory_1.ValidationErrorFactory.DuplicateNameDeclarationInModule({
                        expr,
                        attributes: {
                            name: expr.name.name,
                            filesLength: files.length,
                            fileNames: files.join(", "),
                        },
                    }));
                }
            }
        });
    }
    else {
        const seen = new Set();
        const duplicates = new Set();
        const parentScope = checker.getVisibleNames(scope.context, false);
        (_b = scope.expressions) === null || _b === void 0 ? void 0 : _b.forEach((expr) => {
            if (hasName(expr)) {
                const name = expr.name.name;
                if (seen.has(name) || (parentScope === null || parentScope === void 0 ? void 0 : parentScope.has(name)) || checker.global.scope.has(name)) {
                    duplicates.add(name);
                }
                seen.add(name);
            }
        });
        (_c = scope.expressions) === null || _c === void 0 ? void 0 : _c.forEach((expr) => {
            var _a;
            if (hasName(expr) && duplicates.has((_a = expr.name) === null || _a === void 0 ? void 0 : _a.name)) {
                errors.push(error_factory_1.ValidationErrorFactory.DuplicateNameDeclaration({
                    expr: expr.name,
                    attributes: {
                        name: expr.name.name,
                    },
                }));
            }
        });
    }
    return errors;
};
exports.validateDuplicateNames = validateDuplicateNames;
/**
 * Validates a name expression.
 *
 * @param checker
 * @param name
 */
const validateNameDeclaration = (name, checker) => {
    var _a;
    const errors = name.expression ? [...(0, exports.validateExpression)(name.expression, checker)] : [];
    errors.push(...(0, exports.validateCircularReferences)(name, checker));
    errors.push(...(0, exports.validateAnnotations)(name, checker));
    const valueType = checker.getType(name.expression);
    const explicitType = name.type ? checker.instantiateTypeReference(name.type) : undefined;
    if (name.type !== undefined) {
        errors.push(...(0, exports.validateTypeReference)(name.type, checker));
    }
    if (explicitType !== undefined && valueType !== undefined) {
        if (!valueType.extends(explicitType)) {
            errors.push((0, error_1.typeError)(valueType, explicitType, name, name.name));
        }
    }
    if (valueType === undefined) {
    }
    // declare a name with an expression of type Nothing is invalid
    const nameType = checker.getType(name.expression);
    if ((nameType === null || nameType === void 0 ? void 0 : nameType.isNothing()) || (nameType === null || nameType === void 0 ? void 0 : nameType.isVoid())) {
        errors.push(error_factory_1.ValidationErrorFactory.InvalidNameDeclaration({
            expr: name.name,
            attributes: {
                name: (_a = name.name) === null || _a === void 0 ? void 0 : _a.name,
                nothingTypeName: checker.nothing.toString(name),
                voidTypeName: checker.void.toString(name),
            },
        }));
    }
    return errors;
};
exports.validateNameDeclaration = validateNameDeclaration;
const validateNameReference = (id, checker) => [...(0, exports.validateName)(id, checker)];
exports.validateNameReference = validateNameReference;
const validateName = (id, checker) => {
    var _a;
    const found = lookupName(id, id.name);
    if (found === undefined) {
        // For Call, it's valid when name is undefined, like listLiteral
        if (id.name !== undefined && id.kind !== "Call") {
            return [(0, error_1.nameNotFound)(id.name)];
        }
    }
    else if (Array.isArray(found)) {
        const declares = found
            .map((f) => {
            if (f.kind === "ResponseTemplate") {
                return f.type === ask.ResponseTemplateType.Prompt ? `'prompts.${f.name}'` : `'displays.${f.name}'`;
            }
            return `'${f.name.name}'`;
        })
            .filter((f) => f !== undefined)
            .join(", ");
        return [
            error_factory_1.ValidationErrorFactory.AmbiguousNameReference({
                expr: id,
                attributes: {
                    name: (_a = id.name) === null || _a === void 0 ? void 0 : _a.name,
                    possibleName: declares,
                },
            }),
        ];
    }
    return [];
    function lookupName(scope, name) {
        if (name === undefined) {
            return undefined;
        }
        const nameStr = typeof name === "string" ? name : name.name;
        if (checker.global.scope.has(nameStr)) {
            return checker.global.scope.get(nameStr);
        }
        const lexicalScope = checker.getVisibleNames(scope);
        if (lexicalScope === null || lexicalScope === void 0 ? void 0 : lexicalScope.has(nameStr)) {
            return lexicalScope.get(nameStr);
        }
        return undefined;
    }
};
exports.validateName = validateName;
const validateActionDeclaration = (action, checker) => [
    ...(0, exports.validateTypeReference)(action.returnType, checker),
    ...(0, exports.validateTypeParameters)(action.genericArguments, checker),
    ...(action.arguments ? validateArgumentDeclarations(action.arguments, checker, false) : []),
    ...(0, exports.validateAnnotations)(action, checker),
    ...(0, exports.validateAnnotatedActionDeclaration)(action, checker),
];
exports.validateActionDeclaration = validateActionDeclaration;
/**
 * Validates that an ActionDeclaration that is annotated with the `@annotation` meta-annotation has a return type of void.
 */
const validateAnnotatedActionDeclaration = (action, checker) => {
    var _a, _b, _c;
    if (((_a = action.annotations) === null || _a === void 0 ? void 0 : _a.find((a) => checker.qualifyName(action, a.call.name) === ast_1.AlexaConversations.annotation)) !== undefined) {
        const actionDeclType = checker.getType(action);
        if ((actionDeclType === null || actionDeclType === void 0 ? void 0 : actionDeclType.isAction()) && ((_b = actionDeclType === null || actionDeclType === void 0 ? void 0 : actionDeclType.getPropertyType("returnType")) === null || _b === void 0 ? void 0 : _b.getTypeType())) {
            const returnType = (_c = actionDeclType === null || actionDeclType === void 0 ? void 0 : actionDeclType.getPropertyType("returnType")) === null || _c === void 0 ? void 0 : _c.getTypeType();
            if (returnType && !(returnType.isVoid() || returnType.isNothing())) {
                return [
                    error_factory_1.ValidationErrorFactory.InvalidAnnotationMetaAnnotationReturnType({
                        expr: action.name,
                    }),
                ];
            }
        }
    }
    return [];
};
exports.validateAnnotatedActionDeclaration = validateAnnotatedActionDeclaration;
function validateArgumentDeclarations(args, checker, isDialogArgument) {
    var _a, _b, _c, _d, _e;
    const seen = new Set();
    const duplicates = new Set();
    const errors = [];
    let isRequiredArgAllowed = true;
    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) {
            if (seen.has(arg.name.name)) {
                duplicates.add(arg.name.name);
            }
            seen.add((_b = arg.name) === null || _b === void 0 ? void 0 : _b.name);
        }
        const hasMoreArgs = args[i + 1] !== undefined;
        const type = checker.instantiateTypeReference(arg.type);
        if ((type === null || type === void 0 ? void 0 : type.isArgs()) && hasMoreArgs) {
            errors.push(error_factory_1.ValidationErrorFactory.VarArgsMustBeLast({
                expr: arg,
            }));
        }
        if (type === null || type === void 0 ? void 0 : type.isOptional()) {
            isRequiredArgAllowed = false;
        }
        else if (!(type === null || type === void 0 ? void 0 : type.isArgs()) && !isRequiredArgAllowed) {
            errors.push(error_factory_1.ValidationErrorFactory.RequiredArgExistAfterOptionalArg({
                expr: arg,
                attributes: {
                    argumentName: (_c = arg.name) === null || _c === void 0 ? void 0 : _c.name,
                },
            }));
        }
        errors.push(...validateArgumentDeclaration(arg, checker, isDialogArgument));
    }
    for (const arg of args) {
        if (((_d = arg.name) === null || _d === void 0 ? void 0 : _d.name) && duplicates.has((_e = arg.name) === null || _e === void 0 ? void 0 : _e.name)) {
            errors.push(error_factory_1.ValidationErrorFactory.DuplicateArgument({
                expr: arg.name,
                attributes: {
                    argumentName: arg.name.name,
                },
            }));
        }
    }
    return errors;
}
exports.validateArgumentDeclarations = validateArgumentDeclarations;
function validateArgumentDeclaration(arg, checker, isDialogArgument = false) {
    const errors = [
        ...(0, exports.validateExpression)(arg.defaultExpression, checker),
        ...(0, exports.validateTypeReference)(arg.type, checker),
        ...(0, exports.validateAnnotations)(arg, checker),
    ];
    if (arg.name === undefined) {
        errors.push(error_factory_1.ValidationErrorFactory.SyntaxError({
            expr: (0, error_factory_1.getExpressionIfLocField)(arg.type, arg),
            overrideMessage: "expected name for argument declaration.",
        }));
    }
    if (arg.defaultExpression) {
        const actualType = checker.getType(arg.defaultExpression);
        const expectedType = checker.getType(arg.type);
        if (actualType && expectedType && !actualType.extends(expectedType)) {
            errors.push((0, error_1.typeError)(actualType, expectedType, arg.defaultExpression, arg.defaultExpression));
        }
        // Arguments' default value must be nothing except dialogArgument
        if (!isDialogArgument) {
            const thing = checker.getThing(arg.defaultExpression);
            if (!((thing === null || thing === void 0 ? void 0 : thing.isNothing()) && thing.isLiteral())) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidApiArgumentDefaultValue({
                    expr: arg,
                }));
            }
        }
        else {
            // for dialogArgument, the default expression canâ€™t call dialogs, user defined APIs or branch with conditions
        }
    }
    return errors;
}
exports.validateArgumentDeclaration = validateArgumentDeclaration;
/**
 * Validate that an EnumDeclaration has at least one item and no duplicate items.
 *
 * ```acdl
 * enum E {} // invalid
 * enum E { // invalid
 *   A
 *   A
 * }
 * enum E { // valid
 *   A
 *   B
 * }
 * ```
 */
const validateEnumDeclaration = (enumDecl, checker) => {
    var _a, _b, _c, _d;
    if (enumDecl.items === undefined || enumDecl.items.length === 0) {
        return [
            error_factory_1.ValidationErrorFactory.EmptyEnumDeclaration({
                expr: enumDecl,
                attributes: {
                    enumName: (_a = enumDecl.name) === null || _a === void 0 ? void 0 : _a.name,
                },
            }),
            ...(0, exports.validateAnnotations)(enumDecl, checker),
        ];
    }
    const names = new Set();
    const dups = new Set();
    (_b = enumDecl.items) === null || _b === void 0 ? void 0 : _b.forEach((item) => {
        var _a, _b;
        if ((_a = item.name) === null || _a === void 0 ? void 0 : _a.name) {
            if (names.has((_b = item.name) === null || _b === void 0 ? void 0 : _b.name)) {
                dups.add(item.name.name);
            }
            else {
                names.add(item.name.name);
            }
        }
    });
    if (dups.size === 0) {
        return [];
    }
    return [
        ...(0, exports.validateAnnotations)(enumDecl, checker),
        ...((_d = (_c = enumDecl.items) === null || _c === void 0 ? void 0 : _c.map((item) => {
            var _a;
            if (((_a = item.name) === null || _a === void 0 ? void 0 : _a.name) && dups.has(item.name.name)) {
                return error_factory_1.ValidationErrorFactory.DuplicateEnumItem({
                    expr: item,
                    attributes: {
                        enumItemName: item.name.name,
                    },
                });
            }
            return undefined;
        }).filter((e) => e !== undefined)) !== null && _d !== void 0 ? _d : []),
    ];
};
exports.validateEnumDeclaration = validateEnumDeclaration;
const validateTypeDeclaration = (type, checker) => {
    var _a;
    return [
        ...(0, exports.validateTypeReferences)((_a = type.properties) === null || _a === void 0 ? void 0 : _a.map((p) => p.type).filter((t) => t !== undefined), checker),
        ...(0, exports.validateTypeReferences)(type.extensions, checker),
        ...(0, exports.validateTypeParameters)(type.genericArguments, checker),
        ...(0, exports.validateCircularReferences)(type, checker),
        ...(0, exports.validateAnnotations)(type, checker),
        ...(0, exports.validateTypeDeclarationProperties)(type, checker),
    ];
};
exports.validateTypeDeclaration = validateTypeDeclaration;
/**
 * validate the properties in typeDecl are not duplicate
 */
const validateTypeDeclarationProperties = (typeDecl, checker) => {
    var _a, _b, _c;
    const seen = new Set((_a = typeDecl.extensions) === null || _a === void 0 ? void 0 : _a.map((ext) => { var _a, _b, _c; return (_c = (_b = (_a = checker.getType(ext)) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.map((p) => p.name)) !== null && _c !== void 0 ? _c : []; }).reduce((a, b) => a.concat(b), []));
    return ((_c = (_b = typeDecl.properties) === null || _b === void 0 ? void 0 : _b.map((prop) => {
        var _a;
        const name = (_a = prop.name) === null || _a === void 0 ? void 0 : _a.name;
        if (name === undefined) {
            return error_factory_1.ValidationErrorFactory.SyntaxError({
                expr: (0, error_factory_1.getExpressionIfLocField)(prop.type, prop),
                overrideMessage: "expected property name.",
            });
        }
        if (seen.has(name)) {
            return error_factory_1.ValidationErrorFactory.DuplicatePropertyRedeclared({
                expr: prop,
                attributes: {
                    propertyName: name,
                },
            });
        }
        seen.add(name);
        return undefined;
    }).filter((e) => e !== undefined)) !== null && _c !== void 0 ? _c : []);
};
exports.validateTypeDeclarationProperties = validateTypeDeclarationProperties;
const validateTypeParameters = (params, checker) => { var _a; return (_a = params === null || params === void 0 ? void 0 : params.map((param) => (0, exports.validateTypeParameter)(param, checker)).flat()) !== null && _a !== void 0 ? _a : []; };
exports.validateTypeParameters = validateTypeParameters;
const validateTypeParameter = (param, checker) => (0, exports.validateTypeReferences)(param.constraints, checker);
exports.validateTypeParameter = validateTypeParameter;
const validateTypeReferences = (refs, checker) => { var _a; return (_a = refs === null || refs === void 0 ? void 0 : refs.map((ref) => (0, exports.validateTypeReference)(ref, checker)).flat()) !== null && _a !== void 0 ? _a : []; };
exports.validateTypeReferences = validateTypeReferences;
const validateTypeReference = (ref, checker) => {
    var _a, _b;
    const errors = [];
    if (ref) {
        // check if the call name could be resolved, error if fail to resolve call name
        errors.push(...(0, exports.validateName)(ref, checker));
        if (errors.length > 0) {
            return errors;
        }
        errors.push(...(0, exports.validateCircularReferences)(ref, checker));
        const typeDecl = checker.lookupTypeReference(ref);
        if (typeDecl === undefined) {
            errors.push((0, error_1.nameNotFound)(ref.name));
        }
        if (ref.arguments) {
            for (const arg of ref.arguments) {
                errors.push(...(0, exports.validateTypeReference)(arg, checker));
            }
        }
        if (typeDecl && errors.length === 0) {
            const type = checker.instantiateTypeReference(ref);
            if (type !== undefined) {
                if (typeDecl.kind === "TypeDeclaration") {
                    if (typeDecl.genericArguments) {
                        if (typeDecl.genericArguments.length !== ((_a = type.genericArguments) === null || _a === void 0 ? void 0 : _a.length)) {
                            errors.push(error_factory_1.ValidationErrorFactory.TypeErrorRequiredTypeArguments({
                                expr: ref,
                                attributes: {
                                    typeDeclarationName: (_b = typeDecl.name) === null || _b === void 0 ? void 0 : _b.name,
                                    numArguments: typeDecl.genericArguments.length,
                                },
                            }));
                        }
                        else {
                            type.genericArguments.forEach((genericArgument, i) => {
                                var _a, _b;
                                const typeParameter = (_a = typeDecl.genericArguments) === null || _a === void 0 ? void 0 : _a[i];
                                if (typeParameter !== undefined && typeParameter.constraints && genericArgument !== undefined) {
                                    for (const constraint of typeParameter.constraints) {
                                        const constraintType = checker.instantiateTypeReference(constraint, type.environment);
                                        if (constraintType && !genericArgument.extends(constraintType)) {
                                            errors.push((0, error_1.typeError)(genericArgument, constraintType, ref, (_b = ref.arguments) === null || _b === void 0 ? void 0 : _b[i]));
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }
        }
    }
    return errors;
};
exports.validateTypeReference = validateTypeReference;
/**
 * Validate an `alexa.lang.property` call to access a property on a type.
 *
 * @param ref call expression representing the access of a property on another expression
 */
const validatePropertyReference = (ref, checker) => {
    // property does not exist
    const { name } = ref;
    const expr = ref.expression;
    const exprType = checker.getType(expr);
    if ((name === null || name === void 0 ? void 0 : name.name) === undefined) {
        return [
            error_factory_1.ValidationErrorFactory.IdentifierExpected({
                expr: (0, error_factory_1.getExpressionIfLocField)(ref.name, ref),
            }),
        ];
    }
    const qualifiedName = ask.PropertyReference.tryResolveQualifiedName(ref);
    if (qualifiedName !== undefined && checker.lookupQualifiedName(qualifiedName) !== undefined) {
        return [];
    }
    if (exprType !== undefined) {
        const prop = exprType.getProperty(name.name);
        if (prop === undefined) {
            return [
                ...(0, exports.validateExpression)(expr, checker),
                error_factory_1.ValidationErrorFactory.UnknownProperty({
                    expr: (0, error_factory_1.getExpressionIfLocField)(ref.name, ref),
                    attributes: {
                        propertyName: name.name,
                        typeName: exprType.toString(ref),
                    },
                }),
            ];
        }
    }
    return (0, exports.validateExpression)(expr, checker);
};
exports.validatePropertyReference = validatePropertyReference;
const validateUtteranceTypeWrapper = (apply) => {
    var _a;
    const errors = [];
    if (!apply.isUtterances()) {
        return [];
    }
    const utteranceType = (_a = apply.getReturnType()) === null || _a === void 0 ? void 0 : _a.getUtteranceEventType();
    if (!(utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.isValidUtteranceWrapper())) {
        errors.push(error_factory_1.ValidationErrorFactory.UtteranceEventTypeMustReferToWrapper({
            expr: utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.declaration,
            attributes: {
                typeName: utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.shortName,
            },
        }));
    }
    return errors;
};
exports.validateUtteranceTypeWrapper = validateUtteranceTypeWrapper;
/**
 * Validate a Call to a Type or an Action:
 *
 * - Resolve its declaration and throw errors if it cannot be found.
 * - Infer generic arguments if they aren't provided and flag errors if that cannot be achieved.
 * - Validate that all required arguments are provided and that types of arguments match declaration.
 */
const validateCall = (call, checker) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const errors = [];
    // check if the call name could be resolved, error if fail to resolve call name
    errors.push(...(0, exports.validateName)(call, checker));
    const getPropertyMap = (0, lazy_1.memoize)((type) => type.getPropertyMap());
    if (errors.length > 0) {
        return errors;
    }
    const apply = checker.getApply(call);
    if (call.genericArguments) {
        errors.push(...(0, exports.validateTypeReferences)(call.genericArguments, checker));
    }
    if (apply === undefined) {
        if (((_a = call.name) === null || _a === void 0 ? void 0 : _a.name) === undefined) {
            // could not infer anonymous type
            errors.push(error_factory_1.ValidationErrorFactory.CouldNotInferAnonymousType({
                expr: call,
            }));
        }
        else {
            errors.push((0, error_1.nameNotFound)(call.name));
        }
    }
    else {
        errors.push(...(0, validate_skill_1.validateSkillCallContext)(apply));
        errors.push(...(0, exports.validateRequireCall)(apply, checker));
        errors.push(...(0, exports.validateValidateArgAnnotation)(apply, checker));
        if (apply.isAnnotation()) {
            // if this is a call to an Annotation, we must ensure that it is in an Annotation context.
            if (apply.call.context.kind !== "Annotation" && apply.call.getSample() !== undefined) {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidAnnotationCall({
                    expr: call,
                    attributes: {
                        annotationTarget: apply.getName(),
                    },
                }));
            }
        }
        else if (apply.isEventDecl() || apply.isFileAccessAction() || apply.isSkillAction() || apply.isWelcome() || apply.isVariations()) {
            if (apply.isSkillAction()) {
                errors.push(...(0, validate_skill_1.validateSkillCallContext)(apply));
            }
            else if (call.context.kind !== "NameDeclaration" || ((_b = call.context.context) === null || _b === void 0 ? void 0 : _b.kind) !== "Module") {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidCallContextModuleNameDeclaration({
                    expr: call,
                    attributes: {
                        actionName: checker.qualifyName(call, (_c = call.name) === null || _c === void 0 ? void 0 : _c.name),
                    },
                }));
            }
            if (apply.isWelcome()) {
                const actionValue = apply.getArgumentValue("action");
                const actionType = checker.getType(actionValue);
                if (actionType === null || actionType === void 0 ? void 0 : actionType.isAction()) {
                    if (actionType.isBuiltIn()) {
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidWelcomeAction({
                            expr: actionValue,
                        }));
                    }
                    const returnType = (_d = actionType.getPropertyType("returnType")) === null || _d === void 0 ? void 0 : _d.getTypeType();
                    if (returnType) {
                        if (returnType.isVoid() || returnType.isNothing()) {
                            errors.push(error_factory_1.ValidationErrorFactory.InvalidWelcomeActionReturnValue({
                                expr: actionValue,
                            }));
                        }
                    }
                }
            }
            else if (apply.isVariations()) {
                errors.push(...(0, exports.validateVariations)(call, checker));
            }
        }
        else if (apply.isType() || apply.isGetListItem()) {
            // TODO: should we allow operators and get list item?
            if (apply.isResetArguments() || apply.isResetAllArguments() || apply.isEnsureArgOrder()) {
                const argumentsValue = apply.getArgumentValue("arguments");
                // for ResetArguments, all the arguments in the list should from same api
                if (apply.isResetArguments()) {
                    errors.push(...(0, evaluate_1.validateArgumentListThing)(checker.getThing(argumentsValue), argumentsValue));
                }
                // for EnsureArgOrder, all the arguments in the list should be required args
                if (apply.isEnsureArgOrder()) {
                    errors.push(...(0, exports.validateEnsureArgOrder)(apply, checker));
                }
            }
        }
        else if (call.findInContext(ask.isAnnotation) === undefined) {
            errors.push(...(0, exports.validateCallContext)(call, checker));
        }
        if (apply.isUtterances()) {
            errors.push(...(0, exports.validateUtteranceTypeWrapper)(apply, checker));
        }
        if (apply.getName() === ast_1.AlexaConversations.utterances && checker.isNameReference((_e = apply.getArguments()) === null || _e === void 0 ? void 0 : _e.samples.value)) {
            errors.push(...(0, exports.validateNamedArguments)(apply, checker, false)); // check the arguments but don't type check - we will do this in a custom way
            // special case - we're calling utterances with a name reference to a List.
            // we need to find that list and validate
            const value = (_f = apply.getArguments()) === null || _f === void 0 ? void 0 : _f.samples.value;
            const found = checker.resolveNameReference(value);
            const foundType = checker.getType(value);
            if (ask.isCall(found) && ask.isListLiteral(found.arguments) && (foundType === null || foundType === void 0 ? void 0 : foundType.isList())) {
                // if empty list, throw error
                if (found.arguments.items.length === 0) {
                    errors.push(error_factory_1.ValidationErrorFactory.EmptyUtteranceSet({
                        expr: found.arguments,
                    }));
                }
                else if ((_g = foundType.getListItemType()) === null || _g === void 0 ? void 0 : _g.isString()) {
                    // yes, we are referencing a List<String> literal
                    const utteranceType = (_h = apply.getGenericArguments()) === null || _h === void 0 ? void 0 : _h[0];
                    for (const item of found.arguments.items) {
                        if (item.item !== undefined) {
                            // TODO: should we change the error message to provide more help? the error is associated with an afar list literal but attached to the name reference
                            errors.push(...(0, exports.validateUtterance)(item.item, utteranceType, getPropertyMap).map((e) => {
                                var _a;
                                return ({
                                    ...e,
                                    loc: value.loc,
                                    uri: (_a = e.uri) !== null && _a !== void 0 ? _a : value.uri,
                                });
                            }));
                        }
                    }
                }
            }
            else {
                errors.push(error_factory_1.ValidationErrorFactory.InvalidUtteranceArg({
                    expr: value,
                }));
            }
        }
        else {
            if (apply.getName() === ast_1.AlexaConversations.utterances) {
                const utteranceList = (_k = (_j = apply.getArguments()) === null || _j === void 0 ? void 0 : _j.samples) === null || _k === void 0 ? void 0 : _k.value;
                if ((utteranceList === null || utteranceList === void 0 ? void 0 : utteranceList.kind) === "Call" && ask.isListLiteral(utteranceList.arguments) && utteranceList.arguments.items.length === 0) {
                    errors.push(error_factory_1.ValidationErrorFactory.EmptyUtteranceSet({
                        expr: utteranceList.arguments,
                    }));
                }
            }
            errors.push(...(0, exports.validateNamedArguments)(apply, checker));
            const genericArguments = apply.getGenericArguments();
            const genericEnvironment = apply.getGenericEnvironment();
            if (apply.decl.genericArguments !== undefined && genericArguments === undefined) {
                errors.push(error_factory_1.ValidationErrorFactory.CouldNotInferGenericArguments({
                    expr: call,
                    attributes: {
                        argumentName: (_l = apply.decl.name) === null || _l === void 0 ? void 0 : _l.name,
                    },
                }));
            }
            else if (genericArguments && ((_m = apply.decl.genericArguments) === null || _m === void 0 ? void 0 : _m.length) === (genericArguments === null || genericArguments === void 0 ? void 0 : genericArguments.length)) {
                const decl = apply.decl.kind === "Type" ? apply.decl.declaration : apply.decl;
                if (decl &&
                    decl.kind !== "TypeParameter" &&
                    decl.kind !== "SlotType" &&
                    decl.kind !== "EnumDeclaration" &&
                    decl.kind !== "EnumItemDeclaration" &&
                    decl.kind !== "TypeReference") {
                    (_o = decl.genericArguments) === null || _o === void 0 ? void 0 : _o.forEach((genericArgument, i) => {
                        var _a, _b;
                        const actualType = genericArguments === null || genericArguments === void 0 ? void 0 : genericArguments[i];
                        if (actualType && genericArgument.constraints) {
                            for (const constraint of genericArgument.constraints) {
                                const expectedType = checker.instantiateTypeReference(constraint, genericEnvironment);
                                if (expectedType && !actualType.extends(expectedType)) {
                                    errors.push((0, error_1.typeError)(actualType, expectedType, (_b = (_a = call === null || call === void 0 ? void 0 : call.genericArguments) === null || _a === void 0 ? void 0 : _a[i]) !== null && _b !== void 0 ? _b : call));
                                }
                            }
                        }
                    });
                }
            }
            const returnType = apply.getReturnType();
            if (apply.isType() && returnType) {
                // this is a Type expression, e.g. `Person { name = "sam" }` or `[1, 2]` or `"hello"`
                if (call.arguments === null && !(returnType.isVoid() || returnType.isNothing() || returnType.isOptional())) {
                    errors.push((0, error_1.typeError)(returnType, checker.void, call));
                }
                else if (typeof call.arguments === "string" && !returnType.isStringLike()) {
                    errors.push((0, error_1.typeError)(returnType, checker.string, call));
                }
                else if (typeof call.arguments === "number" && !returnType.isNumber()) {
                    errors.push((0, error_1.typeError)(returnType, checker.number, call));
                }
                else if (typeof call.arguments === "boolean" && !returnType.isBoolean()) {
                    errors.push((0, error_1.typeError)(returnType, checker.boolean, call));
                }
                else if (ask.isListLiteral(call.arguments) && !returnType.isList()) {
                    errors.push(error_factory_1.ValidationErrorFactory.TypeErrorListType({
                        expr: call,
                    }));
                }
                if (returnType.isUtterance()) {
                    const utteranceType = returnType.getUtteranceType();
                    errors.push(...(0, exports.validateUtterance)(call, utteranceType, getPropertyMap));
                }
                if (ask.isListLiteral(call.arguments) && returnType.isList()) {
                    const expectedType = returnType.getListItemType();
                    if (expectedType) {
                        for (const item of call.arguments.items) {
                            errors.push(...(0, exports.validateExpression)(item.item, checker));
                            const actualType = checker.getType(item.item);
                            if (actualType) {
                                if (!actualType.extends(expectedType)) {
                                    errors.push(error_factory_1.ValidationErrorFactory.TypeErrorListItem({
                                        expr: (0, error_factory_1.getExpressionIfLocField)(item.item, item),
                                        attributes: {
                                            actualType: actualType.toString(item.item),
                                            expectedType: expectedType.toString(item.item),
                                        },
                                    }));
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return errors;
};
exports.validateCall = validateCall;
/**
 * validate the variations call
 * 1. The argument value can't use duplicate locale info
 * 2. SkillLevelResponses can't be used as an argument of variations call
 * 3. prompts.abc can't be used as an argument of variations call
 *
 * Invalid case example:
 * 1. duplicate locales
 * ```
 *  @locale(Locale.en_US)
 *  promptUS = utterances<Person>([
 *     "hi I am American my name is {name}",
 *     "hi I am American my name is {name} and i am {age} years old"
 *  ])
 *
 *  @locale(Locale.en_US, Locale.en_GB)
 *  promptGB = utterances<Person>([
 *    "hi I am British my name is {name}",
 *    "hi I am British my name is {name} and i am {age} years old"
 *  ])
 *  u = variations(promptUS, promptGB)
 * ```
 *
 * 2. SkillLevelResponses used as argument
 * ```
 * skillLevelResponsesEN = SkillLevelResponses { ... }
 * skillLevelResponsesGB = SkillLevelResponses { ... }
 *
 * skillLevelResponses = variations(skillLevelResponsesEN, skillLevelResponsesGB)
 * ```
 *
 * 3. prompts used as argument
 * ```
 * skillLevelResponses = variations(prompts.AlexaConversationsWelcome, prompts.AlexaConversationsOutOfDomain)
 * ```
 */
const validateVariations = (call, checker) => {
    const apply = checker.getApply(call);
    if (apply === undefined) {
        return [];
    }
    const errors = [];
    const usedLocale = new Map();
    const argumentValueThing = apply.getArgumentValueThing("variations");
    if (argumentValueThing === null || argumentValueThing === void 0 ? void 0 : argumentValueThing.isList()) {
        const items = argumentValueThing.getListItems();
        items === null || items === void 0 ? void 0 : items.forEach((item) => {
            var _a, _b, _c;
            if (((_a = item === null || item === void 0 ? void 0 : item.item) === null || _a === void 0 ? void 0 : _a.kind) === "NameReference" || ((_b = item === null || item === void 0 ? void 0 : item.item) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                // TODO: validate the item is not SkillLevelResponses or prompts
                const thing = checker.getThing(item.item);
                if (thing === null || thing === void 0 ? void 0 : thing.type.isSkillLevelResponses()) {
                    // SkillLevelResponses can't be used as an argument of variations call
                    errors.push(error_factory_1.ValidationErrorFactory.InvalidVariationsArgumentSkillLevelResponses({
                        expr: (0, error_factory_1.getExpressionIfLocField)(item.item, item),
                    }));
                }
                else if (((_c = checker.resolveNameReference(item.item)) === null || _c === void 0 ? void 0 : _c.kind) === "ResponseTemplate") {
                    errors.push(error_factory_1.ValidationErrorFactory.InvalidVariationsArgumentResponsePrompts({
                        expr: (0, error_factory_1.getExpressionIfLocField)(item.item, item),
                    }));
                }
                else {
                    const locales = checker.collectLocaleInfo(item.item);
                    locales.forEach((locale) => {
                        var _a, _b;
                        if (usedLocale.has(locale)) {
                            errors.push(error_factory_1.ValidationErrorFactory.DuplicateLocale({
                                expr: (0, error_factory_1.getExpressionIfLocField)(item.item, item),
                                attributes: {
                                    locale,
                                    variationItem: usedLocale.get(locale),
                                },
                            }));
                        }
                        else {
                            usedLocale.set(locale, (_b = (_a = item.item) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.name);
                        }
                    });
                }
            }
        });
    }
    return errors;
};
exports.validateVariations = validateVariations;
/**
 * Validate that a call to a User Defined API or Dialog is not contained within another call.
 *
 * Validate that this Call is allowed in this Context.
 *
 * @param call
 * @param checker
 * @returns
 */
const validateCallContext = (call, checker) => {
    const apply = checker.getApply(call);
    if (apply !== undefined) {
        const callType = apply.isUserDefinedApi()
            ? `user defined API '${apply.getName()}'`
            : apply.isDialog()
                ? "a dialog"
                : apply.isBuiltin()
                    ? `'${apply.getShortName()}'`
                    : "an action";
        return walkCallContext(call.context);
        function walkCallContext(context) {
            if (context === undefined || ask.isDialogDeclaration(context)) {
                return [];
            }
            if (context.kind === "InteractionDeclaration" || context.kind === "Correction") {
                // TODO: add validation checks - https://github.com/alexa/ask-ac/issues/869
                return [];
            }
            if (ask.isModule(context)) {
                return [
                    error_factory_1.ValidationErrorFactory.InvalidCallContextInModule({
                        expr: call,
                        attributes: {
                            callType,
                        },
                    }),
                ];
            }
            if (context.kind === "When") {
                if (!(apply.isOperator() || apply.isNativeAction())) {
                    return [
                        error_factory_1.ValidationErrorFactory.InvalidCallContextInCondition({
                            expr: call,
                            attributes: {
                                callType,
                            },
                        }),
                    ];
                }
            }
            else if (context.kind === "Call") {
                const contextApply = checker.getApply(context);
                if ((contextApply === null || contextApply === void 0 ? void 0 : contextApply.isUserDefinedApi()) || (contextApply === null || contextApply === void 0 ? void 0 : contextApply.isDialog()) || (contextApply === null || contextApply === void 0 ? void 0 : contextApply.isType())) {
                    const contextType = contextApply.isType() ? (contextApply.isList() ? "a list item" : "a property") : "an argument";
                    const errorArguments = {
                        expr: call,
                        attributes: {
                            callType,
                            contextType,
                        },
                    };
                    if (apply.isOperator()) {
                        return [error_factory_1.ValidationErrorFactory.InvalidCallContextComparison(errorArguments)];
                    }
                    if (apply.isNativeAction()) {
                        return [error_factory_1.ValidationErrorFactory.InvalidCallContextType(errorArguments)];
                    }
                    return [error_factory_1.ValidationErrorFactory.InvalidCallContextTypeInline(errorArguments)];
                }
            }
            return walkCallContext(context.context);
        }
    }
    return [];
};
exports.validateCallContext = validateCallContext;
/**
 * Validates that a `validateArg` annotation matches the following rules:
 * 1. action must have at least one argument
 * 2. condition must reference at least one of those arguments in its boolean expression
 * 3. at least one argument must be referenced
 * 4. that argument must be from the same action that this validateArg annotation is attached to.
 *
 * @param apply Apply instance for the validateArg annotation call.
 * @param checker static TypeChecker instance
 * @returns validation errors
 * @see https://github.com/alexa/ask-ac/issues/690
 */
const validateValidateArgAnnotation = (apply, checker) => {
    var _a;
    if (!apply.isValidateArg()) {
        return [];
    }
    const action = (_a = apply.checker.getThing(apply.call.context.context)) === null || _a === void 0 ? void 0 : _a.asAction();
    if (action === undefined) {
        // we don't need to error here - validateArg's annotation targets restricts it to an Action
        return [];
    }
    if (action.origin.arguments === undefined || action.origin.arguments.length === 0) {
        return [
            error_factory_1.ValidationErrorFactory.InvalidAnnotationValidateArg({
                expr: apply.call,
            }),
        ];
    }
    const argumentsNode = apply.getArgumentValue("arguments");
    const conditionNode = apply.getArgumentValue("condition");
    const condition = apply.getArgumentValueThing("condition");
    const args = apply.getArgumentValueThing("arguments");
    const argsNode = apply.getArgumentValue("arguments");
    const requestPromptNode = apply.getArgumentValue("requestPrompt");
    const requestPrompt = apply.getArgumentValueThing("requestPrompt");
    return [
        ...validateArguments(),
        ...validateConditionReferencesAtLeastOneArgument(),
        ...validateConditionOperations(conditionNode, undefined),
        ...validateRequestPrompt(),
    ];
    function validateConditionReferencesAtLeastOneArgument() {
        var _a;
        if (conditionNode === undefined) {
            // type error
            return [];
        }
        if (condition === null || condition === void 0 ? void 0 : condition.isNothing()) {
            return [
                error_factory_1.ValidationErrorFactory.IllegalNothingValueBoolean({
                    expr: (0, error_factory_1.getExpressionIfLocField)(conditionNode, apply.call),
                }),
            ];
        }
        if (!hasAtLeastOneArgumentNameReference(conditionNode)) {
            return [
                error_factory_1.ValidationErrorFactory.InvalidAnnotationValidateArgCondition({
                    expr: conditionNode,
                    attributes: {
                        actionArguments: (_a = action === null || action === void 0 ? void 0 : action.origin.arguments) === null || _a === void 0 ? void 0 : _a.map((arg) => { var _a; return `'${(_a = arg.name) === null || _a === void 0 ? void 0 : _a.name}'`; }).join(","),
                        actionName: action.actionName,
                    },
                }),
            ];
        }
        return [];
    }
    function hasAtLeastOneArgumentNameReference(node) {
        if (node.kind === "NameReference") {
            const referencedNode = checker.resolveNameReference(node);
            if ((referencedNode === null || referencedNode === void 0 ? void 0 : referencedNode.kind) === "ArgumentDeclaration") {
                return true;
            }
        }
        return (0, visit_1.collect)(node, hasAtLeastOneArgumentNameReference, (a, b) => a || b, false);
    }
    function validateConditionOperations(node, errorExpr) {
        if (node === undefined) {
            return [];
        }
        if (node.kind === "NameReference") {
            return validateConditionOperations(checker.resolveNameReference(node), (0, error_factory_1.getExpressionIfLocField)(errorExpr, node));
        }
        if (node.kind === "PropertyReference") {
            return validateConditionOperations(checker.resolveNameReferenceToCall(node), (0, error_factory_1.getExpressionIfLocField)(errorExpr, node));
        }
        if (node.kind === "Call") {
            const apply = checker.getApply(node);
            if (apply === undefined) {
                // type error
                return [];
            }
            if (apply.isType()) {
                if (node.arguments === null ||
                    typeof node.arguments === "string" ||
                    typeof node.arguments === "number" ||
                    typeof node.arguments === "boolean" ||
                    ask.isListLiteral(node.arguments)) {
                    if (ask.isListLiteral(node.arguments)) {
                        // check that each of the values in the list are also valid
                        return node.arguments.items.map((item) => validateConditionOperations(item.item, errorExpr)).flat();
                    }
                    // literal value comparisons are allowed
                    return [];
                }
                return [
                    error_factory_1.ValidationErrorFactory.InvalidBooleanExpressionTypeLiteral({
                        expr: (0, error_factory_1.getExpressionIfLocField)(errorExpr, node, conditionNode),
                        attributes: {
                            typeName: apply.getName(),
                        },
                    }),
                ];
            }
            if (apply.isBinaryOperator()) {
                return [
                    ...validateConditionOperations(apply.getArgumentValue("left"), errorExpr),
                    ...validateConditionOperations(apply.getArgumentValue("right"), errorExpr),
                ];
            }
            if (apply.isNot() || apply.isIs() || apply.isExists()) {
                return validateConditionOperations(apply.getArgumentValue("right"), errorExpr);
            }
            if (apply.isSize()) {
                return validateConditionOperations(apply.getArgumentValue("list"), errorExpr);
            }
            if (apply.isGetListItem()) {
                return [
                    ...validateConditionOperations(apply.getArgumentValue("list"), errorExpr),
                    ...validateConditionOperations(apply.getArgumentValue("index"), errorExpr),
                ];
            }
            if (apply.isLength()) {
                return validateConditionOperations(apply.getArgumentValue("s"), errorExpr);
            }
            return [
                error_factory_1.ValidationErrorFactory.InvalidBooleanExpressionAction({
                    expr: (0, error_factory_1.getExpressionIfLocField)(errorExpr, node, conditionNode),
                    attributes: {
                        actionName: apply.getName(),
                    },
                }),
            ];
        }
        return [];
    }
    function validateRequestPrompt() {
        if (requestPromptNode === undefined) {
            // type error
            return [];
        }
        if (requestPrompt === null || requestPrompt === void 0 ? void 0 : requestPrompt.isNothing()) {
            return [
                error_factory_1.ValidationErrorFactory.IllegalNothingValueResponsePrompt({
                    expr: (0, error_factory_1.getExpressionIfLocField)(requestPromptNode, apply.call),
                }),
            ];
        }
        return [];
    }
    function validateArguments() {
        var _a, _b;
        if (argumentsNode === undefined || (args === null || args === void 0 ? void 0 : args.isNothing())) {
            return [
                error_factory_1.ValidationErrorFactory.ExpectedNonEmptyList({
                    expr: apply.call,
                    attributes: {
                        actionName: (_a = action.name) === null || _a === void 0 ? void 0 : _a.name,
                    },
                }),
            ];
        }
        if (!(args === null || args === void 0 ? void 0 : args.isLiteral())) {
            return [
                error_factory_1.ValidationErrorFactory.ExpectedLiteralValue({
                    expr: (0, error_factory_1.getExpressionIfLocField)(argumentsNode, apply.call),
                }),
            ];
        }
        if (!args.isList()) {
            return [];
        }
        const items = args.getItems();
        if (!(items === null || items === void 0 ? void 0 : items.length)) {
            return [
                error_factory_1.ValidationErrorFactory.ExpectedNonEmptyList({
                    expr: (0, error_factory_1.getExpressionIfLocField)(argumentsNode, apply.call),
                    attributes: {
                        actionName: (_b = action.name) === null || _b === void 0 ? void 0 : _b.name,
                    },
                }),
            ];
        }
        return items.flatMap((arg, i) => {
            var _a;
            // if this arguments is an inline literal list, we will place the error on the specific item in the list
            const argsExpr = (argsNode === null || argsNode === void 0 ? void 0 : argsNode.kind) === "Call" && ask.isListLiteral(argsNode.arguments)
                ? (_a = argsNode.arguments.items[i]) === null || _a === void 0 ? void 0 : _a.item
                : (0, error_factory_1.getExpressionIfLocField)(argumentsNode, apply.call);
            if (arg === undefined) {
                return []; // type error;
            }
            if (arg.isNothing()) {
                return [
                    error_factory_1.ValidationErrorFactory.IllegalNothingValueActionArgument({
                        expr: argsExpr,
                        attributes: {
                            actionName: action === null || action === void 0 ? void 0 : action.actionName,
                        },
                    }),
                ];
            }
            if (arg.isArgument() && arg.action && !arg.action.equals(action)) {
                return [
                    error_factory_1.ValidationErrorFactory.MismatchedActionArgumentsValidateArguments({
                        expr: argsExpr,
                        attributes: {
                            argumentName: arg.argumentName,
                            actualActionName: arg.action.actionName,
                            expectedActionName: action.actionName,
                        },
                    }),
                ];
            }
            return [];
        });
    }
    return [];
};
exports.validateValidateArgAnnotation = validateValidateArgAnnotation;
/**
 * Validate a call to `require` - an internal action to reference a file from disk.
 */
const validateRequireCall = (apply, checker) => {
    var _a, _b;
    const name = apply.getName();
    if (name === ast_1.AlexaConversations.apl || name === ast_1.AlexaConversations.apla) {
        const pathArg = (_a = apply.getArguments()) === null || _a === void 0 ? void 0 : _a.path;
        if (((_b = pathArg === null || pathArg === void 0 ? void 0 : pathArg.value) === null || _b === void 0 ? void 0 : _b.kind) === "Call") {
            const filePath = ask.isUtterance(pathArg.value.arguments)
                ? pathArg.value.arguments.text
                : typeof pathArg.value.arguments === "string"
                    ? pathArg.value.arguments
                    : undefined;
            if (filePath !== undefined) {
                const uri = checker.getUri(apply.call);
                if (uri !== undefined) {
                    let absolutePath;
                    if (path_1.default.isAbsolute(filePath)) {
                        absolutePath = filePath;
                    }
                    else {
                        absolutePath = path_1.default.join(uri, "..", filePath);
                    }
                    if (!fs_extra_1.default.existsSync(absolutePath)) {
                        // TODO: don't use synchronous IO in the validators
                        // see: https://github.com/alexa/ask-ac/issues/504
                        return [
                            error_factory_1.ValidationErrorFactory.PathNotAccessible({
                                expr: pathArg.value,
                                attributes: {
                                    filePath,
                                },
                            }),
                        ];
                    }
                    // developer could provide folder name only
                    // auto fill the 'document.json' in path
                    const status = fs_extra_1.default.statSync(absolutePath);
                    let documentPath;
                    if (status.isFile()) {
                        documentPath = absolutePath;
                    }
                    else {
                        documentPath = path_1.default.join(absolutePath, constants_1.Constants.APLADocumentFileName);
                    }
                    // The document can only use the name 'document.json'
                    if (path_1.default.basename(documentPath) !== constants_1.Constants.APLADocumentFileName) {
                        const errorArguments = {
                            expr: pathArg.value,
                            attributes: {
                                documentName: path_1.default.basename(documentPath),
                            },
                        };
                        return [
                            name === ast_1.AlexaConversations.apl
                                ? error_factory_1.ValidationErrorFactory.InvalidAplDocumentName(errorArguments)
                                : error_factory_1.ValidationErrorFactory.InvalidAplaDocumentName(errorArguments),
                        ];
                    }
                    // if no document.json found
                    if (!fs_extra_1.default.existsSync(documentPath)) {
                        return [
                            error_factory_1.ValidationErrorFactory.FileNotFound({
                                expr: pathArg.value,
                                attributes: {
                                    filePath,
                                },
                            }),
                        ];
                    }
                    // Type check to make sure apla action point to APLA document
                    // and apl action point to APL document
                    try {
                        const content = fs_extra_1.default.readFileSync(documentPath);
                        const json = JSON.parse(content.toString("utf8"));
                        const { type } = json;
                        const errorArguments = {
                            expr: pathArg.value,
                            attributes: {
                                filePath,
                                fileType: type === undefined ? type : `"${type}"`,
                            },
                        };
                        if (name === ast_1.AlexaConversations.apl && type !== constants_1.APLFileType.APL) {
                            return [error_factory_1.ValidationErrorFactory.InvalidFileTypeApl(errorArguments)];
                        }
                        if (name === ast_1.AlexaConversations.apla && !constants_1.APLAFileTypes.includes(type)) {
                            return [error_factory_1.ValidationErrorFactory.InvalidFileTypeApla(errorArguments)];
                        }
                    }
                    catch (err) {
                        return [
                            error_factory_1.ValidationErrorFactory.FileReadError({
                                expr: pathArg.value,
                                attributes: {
                                    filePath,
                                },
                                overrideMessage: err.message,
                            }),
                        ];
                    }
                }
            }
        }
    }
    return [];
};
exports.validateRequireCall = validateRequireCall;
/**
 * Validate the arguments passed to a Call against the target declaration.
 *
 * - Finds missing required arguments.
 * - Detect unknown arguments, whether by name or position. Account for var-args.
 * - Detect when positional arguments are used after named ones.
 * - Check that the types of arguments.
 *
 * @param apply
 * @param checker
 * @param checkType should we type check? default true
 */
const validateNamedArguments = (apply, checker, checkType = true) => {
    var _a, _b, _c;
    if (apply.isType() && ((_a = apply.getReturnType()) === null || _a === void 0 ? void 0 : _a.isPrimitive())) {
        return [];
    }
    const { call } = apply;
    const errors = [];
    let isPositionalAllowed = true;
    let position = 0;
    const seenNamedArgs = new Set();
    if (Array.isArray(call.arguments)) {
        for (const argument of call.arguments) {
            // recursively descend and validate this argument
            errors.push(...(0, exports.validateExpression)(argument, checker));
            if ((_b = argument.name) === null || _b === void 0 ? void 0 : _b.name) {
                isPositionalAllowed = false;
                const decl = apply.argumentDeclIndex[argument.name.name];
                if (decl === undefined) {
                    unknown();
                }
                if (seenNamedArgs.has(argument.name.name)) {
                    errors.push(error_factory_1.ValidationErrorFactory.InvalidApiArgumentRedeclare({
                        expr: argument,
                        attributes: {
                            argumentName: argument.name.name,
                        },
                    }));
                }
                else {
                    seenNamedArgs.add(argument.name.name);
                }
            }
            else if (isPositionalAllowed) {
                const decl = (_c = apply.argumentDeclarations) === null || _c === void 0 ? void 0 : _c[position];
                const env = apply.getGenericEnvironment();
                const declType = (decl === null || decl === void 0 ? void 0 : decl.kind) === "ArgumentDeclaration" ? checker.instantiateTypeReference(decl.type, env) : decl === null || decl === void 0 ? void 0 : decl.type;
                if (declType === undefined) {
                    unknown();
                }
                if ((declType === null || declType === void 0 ? void 0 : declType.isArgs()) !== true) {
                    // if this is not var args, increment the declaration position
                    // otherwise, subsequent arguments are considered an item in the var-args list
                    position += 1;
                }
            }
            else {
                errors.push(error_factory_1.ValidationErrorFactory.PositionalArgumentAfterName({
                    expr: argument,
                }));
                // If positional arguments are used after a named argument, skip the rest validation
                return errors;
            }
            function unknown() {
                var _a, _b, _c;
                let error;
                const expr = (0, error_factory_1.getExpressionIfLocField)(argument.name, argument);
                if ((_a = argument.name) === null || _a === void 0 ? void 0 : _a.name) {
                    error = apply.isType()
                        ? error_factory_1.ValidationErrorFactory.UnknownProperty({
                            expr,
                            attributes: {
                                propertyName: argument.name.name,
                                typeName: (_c = (_b = apply.getReturnType()) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name,
                            },
                        })
                        : error_factory_1.ValidationErrorFactory.UnknownArgument({
                            expr,
                            attributes: {
                                argumentName: argument.name.name,
                                callName: apply.getName(),
                            },
                        });
                }
                else {
                    const errorArguments = {
                        expr,
                        attributes: {
                            index: argument.index,
                        },
                    };
                    error = apply.isType()
                        ? error_factory_1.ValidationErrorFactory.UnknownPropertyIndex(errorArguments)
                        : error_factory_1.ValidationErrorFactory.UnknownArgumentIndex(errorArguments);
                }
                errors.push(error);
            }
        }
    }
    const missing = new Set(apply.requiredArguments);
    const sanitizedArguments = apply.getArguments();
    if (sanitizedArguments !== undefined) {
        // arguments are grouped by name and var-args are assembled into a List.
        // now go through each argument and type check it.
        for (const [name, argument] of Object.entries(sanitizedArguments || {})) {
            missing.delete(name);
            if (checkType) {
                // special case: when property of an event result is of type optional, and there's request prompt available for that property
                // Then we should treat this property as not optional
                let actualType = checker.getType(argument.value);
                if (actualType === null || actualType === void 0 ? void 0 : actualType.isOptional()) {
                    // for backwards compatibility
                    // Temporarily make Optional<T> assignable to T
                    // TODO: get argumentEnsured condition back once we are ready to ship breaking changes
                    // if (checker.isArgumentEnsured(call, apply.decl, name)) {
                    while (actualType === null || actualType === void 0 ? void 0 : actualType.isOptional()) {
                        actualType = actualType.getOptionalType();
                    }
                }
                const expectedType = apply === null || apply === void 0 ? void 0 : apply.getType(argument);
                if (actualType && expectedType) {
                    if (!actualType.extends(expectedType)) {
                        errors.push((0, error_1.typeError)(actualType, expectedType, apply.call, argument));
                    }
                }
            }
        }
    }
    if (missing.size > 0) {
        errors.push(apply.isType()
            ? error_factory_1.ValidationErrorFactory.MissingProperties({
                expr: call,
                attributes: { properties: Array.from(missing.values()).join(",") },
            })
            : error_factory_1.ValidationErrorFactory.MissingArguments({
                expr: call,
                attributes: { args: Array.from(missing.values()).join(",") },
            }));
    }
    errors.push(...validateBinaryOperator(apply));
    return errors;
};
exports.validateNamedArguments = validateNamedArguments;
function validateBinaryOperator(apply) {
    var _a, _b;
    if (apply.isBinaryOperator()) {
        // special-case logic for binary operators - the types must match
        // for example, if we have `1 == "hello"`, then it will be inferred as
        // `equals<Thing>(1, "hello")` // there is no type error here
        // for these cases, we will explicitly check that either:
        // 1. left extends right
        // 2. right extends left
        const left = (_a = apply.getArgumentValueThing("left")) === null || _a === void 0 ? void 0 : _a.type;
        const right = (_b = apply.getArgumentValueThing("right")) === null || _b === void 0 ? void 0 : _b.type;
        if (left && right) {
            if (!left.extends(right) && !right.extends(left)) {
                return [
                    error_factory_1.ValidationErrorFactory.TypeErrorIncomparableExpr({
                        expr: apply.call,
                        attributes: {
                            leftExpr: left.toString(apply.call),
                            rightExpr: right.toString(apply.call),
                        },
                    }),
                ];
            }
        }
    }
    return [];
}
exports.validateBinaryOperator = validateBinaryOperator;
/**
 * Validates the utterance in expr
 * @param expr expression containing the utterance to validate
 * @param utteranceType type for utterance
 * @param getPropertyMap memoized type's getPropertyMap
 * @returns
 */
const validateUtterance = (expr, utteranceType, getPropertyMap) => {
    var _a;
    let errors = [];
    // throw error if the item in a list is not literal string
    if (expr.kind !== "Call" || (!(typeof expr.arguments === "string") && !ask.isUtterance(expr.arguments))) {
        return [error_factory_1.ValidationErrorFactory.InvalidUtteranceItem({ expr })];
    }
    let utterance;
    if (ask.isUtterance(expr.arguments)) {
        utterance = expr.arguments.text;
    }
    else {
        utterance = expr.arguments;
    }
    // Validate the utterance text here. Currently only validating it's not an empty string
    if (utterance.trim().length === 0) {
        return [error_factory_1.ValidationErrorFactory.EmptyUtteranceString({ expr })];
    }
    if (!utteranceType) {
        return errors;
    }
    const utteranceTypeRequiredProperties = utteranceType.getRequiredProperties();
    if (typeof expr.arguments === "string" && utteranceTypeRequiredProperties.size > 0) {
        errors.push(error_factory_1.ValidationErrorFactory.MissingPropertiesOnType({
            expr,
            attributes: {
                requiredProperties: Array.from(utteranceTypeRequiredProperties.values())
                    .map((p) => `${p.name}`)
                    .join(", "),
                typeName: utteranceType.toString(expr),
            },
        }));
    }
    else if (ask.isUtterance(expr.arguments)) {
        const propertyPaths = [];
        const pathsSeen = new Set();
        for (const name of expr.arguments.names || []) {
            if (!name.name) {
                continue;
            }
            if (pathsSeen.has(name.name)) {
                errors.push(error_factory_1.ValidationErrorFactory.DuplicateProperty({
                    expr: name,
                    attributes: {
                        propertyName: name.name,
                    },
                }));
            }
            pathsSeen.add(name.name);
            propertyPaths.push(name.name);
        }
        const { errors: propertyTreeErrors, root: propertyTreeRoot } = property_node_1.PropertyNode.buildPropertyTree(expr.arguments.names || [], utteranceType, expr, getPropertyMap);
        errors = [...errors, ...propertyTreeErrors];
        // Verify required properties at each tree level.
        // The tree traversal algorithm is the standard queue breadth first
        // (level by level) logic where we quee the root and while the queue
        // is not empty we unqueue element and queue its children.
        const queue = [propertyTreeRoot];
        while (queue.length !== 0) {
            const propertyNode = queue.shift();
            const requiredProperties = propertyNode === null || propertyNode === void 0 ? void 0 : propertyNode.propertyType.getRequiredProperties();
            for (const child of propertyNode.children.values()) {
                // mark this child as present by removing from requiredProperties
                requiredProperties.delete(child.property.name);
                // queue child which is a part of standard queue traversal
                queue.push(child);
            }
            for (const requiredProperty of requiredProperties.values()) {
                // if it's a list, then it's allowed to be omitted - omitted means empty list?
                if (!((_a = requiredProperty.type) === null || _a === void 0 ? void 0 : _a.isList())) {
                    errors.push(error_factory_1.ValidationErrorFactory.MissingPropertiesOnUtteranceType({
                        expr,
                        attributes: {
                            utterance: expr.arguments.text,
                            propertyName: requiredProperty.name,
                            typeName: utteranceType.toString(expr),
                        },
                    }));
                }
            }
        }
    }
    return errors;
};
exports.validateUtterance = validateUtterance;
const validateCondition = (condition, checker) => {
    const errors = [];
    if (condition.when !== undefined) {
        errors.push(...(0, exports.validateExpression)(condition.when, checker));
    }
    if (condition.then === undefined) {
        console.warn("undefined then");
    }
    else {
        errors.push(...(0, exports.validateConditionBlock)(condition.then, checker));
        errors.push(...(0, exports.validateBlock)(condition.then, checker));
    }
    if (condition.else) {
        errors.push(...(0, exports.validateConditionBlock)(condition.else, checker));
        errors.push(...(0, exports.validateBlock)(condition.else, checker));
    }
    const whenType = checker.getType(condition.when);
    if ((whenType === null || whenType === void 0 ? void 0 : whenType.isBoolean()) === false) {
        errors.push(error_factory_1.ValidationErrorFactory.TypeErrorWhenBoolean({
            expr: (0, error_factory_1.getExpressionIfLocField)(condition.when, condition),
            attributes: {
                whenType: whenType.toString(condition.when),
                whenCondition: checker.boolean.toString(condition.when),
            },
        }));
    }
    return errors;
};
exports.validateCondition = validateCondition;
/**
 * Validate that a Condition Block has expressions.
 */
const validateConditionBlock = (scope) => {
    var _a;
    return scope.expressions === undefined || ((_a = scope.expressions) === null || _a === void 0 ? void 0 : _a.length) === 0
        ? [
            error_factory_1.ValidationErrorFactory.EmptyConditionBlock({
                expr: scope,
            }),
        ]
        : [];
};
exports.validateConditionBlock = validateConditionBlock;
/**
 * Validate EnsureOrder action call
 * 1. All the args in the list should from same api
 * 2. All the args in the list should be required args
 *
 * Related Github feature request:
 * https://github.com/alexa/ask-ac/issues/553
 */
const validateEnsureArgOrder = (apply, checker) => {
    const errors = [];
    if (apply.isEnsureArgOrder()) {
        const argumentsValue = apply.getArgumentValue("arguments");
        const argumentsValueThing = checker.getThing(argumentsValue);
        // all the arguments in the list should be required args
        errors.push(...(0, evaluate_1.validateArgumentListThing)(argumentsValueThing, argumentsValue));
        if ((argumentsValueThing === null || argumentsValueThing === void 0 ? void 0 : argumentsValueThing.isLiteral()) && argumentsValueThing.isList()) {
            const items = argumentsValueThing.getItems();
            items === null || items === void 0 ? void 0 : items.forEach((item) => {
                var _a, _b, _c;
                if (item === null || item === void 0 ? void 0 : item.isArgument()) {
                    const referencedArgumentDeclaration = item.getReferencedActionArgumentDeclaration();
                    const type = checker.getType(referencedArgumentDeclaration === null || referencedArgumentDeclaration === void 0 ? void 0 : referencedArgumentDeclaration.type);
                    if (type === null || type === void 0 ? void 0 : type.isOptional()) {
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidEnsureArgOptional({
                            expr: item,
                            attributes: {
                                argumentName: (_a = referencedArgumentDeclaration === null || referencedArgumentDeclaration === void 0 ? void 0 : referencedArgumentDeclaration.name) === null || _a === void 0 ? void 0 : _a.name,
                                actionName: (_c = (_b = referencedArgumentDeclaration === null || referencedArgumentDeclaration === void 0 ? void 0 : referencedArgumentDeclaration.context) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name,
                            },
                        }));
                    }
                }
            });
        }
    }
    return errors;
};
exports.validateEnsureArgOrder = validateEnsureArgOrder;
const validateInteractionDeclaration = (action, checker) => [
    ...(0, exports.validateAnnotations)(action, checker),
    ...(0, exports.validateExpression)(action.scope, checker),
];
exports.validateInteractionDeclaration = validateInteractionDeclaration;
const validateCorrection = (action, checker) => [
    ...(0, exports.validateExpression)(action.actual, checker),
    ...(0, exports.validateExpression)(action.expected, checker),
];
exports.validateCorrection = validateCorrection;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdmFsaWRhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx3REFBMEI7QUFDMUIsZ0RBQXdCO0FBQ3hCLDJDQUE2QjtBQUU3QixtQ0FBNkc7QUFNN0csK0JBQXlGO0FBQ3pGLGlDQUFrQztBQUNsQywyQ0FBa0U7QUFFbEUseUNBQTZIO0FBQzdILGlDQUE0QjtBQUM1QixxREFBeUU7QUFDekUseURBQW1EO0FBQ25ELG1DQUFnQztBQUNoQyxtREFBNkg7QUFFN0gsbURBQTZDO0FBQzdDLGlDQUErQjtBQUkvQjs7Ozs7OztHQU9HO0FBQ0gsU0FBZ0IsZUFBZSxDQUFDLE9BQWdCLEVBQUUsT0FBaUIsRUFBRSx1QkFBaUM7O0lBQ3BHLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUN6QyxNQUFNLE1BQU0sR0FBaUIsRUFBRSxDQUFDO0lBRWhDLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLENBQUM7SUFFNUMsTUFBTSxDQUFDLElBQUksQ0FDVCxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUU7O1FBQUMsT0FBQTtZQUM5QyxtQ0FBbUM7WUFDbkMsR0FBRyxDQUFDLE1BQUEsU0FBUyxDQUFDLE1BQU0sbUNBQUksRUFBRSxDQUFDO1lBQzNCLDZDQUE2QztZQUM3QyxHQUFHLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsdUJBQXVCLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ2pGLHNDQUFzQztZQUN0QyxHQUFHLENBQUMsU0FBUyxDQUFDLE9BQU8sSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxJQUFBLHNC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