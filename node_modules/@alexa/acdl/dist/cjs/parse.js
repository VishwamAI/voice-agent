"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLocation = exports.parseQualifiedName = exports.parseIdentifierLocation = exports.parseIdentifier = exports.parseNameDeclaration = exports.parseArgumentDeclaration = exports.parseArgumentDeclarations = exports.parseFunctionSignature = exports.parseActionDeclaration = exports.parseListIndex = exports.parseList = exports.parseObjectProperty = exports.parseObject = exports.parseInOperator = exports.parseIsOperator = exports.createLiteral = exports.parseLiteral = exports.parseArgumentValue = exports.parseCall = exports.parseBooleanOperator = exports.parseBinaryExpression = exports.parseCorrection = exports.parseCondition = exports.parsePropertyReference = exports.parseNameReference = exports.parseExpression = exports.parseInteractionDeclaration = exports.parseScopeExpression = exports.parseScope = exports.parseSampleDeclaration = exports.parseDialogDeclaration = exports.parseNamespaceDeclaration = exports.parseTypeProperty = exports.parseTypeReference = exports.parseTypeArgumentDeclaration = exports.parseTypeArgumentDeclarations = exports.parseTypeDeclaration = exports.parseAnnotationList = exports.parseEnumItem = exports.parseEnumDeclaration = exports.parseModuleLevelNameDeclaration = exports.parseACDLFile = exports.loadACDLFile = exports.loadACDLFileSync = exports.loadModuleFile = exports.loadModuleFileSync = exports.ParseContext = exports.Counter = void 0;
const antlr = __importStar(require("antlr4ts"));
const acdl = __importStar(require("./syntax"));
const ask = __importStar(require("./ast"));
const source_file_1 = require("./source-file");
const try_1 = require("./try");
const util_1 = require("./util");
const ast_1 = require("./ast");
const error_factory_1 = require("./error-factory");
class Counter {
    constructor(counter = 0) {
        Object.defineProperty(this, "counter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: counter
        });
    }
    nextId() {
        this.counter += 1;
        return this.counter;
    }
}
exports.Counter = Counter;
class ParseContext {
    constructor(uri, namespace, nameCounter, errors, scope, imports) {
        Object.defineProperty(this, "uri", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: uri
        });
        Object.defineProperty(this, "namespace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: namespace
        });
        Object.defineProperty(this, "nameCounter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: nameCounter
        });
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: errors
        });
        Object.defineProperty(this, "scope", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: scope
        });
        Object.defineProperty(this, "imports", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: imports
        });
    }
    hasOptionalImported() {
        return (this.imports.find((i) => (i.kind === "ImportName" && i.name === ast_1.AlexaSchema.Optional) ||
            (i.kind === "ImportNamespace" && i.name === (0, util_1.getNamespace)(ast_1.AlexaSchema.Optional))) !== undefined);
    }
    withScope(scope) {
        return new ParseContext(this.uri, this.namespace, this.nameCounter, this.errors, scope, this.imports);
    }
    addError(err) {
        this.errors.push(err);
    }
    newName() {
        return `var${this.nameCounter.nextId()}`;
    }
}
exports.ParseContext = ParseContext;
/**
 * Load an ASK Module file from file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.json`.
 * @param uri file path of the Module File
 * @returns source file of the module if it is a valid module, otherwise `undefined`.
 */
function loadModuleFileSync(baseDir, uri) {
    const json = (0, util_1.readJsonFileSync)((0, util_1.trimScheme)(uri));
    if ((json === null || json === void 0 ? void 0 : json.schema) === ask.ModuleSchema) {
        try {
            return (0, source_file_1.sourceFile)(baseDir, uri, ask.fromASKModule(json, uri));
        }
        catch (err) {
            console.log(`failed to load module file: ${uri}`);
            console.error(err);
            throw err;
        }
    }
    else {
        return undefined;
    }
}
exports.loadModuleFileSync = loadModuleFileSync;
/**
 * Load an ASK Module file from file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.json`.
 * @param uri file path of the Module File
 * @returns source file of the module if it is a valid module, otherwise `undefined`.
 */
async function loadModuleFile(baseDir, uri) {
    const json = await (0, util_1.readJsonFile)((0, util_1.trimScheme)(uri));
    if ((json === null || json === void 0 ? void 0 : json.schema) === ask.ModuleSchema) {
        try {
            return (0, source_file_1.sourceFile)(baseDir, uri, ask.fromASKModule(json, uri));
        }
        catch (err) {
            console.log(`failed to load module file: ${uri}`);
            console.error(err);
            throw err;
        }
    }
    else {
        return undefined;
    }
}
exports.loadModuleFile = loadModuleFile;
/**
 * Load an ACDL file from the file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.acdl`.
 * @param uri file path of the Module File
 * @param content optionally pass the ACDL string content already read from the file
 */
function loadACDLFileSync(dir, uri, content) {
    return (0, source_file_1.sourceFile)(dir, uri, ...parseACDLFile(uri, content !== null && content !== void 0 ? content : (0, util_1.readFileSync)(uri)));
}
exports.loadACDLFileSync = loadACDLFileSync;
/**
 * Load an ACDL file from the file system.
 *
 * @param baseDir base directory that contains this file, e.g. `src/` for `src/subdir/file.acdl`.
 * @param uri file path of the Module File
 * @param content optionally pass the ACDL string content already read from the file
 */
async function loadACDLFile(dir, uri, content) {
    return (0, source_file_1.sourceFile)(dir, uri, ...parseACDLFile(uri, content !== null && content !== void 0 ? content : (await (0, util_1.readFile)(uri))));
}
exports.loadACDLFile = loadACDLFile;
/**
 * Parse an ACDL file.
 *
 * @param content ACDL file content
 */
function parseACDLFile(uri, content) {
    const lexer = new acdl.ACDLLexer(antlr.CharStreams.fromString(content));
    const tokenStream = new antlr.CommonTokenStream(lexer);
    const parser = new acdl.ACDLParser(tokenStream);
    const errors = [];
    parser.removeErrorListeners();
    parser.addErrorListener({
        syntaxError: (recognizer, offendingSymbol, line, charPositionInLine, msg) => {
            errors.push(error_factory_1.ValidationErrorFactory.SyntaxError({
                expr: {
                    uri,
                    loc: {
                        begin: { line, character: charPositionInLine },
                        end: { line, character: charPositionInLine },
                    },
                },
                overrideMessage: msg,
            }));
        },
    });
    let module;
    try {
        const unit = parser.module();
        const nameCounter = new Counter();
        const imports = [];
        const namespaceNode = (0, try_1.Try)(() => unit.namespaceDeclaration())
            .flatMap((ns) => (0, try_1.Try)(() => ns === null || ns === void 0 ? void 0 : ns.qualifiedName()))
            .getOrDefault(undefined);
        const context = new ParseContext(uri, namespaceNode === null || namespaceNode === void 0 ? void 0 : namespaceNode.text, nameCounter, errors, [], imports);
        const namespace = new ask.Name(namespaceNode === null || namespaceNode === void 0 ? void 0 : namespaceNode.text, namespaceNode ? parseLocation(namespaceNode) : undefined);
        unit.moduleExpression().forEach((expr) => {
            if (expr.importDeclaration()) {
                imports.push(new ask.Import(expr.importDeclaration().ASTERISK() ? "ImportNamespace" : "ImportName", expr.importDeclaration().qualifiedName().text, parseLocation(expr)));
            }
        });
        const expressions = unit
            .moduleExpression()
            .map((expr) => {
            if (expr.actionDeclaration()) {
                return parseActionDeclaration(expr.actionDeclaration(), context);
            }
            if (expr.dialogDeclaration()) {
                return parseDialogDeclaration(expr.dialogDeclaration(), context);
            }
            if (expr.interactionDeclaration()) {
                return parseInteractionDeclaration(expr.interactionDeclaration(), context);
            }
            if (expr.qualifiedNameDeclaration()) {
                return parseNameDeclaration(expr.qualifiedNameDeclaration(), context);
            }
            if (expr.typeDeclaration()) {
                return parseTypeDeclaration(expr.typeDeclaration(), context);
            }
            if (expr.enumDeclaration()) {
                return parseEnumDeclaration(expr.enumDeclaration(), context);
            }
            if (expr.expression()) {
                return parseExpression(expr.expression(), context);
            }
            return undefined;
        })
            .filter((e) => e !== undefined);
        const exports = expressions.map((e) => { var _a; return e.kind !== "InteractionDeclaration" && ((_a = e === null || e === void 0 ? void 0 : e.name) === null || _a === void 0 ? void 0 : _a.name); }).filter((n) => n !== undefined);
        module = new ask.Module(uri, ask.ModuleSchema, namespace, imports, exports, expressions);
    }
    catch (err) {
        module = undefined;
    }
    return [module, errors || undefined];
}
exports.parseACDLFile = parseACDLFile;
/**
 * Parse the qualified name component of a module-level declaration.
 *
 * That include:
 * - ActionDeclaration
 * - DialogDeclaration
 * - QualifiedNameDeclaration
 * - TypeDeclaration
 */
function parseModuleLevelNameDeclaration(node, context) {
    let name = parseQualifiedName(node);
    if (name.name) {
        if (name.name.includes(".")) {
            name = new ask.Name(name.name, name.loc);
        }
        else if (context.namespace) {
            name = new ask.Name(`${context.namespace}.${name.name}`, name.loc);
        }
        else {
            name = new ask.Name(name.name, name.loc);
        }
    }
    return name;
}
exports.parseModuleLevelNameDeclaration = parseModuleLevelNameDeclaration;
function parseEnumDeclaration(type, context) {
    return new ask.EnumDeclaration(parseModuleLevelNameDeclaration(type.qualifiedName(), context), type.enumItem().map((id) => parseEnumItem(id, context)), parseAnnotationList(type.annotationList(), context), parseLocation(type));
}
exports.parseEnumDeclaration = parseEnumDeclaration;
function parseEnumItem(item, context) {
    return new ask.EnumItem(parseIdentifier(item.identifier()), parseAnnotationList(item.annotationList(), context), parseLocation(item));
}
exports.parseEnumItem = parseEnumItem;
function parseAnnotationList(annotationList, context) {
    var _a;
    const list = ((_a = annotationList === null || annotationList === void 0 ? void 0 : annotationList.annotation()) === null || _a === void 0 ? void 0 : _a.map((annotation) => new ask.Annotation(parseCall(annotation.call(), context)), undefined)) || undefined;
    if (list === undefined || list.length === 0) {
        return undefined;
    }
    return list;
}
exports.parseAnnotationList = parseAnnotationList;
function parseTypeDeclaration(type, context) {
    var _a;
    const name = parseModuleLevelNameDeclaration(type.qualifiedName(), context);
    return new ask.TypeDeclaration(name, (0, util_1.sanitize)((0, try_1.Try)(() => type.typeProperties())
        .flatMap((typeBody) => (0, try_1.Try)(() => typeBody === null || typeBody === void 0 ? void 0 : typeBody.typeProperty()).map((typeProperties) => typeProperties === null || typeProperties === void 0 ? void 0 : typeProperties.map((typeProperty) => parseTypeProperty(typeProperty, context))))
        .resolve(context)), (0, util_1.sanitize)(parseTypeArgumentDeclarations(type.typeArgumentDeclarations(), context)), (0, util_1.sanitize)((_a = type.typeConstraint()) === null || _a === void 0 ? void 0 : _a.map((e) => parseTypeReference(e.typeReference(), context))), parseAnnotationList(type.annotationList(), context), parseLocation(type));
}
exports.parseTypeDeclaration = parseTypeDeclaration;
function parseTypeArgumentDeclarations(args, context) {
    return args === null || args === void 0 ? void 0 : args.typeArgumentDeclaration().map((arg) => parseTypeArgumentDeclaration(arg, context));
}
exports.parseTypeArgumentDeclarations = parseTypeArgumentDeclarations;
function parseTypeArgumentDeclaration(arg, context) {
    var _a;
    return new ask.TypeParameter(parseIdentifier(arg.identifier()), (0, util_1.sanitize)((_a = arg.typeConstraint()) === null || _a === void 0 ? void 0 : _a.map((constraint) => parseTypeReference(constraint.typeReference(), context))), parseLocation(arg));
}
exports.parseTypeArgumentDeclaration = parseTypeArgumentDeclaration;
function parseTypeReference(reference, context) {
    var _a, _b;
    let loc;
    if (reference.typeArguments() === undefined) {
        loc = parseIdentifierLocation(reference.qualifiedName());
    }
    else {
        loc = parseLocation(reference);
    }
    return new ask.TypeReference((0, try_1.Try)(() => reference.qualifiedName())
        .map((name) => parseQualifiedName(name))
        .resolve(context), (0, util_1.sanitize)((_b = (_a = reference
        .typeArguments()) === null || _a === void 0 ? void 0 : _a.typeReference()) === null || _b === void 0 ? void 0 : _b.map((ref) => parseTypeReference(ref, context))), parseAnnotationList(reference.annotationList(), context), undefined, loc);
}
exports.parseTypeReference = parseTypeReference;
function parseTypeProperty(property, context) {
    return new ask.TypeProperty(property.identifier() ? parseIdentifier(property.identifier()) : undefined, (0, try_1.Try)(() => property.typeReference())
        .map((t) => parseTypeReference(t, context))
        .resolve(context), (0, try_1.Try)(() => property.OPTIONAL())
        .map((o) => !!o)
        .resolve(context), parseAnnotationList(property.annotationList(), context), parseLocation(property));
}
exports.parseTypeProperty = parseTypeProperty;
function parseNamespaceDeclaration(namespace, context) {
    return new ask.Name((0, try_1.Try)(() => namespace.qualifiedName())
        .map((name) => name.text)
        .resolve(context), parseLocation(namespace));
}
exports.parseNamespaceDeclaration = parseNamespaceDeclaration;
function parseDialogDeclaration(dialog, context) {
    const functionDecl = parseFunctionSignature(dialog.functionSignature(), context);
    return new ask.DialogDeclaration(functionDecl.name, functionDecl.args, (0, try_1.Try)(() => dialog.dialogScope())
        .flatMap((body) => (0, try_1.Try)(() => body === null || body === void 0 ? void 0 : body.sampleDeclaration()).map((samples) => (samples === null || samples === void 0 ? void 0 : samples.map((s) => parseSampleDeclaration(s, context))) || []))
        .resolve(context), functionDecl.returnType, functionDecl.genericArguments, parseAnnotationList(dialog.annotationList(), context), parseLocation(dialog));
}
exports.parseDialogDeclaration = parseDialogDeclaration;
function parseSampleDeclaration(sample, context) {
    return new ask.Sample((0, try_1.Try)(() => sample.block())
        .map((_) => parseScope(_, context, ask.Block))
        .resolve(context), parseAnnotationList(sample.annotationList(), context), parseLocation(sample));
}
exports.parseSampleDeclaration = parseSampleDeclaration;
function parseScope(body, context, ctor) {
    return (0, try_1.Try)(() => body.blockExpression())
        .map((expressions) => {
        const scopeExpressions = [];
        const scopeContext = context;
        for (const expr of expressions) {
            const parsedExpr = parseScopeExpression(expr, scopeContext);
            if (parsedExpr !== undefined) {
                scopeExpressions.push(parsedExpr); // TODO: assert
            }
        }
        return new ctor(scopeExpressions, parseLocation(body));
    })
        .resolve(context);
}
exports.parseScope = parseScope;
function parseScopeExpression(expr, context) {
    if (expr.nameDeclaration()) {
        return parseNameDeclaration(expr.nameDeclaration(), context);
    }
    if (expr.expression()) {
        return parseExpression(expr.expression(), context);
    }
    return undefined;
}
exports.parseScopeExpression = parseScopeExpression;
function parseInteractionDeclaration(expr, context) {
    return new ask.InteractionDeclaration((0, try_1.Try)(() => expr.block())
        .map((_) => parseScope(_, context, ask.InteractionScope))
        .resolve(context), parseAnnotationList(expr.annotationList(), context), parseLocation(expr));
}
exports.parseInteractionDeclaration = parseInteractionDeclaration;
function parseExpression(expr, context) {
    if (expr instanceof acdl.ParenthesizedExprContext) {
        return (0, try_1.Try)(() => expr.expression())
            .map((expr) => parseExpression(expr, context))
            .resolve(context);
    }
    if (expr instanceof acdl.LiteralExprContext || expr instanceof acdl.LiteralContext) {
        return parseLiteral(expr, context).resolve(context);
    }
    if (expr instanceof acdl.ObjectContext) {
        return (0, try_1.Try)(() => parseObject(expr, context)).resolve(context);
    }
    if (expr instanceof acdl.PropertyReferenceContext) {
        return parsePropertyReference(expr, context);
    }
    if (expr instanceof acdl.ListIndexContext) {
        return (0, try_1.Try)(() => parseListIndex(expr, context)).resolve(context);
    }
    if (expr instanceof acdl.CallExprContext) {
        return (0, try_1.Try)(() => parseCall(expr.call(), context)).resolve(context);
    }
    if (expr instanceof acdl.BinaryExprContext) {
        return parseBinaryExpression(expr, context).resolve(context);
    }
    if (expr instanceof acdl.NameDeclarationContext || expr instanceof acdl.QualifiedNameDeclarationContext) {
        return (0, try_1.Try)(() => parseNameDeclaration(expr, context)).resolve(context);
    }
    if (expr instanceof acdl.ConditionExprContext) {
        return (0, try_1.Try)(() => parseCondition(expr.condition(), context)).resolve(context);
    }
    if (expr instanceof acdl.CorrectionExprContext) {
        return (0, try_1.Try)(() => parseCorrection(expr.correction(), context)).resolve(context);
    }
    if (expr instanceof acdl.IdentifierExprContext) {
        return parseNameReference(expr, context);
    }
    if (expr instanceof acdl.IsExprContext) {
        return parseIsOperator(expr, context);
    }
    if (expr instanceof acdl.InExprContext) {
        return parseInOperator(expr, context);
    }
    const errorFactory = expr.text
        ? error_factory_1.ValidationErrorFactory.UnexpectedOperatorWithText
        : error_factory_1.ValidationErrorFactory.UnexpectedOperator;
    const error = errorFactory({
        expr: {
            uri: context.uri,
            loc: parseLocation(expr),
        },
        attributes: {
            expressionText: expr.text,
            constructorName: expr.constructor.name,
        },
    });
    context.addError(error);
    return undefined;
}
exports.parseExpression = parseExpression;
function parseNameReference(expr, context) {
    return new ask.NameReference(parseIdentifier(expr.identifier()), undefined, parseIdentifierLocation(expr.identifier()));
}
exports.parseNameReference = parseNameReference;
function parsePropertyReference(expr, context) {
    var _a, _b;
    const child = parseExpression(expr.expression(), context); // TODO: type check
    if (child === undefined) {
        return undefined;
    }
    const id = parseIdentifier(expr.identifier());
    const loc = parseLocation(expr);
    if (loc) {
        loc.end = (_b = (_a = id === null || id === void 0 ? void 0 : id.loc) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : loc.end;
    }
    const prop = new ask.PropertyReference(id, child, undefined, loc);
    return prop;
}
exports.parsePropertyReference = parsePropertyReference;
function parseCondition(expr, context) {
    var _a, _b, _c, _d;
    const loc = parseLocation(expr);
    let elseScope;
    if (((_a = expr.otherwise()) === null || _a === void 0 ? void 0 : _a.condition()) !== undefined) {
        const elseIfCondition = parseCondition((_b = expr.otherwise()) === null || _b === void 0 ? void 0 : _b.condition(), context);
        elseScope = new ask.ElseScope(elseIfCondition ? [elseIfCondition] : undefined);
    }
    else if (((_c = expr.otherwise()) === null || _c === void 0 ? void 0 : _c.block()) !== undefined) {
        elseScope = parseScope((_d = expr.otherwise()) === null || _d === void 0 ? void 0 : _d.block(), context, ask.ElseScope);
    }
    return new ask.Condition(new ask.When((0, try_1.Try)(() => expr.expression())
        .map((when) => parseExpression(when, context))
        .resolve(context)), // TODO: check,
    (0, try_1.Try)(() => expr.block())
        .map((body) => (body ? parseScope(body, context, ask.ThenScope) : undefined))
        .resolve(context), elseScope, undefined, loc);
}
exports.parseCondition = parseCondition;
function parseCorrection(expr, context) {
    return new ask.Correction((0, try_1.Try)(() => expr.block(0))
        .map((blockContext) => parseScope(blockContext, context, ask.CorrectionScope))
        .resolve(context), (0, try_1.Try)(() => expr.block(1))
        .map((blockContext) => parseScope(blockContext, context, ask.CorrectionScope))
        .resolve(context), parseLocation(expr));
}
exports.parseCorrection = parseCorrection;
function parseBinaryExpression(expr, context) {
    const loc = parseLocation(expr);
    return (0, try_1.Try)(() => {
        if (expr._left) {
            return new ask.Call(new ask.Name(parseBooleanOperator(expr, context)), [asArgumentValue(expr._left, "left"), asArgumentValue(expr._right, "right")], undefined, undefined, loc);
        }
        if (expr.NOT()) {
            return new ask.Call(new ask.Name(ast_1.AlexaConversations.Not), [asArgumentValue(expr._right, "right")], undefined, undefined, loc);
        }
        throw [
            error_factory_1.ValidationErrorFactory.UnexpectedBooleanExpression({
                expr: {
                    loc,
                },
                attributes: {
                    expressionText: expr.text,
                },
            }),
        ];
    });
    function asArgumentValue(expr, name) {
        return new ask.Argument(new ask.Name(name), undefined, parseExpression(expr, context), parseLocation(expr));
    }
}
exports.parseBinaryExpression = parseBinaryExpression;
function parseBooleanOperator(expr, context) {
    var _a, _b, _c, _d, _e, _f;
    const loc = parseLocation(expr);
    if (expr.AND()) {
        return ast_1.AlexaConversations.And;
    }
    if (expr.OR()) {
        return ast_1.AlexaConversations.Or;
    }
    if ((_a = expr.relational()) === null || _a === void 0 ? void 0 : _a.GE()) {
        return ast_1.AlexaConversations.Gte;
    }
    if ((_b = expr.relational()) === null || _b === void 0 ? void 0 : _b.GT()) {
        return ast_1.AlexaConversations.Gt;
    }
    if ((_c = expr.relational()) === null || _c === void 0 ? void 0 : _c.LE()) {
        return ast_1.AlexaConversations.Lte;
    }
    if ((_d = expr.relational()) === null || _d === void 0 ? void 0 : _d.LT()) {
        return ast_1.AlexaConversations.Lt;
    }
    if ((_e = expr.equality()) === null || _e === void 0 ? void 0 : _e.EQUAL()) {
        return ast_1.AlexaConversations.Eq;
    }
    if ((_f = expr.equality()) === null || _f === void 0 ? void 0 : _f.NOTEQUAL()) {
        return ast_1.AlexaConversations.Neq;
    }
    context.addError(error_factory_1.ValidationErrorFactory.UnexpectedBooleanOperator({
        expr: {
            loc,
        },
        attributes: {
            expressionText: expr.text,
        },
    }));
    return undefined;
}
exports.parseBooleanOperator = parseBooleanOperator;
function parseCall(expr, context) {
    var _a, _b;
    const name = (0, try_1.Try)(() => expr.qualifiedName())
        .map((fqn) => parseQualifiedName(fqn))
        .resolve(context);
    const args = (0, try_1.Try)(() => expr.callArguments())
        .flatMap((list) => (0, try_1.Try)(() => list === null || list === void 0 ? void 0 : list.callArgument()).map((argumentList) => argumentList === null || argumentList === void 0 ? void 0 : argumentList.map((a, i) => parseArgumentValue(a, context, i))))
        .resolve(context);
    const genericArguments = (0, util_1.sanitize)((_b = (_a = expr
        .typeArguments()) === null || _a === void 0 ? void 0 : _a.typeReference()) === null || _b === void 0 ? void 0 : _b.map((ref) => parseTypeReference(ref, context)));
    return new ask.Call(name, args, genericArguments, undefined, parseLocation(expr));
}
exports.parseCall = parseCall;
function parseArgumentValue(argument, context, index) {
    const name = (0, try_1.Try)(() => argument.identifier())
        .map((i) => (i ? parseIdentifier(i) : undefined))
        .resolve(context);
    const value = (0, try_1.Try)(() => argument.expression())
        .map((expr) => parseExpression(expr, context))
        .resolve(context); // TODO: type-check
    const loc = name && name.loc && (value === null || value === void 0 ? void 0 : value.loc) ? ask.appendLocation(name.loc, value.loc) : value === null || value === void 0 ? void 0 : value.loc;
    return new ask.Argument(name, index, value, loc);
}
exports.parseArgumentValue = parseArgumentValue;
function parseLiteral(literal, context) {
    const literalValue = literal.text;
    const litLoc = parseLocation(literal);
    const loc = {
        begin: litLoc.begin,
        end: {
            line: litLoc.begin.line,
            character: litLoc.begin.character + literal.text.length,
        },
    };
    return (0, try_1.Try)(() => {
        var _a, _b;
        if (literal.null()) {
            return createLiteral(ast_1.AlexaSchema.Void, null, loc);
        }
        if (literal.nothing()) {
            return createLiteral(ast_1.AlexaSchema.Nothing, null, loc);
        }
        if (literal.string()) {
            const vars = (_a = literal.string()) === null || _a === void 0 ? void 0 : _a.var();
            const text = literalValue.slice(1, literalValue.length - 1);
            let value = text;
            if (vars && vars.length > 0) {
                value = new ask.Utterance(text, vars.map((v) => parseQualifiedName(v.qualifiedName())), parseLocation(literal));
            }
            return createLiteral(ast_1.AlexaSchema.String, value, loc);
        }
        if (literal.number()) {
            const num = !literalValue.includes(".") ? parseInt(literalValue, 10) : parseFloat(literalValue);
            return createLiteral(ast_1.AlexaSchema.Number, num, loc);
        }
        if (literal.bool()) {
            return createLiteral(ast_1.AlexaSchema.Boolean, ((_b = literal.bool()) === null || _b === void 0 ? void 0 : _b.text.toLocaleLowerCase()) === "true", loc);
        }
        if (literal.object()) {
            return parseObject(literal.object(), context);
        }
        if (literal.list()) {
            return parseList(literal.list(), context);
        }
        console.error(literal);
        throw new Error("unexpected node type");
    });
}
exports.parseLiteral = parseLiteral;
function createLiteral(type, value, loc) {
    return new ask.Call(new ask.Name(type), value, undefined, undefined, loc);
}
exports.createLiteral = createLiteral;
function parseIsOperator(expr, context) {
    return new ask.Call(new ask.Name(ast_1.AlexaConversations.is /* TODO: map the IS token to a source location */), [new ask.Argument(new ask.Name("thing"), 0, parseExpression(expr.expression(), context))], [parseTypeReference(expr.typeReference(), context)]);
}
exports.parseIsOperator = parseIsOperator;
function parseInOperator(expr, context) {
    return new ask.Call(new ask.Name(ast_1.AlexaConversations.in), [
        new ask.Argument(new ask.Name("entity"), 0, parseExpression(expr.expression(0), context)),
        new ask.Argument(new ask.Name("entities"), 0, parseExpression(expr.expression(1), context)),
    ]);
}
exports.parseInOperator = parseInOperator;
function parseObject(obj, context) {
    const objectType = (0, try_1.Try)(() => obj.typeReference())
        .map((type) => (type ? parseTypeReference(type, context) : undefined))
        .resolve(context);
    return new ask.Call(objectType === null || objectType === void 0 ? void 0 : objectType.name, (0, try_1.Try)(() => obj.objectKeyValue())
        .map((pairs) => pairs.map((pair) => parseObjectProperty(pair, context)))
        .resolve(context), objectType === null || objectType === void 0 ? void 0 : objectType.arguments, undefined, parseLocation(obj));
}
exports.parseObject = parseObject;
function parseObjectProperty(member, context) {
    const name = parseIdentifier(member.identifier());
    const expr = member.expression();
    const value = (expr === undefined
        ? // if no value is explicitly provided, default to a name reference
            // name = "hello"
            // person Person { name }
            // equiv. { name = name }
            new ask.NameReference(name, undefined, name.loc)
        : parseExpression(expr, context));
    return new ask.Argument(name, undefined, value, parseLocation(member));
}
exports.parseObjectProperty = parseObjectProperty;
/**
 * Parse a List literal to a call
 *
 * ```
 * list = ["a", "b"]
 * // or
 * list = List<String> ["a", "b"]
 *
 * // translates to an internal representations
 * alexa.lang.expression<List<String>>(items = ["a", "b"])
 * ```
 *
 * @param expr
 * @param parent
 * @param errors
 */
function parseList(expr, context) {
    const loc = parseLocation(expr);
    const list = new ask.ListLiteral(expr
        .expression()
        .map((expr, index) => new ask.ListItem(parseExpression(expr, context), index, parseLocation(expr))), loc);
    return new ask.Call(undefined, list, undefined, undefined, parseLocation(expr));
}
exports.parseList = parseList;
/**
 * Parse syntactic sugar for accessing a list.
 *
 * ```
 * List<String> list = ...
 *
 * // access a list by index 0
 * list[0]
 *
 * // is syntactic sugar for the `inList` action:
 * com.amazon.alexa.ask.conversations.inList(list = list, index = 0)
 * com.amazon.alexa.ask.conversations.inList(list, 0)
 * ```
 *
 * TODO: support accessing properties in a List.
 * ```
 * // how should we translate this?
 * c = list[0].a.b.c
 *
 * // perhaps generate a variable for the result of accessing the list
 * var1 = inList(list, 0)
 * // and then a name expression?
 * c = var1.a.b.c
 * ```
 *
 * @param expr syntax for the list
 * @param parent
 * @param errors
 */
function parseListIndex(expr, context) {
    const list = parseExpression(expr.expression(), context); // TODO: type-check
    const listArg = new ask.Argument(new ask.Name("list"), 0, list, parseLocation(expr));
    const indexNumber = (0, try_1.Try)(() => parseInt(expr.number().text, 10)).resolve(context);
    const indexLiteral = createLiteral(ast_1.AlexaSchema.Number, indexNumber, parseLocation(expr.number()));
    const indexArg = new ask.Argument(new ask.Name("index"), 1, indexLiteral);
    return new ask.Call(new ask.Name(ast_1.AlexaConversations.getListItem), [listArg, indexArg], undefined, undefined, parseLocation(expr));
}
exports.parseListIndex = parseListIndex;
function parseActionDeclaration(action, context) {
    const functionDecl = parseFunctionSignature(action.functionSignature(), context);
    return new ask.ActionDeclaration(functionDecl.name, functionDecl.args, functionDecl.returnType, functionDecl.genericArguments, parseAnnotationList(action.annotationList(), context), parseLocation(action));
}
exports.parseActionDeclaration = parseActionDeclaration;
function parseFunctionSignature(action, context, isTopLevel = true) {
    var _a, _b;
    let returnType;
    const _void = action.void();
    if (_void !== undefined || action.typeReference() === undefined) {
        returnType = new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.Void), undefined, parseAnnotationList(_void === null || _void === void 0 ? void 0 : _void.annotationList(), context), undefined, _void ? parseLocation(_void) : undefined);
    }
    else {
        returnType = parseTypeReference(action.typeReference(), context);
    }
    const functionDecl = {
        name: isTopLevel
            ? parseModuleLevelNameDeclaration((_a = action.qualifiedName()) !== null && _a !== void 0 ? _a : action.identifier(), context)
            : parseQualifiedName((_b = action.qualifiedName()) !== null && _b !== void 0 ? _b : action.identifier()),
        // TODO: what to do with this?
        args: (0, try_1.Try)(() => action.argumentDeclarations())
            .map((p) => (p ? parseArgumentDeclarations(p, context) : undefined))
            .resolve(context),
        returnType,
        genericArguments: parseTypeArgumentDeclarations(action.typeArgumentDeclarations(), context),
    };
    return functionDecl;
}
exports.parseFunctionSignature = parseFunctionSignature;
function parseArgumentDeclarations(argumentDecls, context) {
    return argumentDecls.argumentDeclaration().map((p) => parseArgumentDeclaration(p, context));
}
exports.parseArgumentDeclarations = parseArgumentDeclarations;
function parseArgumentDeclaration(argument, context) {
    var _a, _b;
    const defaultExpression = ((_a = argument.argumentDefault()) === null || _a === void 0 ? void 0 : _a.expression())
        ? parseExpression(argument.argumentDefault().expression(), context)
        : undefined;
    const isOptional = argument.OPTIONAL() !== undefined || ((defaultExpression === null || defaultExpression === void 0 ? void 0 : defaultExpression.kind) === "Call" && ((_b = defaultExpression === null || defaultExpression === void 0 ? void 0 : defaultExpression.name) === null || _b === void 0 ? void 0 : _b.name) === ast_1.AlexaSchema.Nothing);
    if (argument.functionArgumentDeclaration()) {
        return parseFunctionArgumentDeclaration(argument.functionArgumentDeclaration());
    }
    if (argument.standardArgumentDeclaration()) {
        return parseStandardArgumentDeclaration(argument.standardArgumentDeclaration());
    }
    // fatal error, only these two options should be possible.
    throw new Error(`could not parse argument declaration: ${argument.text}`);
    function parseStandardArgumentDeclaration(argDecl) {
        var _a, _b;
        let type;
        if (isOptional) {
            if ((argDecl === null || argDecl === void 0 ? void 0 : argDecl.typeReference()) !== undefined) {
                const innerType = parseTypeReference(argDecl.typeReference(), context);
                if (((_a = innerType.name) === null || _a === void 0 ? void 0 : _a.name) === ast_1.AlexaSchema.Optional || (((_b = innerType.name) === null || _b === void 0 ? void 0 : _b.name) === "Optional" && context.hasOptionalImported())) {
                    // type is already Optional, flatten.
                    // innerType.parent = self;
                    type = innerType;
                }
                else {
                    type = new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.Optional), [innerType], undefined, // innerType.annotations?.map((a) => a.clone()),
                    undefined);
                }
            }
            else {
                type = new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.Optional), [new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.Nothing), undefined, undefined, undefined)], undefined, undefined);
            }
        }
        else if (argDecl.typeReference() !== undefined) {
            type = parseTypeReference(argDecl.typeReference(), context);
        }
        else {
            type = new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.Nothing), undefined, undefined);
        }
        return new ask.ArgumentDeclaration(argDecl.identifier() ? parseIdentifier(argDecl.identifier()) : undefined, type, defaultExpression, parseAnnotationList(argument.annotationList(), context), parseLocation(argument));
    }
    function parseFunctionArgumentDeclaration(fun) {
        var _a, _b, _c, _d, _e, _f, _g;
        const functionSignature = parseFunctionSignature(fun.functionSignature(), context, false);
        const functionArgumentNames = (_c = (_b = (_a = fun
            .functionSignature()
            .argumentDeclarations()) === null || _a === void 0 ? void 0 : _a.argumentDeclaration()) === null || _b === void 0 ? void 0 : _b.map((a, i) => {
            var _a, _b, _c, _d;
            // TODO: this is probably risky??? ACDL will give syntax error though ...
            const defaultArgName = `arg${i}`;
            if (a.standardArgumentDeclaration()) {
                return (_b = (_a = a.standardArgumentDeclaration().identifier()) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : defaultArgName;
            }
            if (a.functionArgumentDeclaration()) {
                return (_d = (_c = a.functionArgumentDeclaration().functionSignature().identifier()) === null || _c === void 0 ? void 0 : _c.text) !== null && _d !== void 0 ? _d : defaultArgName;
            }
            return defaultArgName;
        })) !== null && _c !== void 0 ? _c : [];
        const functionArity = functionArgumentNames.length;
        const typeRefLoc = ((_d = functionSignature.name) === null || _d === void 0 ? void 0 : _d.loc)
            ? ask.betweenLocations(parseLocation(fun), (_e = functionSignature.name) === null || _e === void 0 ? void 0 : _e.loc)
            : parseLocation(fun);
        const typeRefName = fun.ACTION()
            ? (0, ast_1.ActionTypeName)(functionArity)
            : fun.DIALOG()
                ? (0, ast_1.DialogTypeName)(functionArity)
                : (0, ast_1.FunctionTypeName)(functionArity);
        const type = new ask.TypeReference(new ask.Name(typeRefName, typeRefLoc), [...((_g = (_f = functionSignature.args) === null || _f === void 0 ? void 0 : _f.map((arg) => arg.type /* use an object to represent undefined */)) !== null && _g !== void 0 ? _g : []), functionSignature.returnType], undefined, functionArgumentNames, typeRefLoc);
        return new ask.ArgumentDeclaration(functionSignature.name, isOptional ? new ask.TypeReference(new ask.Name(ast_1.AlexaSchema.Optional, type.loc), [type]) : type, defaultExpression, parseAnnotationList(argument.annotationList(), context));
    }
}
exports.parseArgumentDeclaration = parseArgumentDeclaration;
/**
 * Parse a name initialization expression.
 *
 * ```acdl
 * a = <expr>
 * ```
 *
 * @param nameDecl name parse tree
 * @param parent parent expression
 */
function parseNameDeclaration(nameDecl, context) {
    const name = nameDecl instanceof acdl.QualifiedNameDeclarationContext
        ? parseModuleLevelNameDeclaration(nameDecl.qualifiedName(), context)
        : parseIdentifier(nameDecl.identifier());
    const type = nameDecl.typeReference() ? parseTypeReference(nameDecl.typeReference(), context) : undefined;
    const expr = (0, try_1.Try)(() => nameDecl.expression())
        .map((expr) => parseExpression(expr, context))
        .resolve(context);
    return new ask.NameDeclaration(name, type, expr, nameDecl instanceof acdl.QualifiedNameDeclarationContext ? parseAnnotationList(nameDecl.annotationList(), context) : undefined, parseLocation(nameDecl));
}
exports.parseNameDeclaration = parseNameDeclaration;
/**
 * Parse an identifier.
 *
 * @param id identifier parse tree
 * @param context parse context
 */
function parseIdentifier(id) {
    return new ask.Name(id.text === "<missing IDENTIFIER>" ? undefined : id.text, parseIdentifierLocation(id));
}
exports.parseIdentifier = parseIdentifier;
function parseIdentifierLocation(id) {
    const location = parseLocation(id);
    const loc = {
        begin: {
            line: location.begin.line,
            character: location.begin.character,
        },
        end: {
            line: location.begin.line,
            character: location.begin.character + id.text.length,
        },
    };
    return loc;
}
exports.parseIdentifierLocation = parseIdentifierLocation;
/**
 * Parse a qualified name.
 *
 * @param name identifier or qualified name.
 * @param parent parent expression
 */
function parseQualifiedName(name, prefix = "") {
    const fullName = name.text;
    const lastDot = fullName.indexOf(".");
    const identifier = lastDot === -1 ? fullName : fullName.substring(lastDot + 1);
    const qualifier = lastDot === -1 ? undefined : fullName.substring(0, lastDot);
    // TODO: match name with regex and report errors.
    return new ask.Name(qualifier === undefined ? `${prefix}${identifier}` : `${qualifier}.${identifier}`, parseIdentifierLocation(name));
}
exports.parseQualifiedName = parseQualifiedName;
/**
 * Parse the location from a node in the parse tree.
 *
 * @param node parse tree node.
 */
function parseLocation(node) {
    var _a, _b;
    const begin = {
        line: node.start.line,
        character: node.start.charPositionInLine,
    };
    // Antlr only gives us the "start of token" position.
    // To get "end of token" position we need to add the token length,
    // plus we need to adjust the line and column if there are newlines in the token's text
    const stopTokenText = (_a = node.stop) === null || _a === void 0 ? void 0 : _a.text;
    const stopTokenLines = (stopTokenText === null || stopTokenText === void 0 ? void 0 : stopTokenText.split("\\n")) || [];
    // Stop token has no text - no adjustment is needed
    if ((Array.isArray(stopTokenLines) && stopTokenLines.length > 0) || ((_b = node.stop) === null || _b === void 0 ? void 0 : _b.type) === antlr.Token.EOF) {
        return {
            begin,
            end: {
                line: node.stop.line,
                character: node.stop.charPositionInLine + 1,
            },
        };
    }
    const lastLineLength = stopTokenLines[stopTokenLines.length - 1].length;
    const tokenEnd = stopTokenLines.length === 1 ? node.stop.charPositionInLine + stopTokenText.length : lastLineLength;
    return {
        begin,
        end: {
            line: node.stop.line + stopTokenLines.length - 1,
            character: tokenEnd + 1,
        },
    };
}
exports.parseLocation = parseLocation;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcGFyc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxnREFBa0M7QUFDbEMsK0NBQWlDO0FBQ2pDLDJDQUE2QjtBQUU3QiwrQ0FBcUQ7QUFFckQsK0JBQW9DO0FBQ3BDLGlDQUFrSDtBQUNsSCwrQkFBd0c7QUFDeEcsbURBQW9GO0FBRXBGLE1BQWEsT0FBTztJQUNsQixZQUFvQixVQUFrQixDQUFDOzs7OzttQkFBbkI7O0lBQXNCLENBQUM7SUFFcEMsTUFBTTtRQUNYLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDO0NBQ0Y7QUFQRCwwQkFPQztBQUVELE1BQWEsWUFBWTtJQUN2QixZQUNrQixHQUFXLEVBQ1gsU0FBNkIsRUFDN0IsV0FBb0IsRUFDcEIsTUFBb0IsRUFDcEIsS0FBdUIsRUFDdkIsT0FBcUI7Ozs7O21CQUxyQjs7Ozs7O21CQUNBOzs7Ozs7bUJBQ0E7Ozs7OzttQkFDQTs7Ozs7O21CQUNBOzs7Ozs7bUJBQ0E7O0lBQ2YsQ0FBQztJQUVHLG1CQUFtQjtRQUN4QixPQUFPLENBQ0wsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQ2YsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNKLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxZQUFZLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxpQkFBVyxDQUFDLFFBQVEsQ0FBQztZQUM1RCxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssaUJBQWlCLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxJQUFBLG1CQUFZLEVBQUMsaUJBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUNsRixLQUFLLFNBQVMsQ0FDaEIsQ0FBQztJQUNKLENBQUM7SUFFTSxTQUFTLENBQUMsS0FBdUI7UUFDdEMsT0FBTyxJ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