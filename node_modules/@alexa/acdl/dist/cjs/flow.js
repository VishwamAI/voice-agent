"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Flow = void 0;
const immutable_1 = __importDefault(require("immutable"));
const ask = __importStar(require("./ast"));
const checker_1 = require("./checker");
const thing_1 = require("./thing");
const expression_1 = require("./expression");
const apply_1 = require("./apply");
class Flow {
    constructor(
    /**
     * Type Checker environment for this branch.
     */
    checker, 
    /**
     * The next expression in this branch sequence.
     */
    expression, 
    /**
     * Branch before this node.
     */
    prev, 
    /**
     * Node to continue the branch from
     */
    stack, 
    /**
     * Map of node to resolved Thing at this point in the branch.
     */
    things = immutable_1.default.Map(), 
    /**
     * Maps a TypeParameter to its concrete Type.
     */
    types = immutable_1.default.Map()) {
        Object.defineProperty(this, "checker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: checker
        });
        Object.defineProperty(this, "expression", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: expression
        });
        Object.defineProperty(this, "prev", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: prev
        });
        Object.defineProperty(this, "stack", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: stack
        });
        Object.defineProperty(this, "things", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: things
        });
        Object.defineProperty(this, "types", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: types
        });
    }
    /**
     * This function will walk over each dialog flow, parse each ASKIR {@link ask.Expression} into a
     * high-level {@link Expression} class and call the provided call back.
     *
     * Those Expressions represent concepts like {@link Expect}, {@link InvokeApi}, {@link ConditionalBranch}, {@link DialogExpansion}, etc.
     *
     * The most basic usage:
     * ```
     * flow.interpret(function interpret(expr): InterpretResult<boolean> {
     *   // process this expression in the stream
     *   const result = process(expr);
     *   if (result !== undefined) {
     *      // terminate the interpreter and end with this result
     *      return result;
     *   }
     *   // return a callback to handle the next expression after this one in the stream.
     *   return interpret;
     * })
     * ``
     *
     * Usually, you want to track some state. Do this with recursive closures. Below,
     * we track a variable, `seenEvent`, which we'll set to true if we come across an Expect event.
     *
     * At the end of the Dialog Flow stream, we'll return this value.
     * ```
     * get a list of booleans indicating if each branch in this Dialog Flow contains an Expect event.
     * const seenEvents = flow.interpret(function interpret(expr, seenEvent = false) {
     *   if (expr.isExpect()) {
     *     // if we receive an Expect event, we'll return a closure that sets the seenEvent variable to `true`.
     *     return (nextExpr) => interpret(nextExpr, true)
     *   } else if (expr.isEnd()) {
     *     // at the end, we'll return the result
     *     return seenEvent;
     *   } else {
     *     // otherwise, recursively process the next expression and pass along the `seenEvent` state.
     *     return (nextExpr) => interpret(nextExpr, seenEvent);
     *   }
     * })
     *
     * if (seenEvents.find(seenEvent => seenEvent === true) {
     *   // all
     * }
     * ```
     *
     * @param interpreter callback function to interpret the next Expression and return a
     * @param prev the previous Expression seen in this interpreter stream.
     * @returns a list of {@link State} objects, one for each branch in the Dialog Flow stream.
     */
    interpret(interpreter, prev) {
        return this.walkEachBranch((flow) => {
            const expr = getExpression();
            if (expr !== undefined) {
                const next = interpreter(expr);
                if (typeof next === "function") {
                    return flow.interpret(next, expr);
                }
                return [next];
            }
            // this node does not define an expression that should be evaluated, so we skip to the next one.
            return flow.interpret(interpreter, prev);
            function getExpression() {
                var _a, _b, _c, _d, _e, _f;
                if (flow.expression === undefined) {
                    return new expression_1.End(prev, flow);
                }
                if (flow.expression.kind === "Condition") {
                    return new expression_1.ConditionalBranch(prev, flow, flow.checker.getThing(flow.expression.when));
                }
                if (flow.expression.kind === "Call") {
                    const apply = flow.checker.getApply(flow.expression);
                    if (apply === undefined) {
                        return undefined;
                    }
                    if (apply.isResponse()) {
                        return new expression_1.Response(prev, flow, apply, apply.getArgumentValueThing("response"), apply.getArgumentValueThing("act"), apply.getArgumentValueThing("nextAct"), apply.getArgumentValueThing("payload"), (_a = apply.getArgumentValueThing("surfaceForm")) === null || _a === void 0 ? void 0 : _a.asString());
                    }
                    if (apply.isConfirmAction()) {
                        return new expression_1.ConfirmAction(prev, flow, apply.getArgumentValueThing("response"), (_b = apply.getArgumentValueThing("actionName")) === null || _b === void 0 ? void 0 : _b.asAction(), apply.getArgumentValueThing("payload"));
                    }
                    if (apply.isConfirmArgs()) {
                        return new expression_1.ConfirmArgs(prev, flow, (_c = apply.getArgumentValueThing("confirmArgs")) === null || _c === void 0 ? void 0 : _c.asList());
                    }
                    if (apply.isEnsure()) {
                        return new expression_1.Ensure(prev, flow, (_d = apply.getArgumentValueThing("requestArgs")) === null || _d === void 0 ? void 0 : _d.asList());
                    }
                    if (apply.isExpect()) {
                        return new expression_1.Expect(prev, flow, apply.getArgumentValueThing("act"), apply.getArgumentValueThing("event"));
                    }
                    if (apply.isUserDefinedApi()) {
                        const action = (_e = flow.checker.getThing(flow.checker.lookupCallDeclaration(apply.call))) === null || _e === void 0 ? void 0 : _e.asAction();
                        return new expression_1.InvokeApi(prev, flow, action, apply.getArgumentsThing());
                    }
                    if (apply.isDialog()) {
                        const dialog = (_f = flow.checker.getThing(flow.checker.lookupCallDeclaration(apply.call))) === null || _f === void 0 ? void 0 : _f.asDialog();
                        return new expression_1.DialogExpansion(prev, flow, dialog, apply.getArgumentsThing());
                    }
                }
                else if (flow.expression.kind === "Block") {
                    return new expression_1.BlockExpression(prev, flow);
                }
                return undefined;
            }
        });
    }
    /**
     * Push a Call or Condition node onto the Call Stack.
     *
     * @param node Call or Condition node to push onto the STack.
     * @returns a new Dialog Flow representing the environment within the Call or Condition
     */
    push(node) {
        return new Flow(this.checker, node, this, [node, ...this.stack], this.things);
    }
    /**
     * Steps to the next {@link expr} in the Dialog Flow.
     *
     * @param expr next expression in the flow
     * @returns a new Flow starting from the next {@link expr}
     */
    step(expr) {
        return new Flow(this.checker, expr, this, this.stack, expr ? this.things.set(expr, this.checker.getThing(expr)) : this.things);
    }
    /**
     * Walks back up the Stack to create a Flow continuing with the return value and next expression.
     *
     * @param returnValue the value returned from this Frame
     * @return Flow a new Data Flow reprsenting the continuation of this Flow after returning the value.
     */
    pop(returnValue) {
        var _a, _b;
        let { things } = this;
        let next;
        let stack;
        const checker = new checker_1.TypeChecker(this.checker.project, this.checker, this.things, this.types);
        // this code walks up the list of nodes in the call stack and sets the Thing value of each node to the `returnValue`,
        // it is implemented as low-level for and while loops to minimize stack frame allocation as this function is often called within
        // the highly recursive environment of Flow.interpret and Flow.walkEachBranch.
        for (let i = 0; i < this.stack.length; i++) {
            let frameNode = this.stack[i];
            let thing = returnValue;
            if (hasFunctions(returnValue)) {
                // if the returnValue's type contains Function definitions, we need to map the actual Function value's interface
                // to the interface expected by this environment
                thing = (_a = mapInterface(checker, returnValue, this.checker.root.getType(frameNode))) !== null && _a !== void 0 ? _a : thing;
            }
            checker.localThingIndex.set(frameNode, thing);
            things = things.set(frameNode, thing);
            if (frameNode !== undefined) {
                next = frameNode.next;
                if (next === undefined) {
                    // there was no adjacent expression, we will now walk up the context tree
                    // if we encounter a Block, then we break out of the loop and continue unrolling the stack (encountering a Block in the context should trigger a RETURN)
                    while (frameNode !== undefined && frameNode.kind !== "Block") {
                        if (frameNode.kind === "PropertyReference") {
                            // encountered a property reference, extract the property
                            // e.g, DialogCall().prop
                            thing = thing.getProperty(frameNode.name);
                        }
                        else if (frameNode.kind === "Call") {
                            const apply = this.checker.getApply(frameNode);
                            if (apply === null || apply === void 0 ? void 0 : apply.isGetListItem()) {
                                // we encountered a list index, e.g, DialogCall()[0], extract the item from the returned list
                                const index = (_b = apply.getArgumentValueThing("index")) === null || _b === void 0 ? void 0 : _b.asNumber();
                                if (index) {
                                    thing = thing.getItem(index);
                                }
                            }
                        }
                        // overwrite the mapping of Node->Thing in this environment
                        checker.localThingIndex.set(frameNode, thing);
                        things = things.set(frameNode, thing);
                        if (frameNode.next) {
                            // after un-rolling the stack, we found an adjacent node in a Block, we should stop unrolling here
                            next = frameNode.next;
                            break;
                        }
                        frameNode = frameNode.context;
                    }
                }
                if (next !== undefined) {
                    // pop the frames off of the stack.
                    stack = this.stack.slice(i + 1);
                    break;
                }
            }
        }
        return new Flow(checker, next, this, stack !== null && stack !== void 0 ? stack : [], things);
    }
    /**
     * Fork this Dialog Flow into a new dialog flow, starting from this {@link expr}.
     * @param expr expression from which we need to fork the dialog, e.g. a Call to a Dialog or Condition branch.
     * @returns a new Flow starting with the first expression in the forked Dialog Flow.
     */
    fork(expr) {
        var _a, _b, _c, _d;
        if (expr.kind === "Call") {
            const apply = this.checker.getApply(expr);
            if (apply === null || apply === void 0 ? void 0 : apply.isDialog()) {
                const args = apply.getArguments();
                const genericArgs = apply.getGenericArguments();
                const decl = apply.decl.kind === "DialogDeclaration" ? apply.decl : apply.decl.declaration;
                // resolve the generic arguments and map the TypeParameter nodes to the concrete types
                const types = (_b = (_a = decl.genericArguments) === null || _a === void 0 ? void 0 : _a.map((typeParameter, i) => { var _a; return immutable_1.default.Map([[typeParameter, (_a = genericArgs === null || genericArgs === void 0 ? void 0 : genericArgs[i]) !== null && _a !== void 0 ? _a : null]]); }).reduce((a, b) => a.merge(b), this.types)) !== null && _b !== void 0 ? _b : immutable_1.default.Map();
                const checker = new checker_1.TypeChecker(this.checker.project, this.checker, this.things, types);
                // plumb the arguments through from the previous frame.
                const things = (_d = (_c = decl.arguments) === null || _c === void 0 ? void 0 : _c.map((arg) => {
                    var _a, _b, _c, _d;
                    let thing;
                    if (((_a = arg.name) === null || _a === void 0 ? void 0 : _a.name) && (args === null || args === void 0 ? void 0 : args[(_b = arg.name) === null || _b === void 0 ? void 0 : _b.name])) {
                        thing = apply.getArgumentValueThing(arg.name.name);
                    }
                    else if (((_c = arg.name) === null || _c === void 0 ? void 0 : _c.name) && arg.defaultExpression) {
                        thing = this.checker.root.getThing(arg.defaultExpression);
                    }
                    if (hasFunctions(thing)) {
                        // if the argument's type contains Function definitions, we need to map the actual Function value's interface
                        // to the interface expected by this environment
                        thing = (_d = mapInterface(checker, thing, this.checker.root.getType(arg))) !== null && _d !== void 0 ? _d : thing;
                    }
                    // HACK: mutate the localThingIndex of Node->Thing in the next TypeChecker environment
                    checker.localThingIndex.set(arg, thing);
                    return immutable_1.default.Map().set(arg, thing !== null && thing !== void 0 ? thing : null);
                }).reduce((a, b) => a.merge(b), this.things)) !== null && _d !== void 0 ? _d : this.things;
                return new Flow(checker, decl, this, this.stack, things, types);
            }
        }
        return new Flow(new checker_1.TypeChecker(this.checker.project, this.checker, this.things, this.types), expr, this, this.stack, this.things, this.types);
    }
    visitPrevious(hook) {
        if (this.prev) {
            return hook(this.prev);
        }
        return hook(undefined);
    }
    walkEachBranch(hook) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        let node = this.expression;
        if (node === undefined) {
            return hook(this);
        }
        if (node.kind === "DialogDeclaration") {
            return (_b = (_a = node.samples) === null || _a === void 0 ? void 0 : _a.map((sample) => hook(this.step(sample))).reduce((a, b) => a.concat(b), [])) !== null && _b !== void 0 ? _b : [];
        }
        if (node.kind === "NameDeclaration") {
            if (node.expression) {
                return hook(this.step(node.expression));
            }
        }
        else if (node.kind === "Sample") {
            return hook(this.step(node.scope));
        }
        else if (node.kind === "Block") {
            if ((_c = node.expressions) === null || _c === void 0 ? void 0 : _c[0]) {
                return hook(this.step((_d = node.expressions) === null || _d === void 0 ? void 0 : _d[0]));
            }
        }
        else if (node.kind === "Condition") {
            if (((_f = (_e = node.then) === null || _e === void 0 ? void 0 : _e.expressions) === null || _f === void 0 ? void 0 : _f.length) && ((_h = (_g = node.else) === null || _g === void 0 ? void 0 : _g.expressions) === null || _h === void 0 ? void 0 : _h.length)) {
                return [
                    //
                    ...hook(this.push(node).fork(node.then)),
                    ...hook(this.push(node).fork(node.else)),
                ];
            }
            if ((_k = (_j = node.then) === null || _j === void 0 ? void 0 : _j.expressions) === null || _k === void 0 ? void 0 : _k.length) {
                return hook(this.push(node).step(node.then));
            }
            if ((_m = (_l = node.else) === null || _l === void 0 ? void 0 : _l.expressions) === null || _m === void 0 ? void 0 : _m.length) {
                return hook(this.push(node).step(node.else));
            }
        }
        else if (node.kind === "Call") {
            const apply = this.checker.getApply(node);
            if (apply !== undefined) {
                if (apply.isDialog()) {
                    return this.push(node).fork(node).walkEachBranch(hook);
                }
                if (apply.isGetListItem()) {
                    return hook(this.step(apply.getArgumentValue("list")));
                }
            }
        }
        else if (node.kind === "PropertyReference") {
            return hook(this.step(node.expression));
        }
        while (node !== undefined) {
            if (node.next) {
                return hook(this.step(node.next));
            }
            if (node.kind === "Block") {
                return hook(this.pop(this.checker.getThing(node)));
            }
            node = node.context;
        }
        return [];
    }
    /**
     * Returns true if the resetArgumentsAction resets the argument with value argValueThing. Returns false otherwise.
     * Example of false return:
     * ```
     * policies = [ResetArguments{arguments = [getWeather.arguments.cityName]}] //only reset cityName
     *
     * sample {
     *   weatherRequest = expect(Invoke, getWeatherEvent)
     *   getWeather(weatherRequest.cityName) // weatherRequest.cityName is reset
     * }
     * ```
     *
     * sample {
     *   weatherRequest = expect(Invoke, getWeatherEvent)
     *   people = expect(Invoke, getPeopleEvent)
     *   getWeather(weatherRequest.cityName, weatherRequest.date)
     *
     *   getWeather(weatherRequest.cityName, weatherRequest.date) // invalid since weatherRequest.cityName has been reset
     * }
     * ```
     * @param argValueThing 'Thing' object for the argument value we are validating
     * @param argumentActionName action name for the argument being validated
     * @param resetArgumentsAction {@link Apply} object for a an {@link Action} that has a corresponding ResetArguments policy
     * @param resetArgumentsPolicy the ResetArgumentsPolicy for the resetArgumentsAction
     * @param actionChecker checker for resetArgumentsAction
     * @returns true if the resetArgumentsAction resets the argument with value argValueThing which means:
     * 1) argumentActionName and resetArgumentsAction refer to the same action
     * 2) resetArgumentsAction is passed argValueThing
     * 3) resetArgumentsPolicy mentions the argument to which argValueThing is passed in resetArgumentsAction
     */
    doesResetArgumentsResetArgument(argValueThing, argumentActionName, resetArgumentsAction, resetArgumentsPolicy, actionChecker) {
        var _a;
        // when the action has ResetArguments policy, check whether the following three requirements are met:
        // 1. The action with the policy is the same as the action in the argument being validated
        if (((_a = resetArgumentsAction.decl.name) === null || _a === void 0 ? void 0 : _a.name) !== argumentActionName) {
            return false;
        }
        const resetArgumentsActionArgs = resetArgumentsAction.getArguments() || {};
        // 2. The argument value being validated is passed to the action with the policy
        for (const [resetArgumentsActionArgName, resetArgumentsActionArgValue] of Object.entries(resetArgumentsActionArgs)) {
            const resetArgumentsActionArgValueThing = actionChecker.getThing(resetArgumentsActionArgValue.value);
            if (!(resetArgumentsActionArgValueThing === null || resetArgumentsActionArgValueThing === void 0 ? void 0 : resetArgumentsActionArgValueThing.equals(argValueThing))) {
                continue;
            }
            // 3. The policy resets the argument being validated
            for (const policyArgName of resetArgumentsPolicy.arguments) {
                if (policyArgName === resetArgumentsActionArgName)
                    return true;
            }
        }
        return false;
    }
    /**
     * check whether the input argValue has been reset
     * @param argValueThing argValue to check whether it has been reset
     * @param argumentActionDecl The action declaration of the action which use the input argValue
     * @returns
     */
    isArgumentReset(argValueThing, argumentActionDecl) {
        var _a;
        const argumentActionName = (_a = argumentActionDecl.name) === null || _a === void 0 ? void 0 : _a.name;
        if (!argumentActionName) {
            return false;
        }
        const policyInfo = this.checker.project.getPolicyInfo();
        if (policyInfo === undefined || policyInfo.size === 0) {
            // If there's no reset policy configured, directly return false
            return false;
        }
        let isResetByResetArguments = false;
        let resetAllArgumentsSeen = false;
        const resetAllArgumentsArguments = new Set();
        for (let previousExpression = this.prev; previousExpression; previousExpression = previousExpression === null || previousExpression === void 0 ? void 0 : previousExpression.prev) {
            if ((previousExpression === null || previousExpression === void 0 ? void 0 : previousExpression.expression) === undefined) {
                break;
            }
            if (previousExpression.expression.kind !== "Call") {
                continue;
            }
            const previousApply = previousExpression.checker.getApply(previousExpression.expression);
            if (previousApply === undefined) {
                continue;
            }
            if (!previousApply.isUserDefinedApi()) {
                continue;
            }
            const actionName = previousApply.getName();
            if (!actionName) {
                continue;
            }
            const policyForCall = policyInfo.get(actionName);
            if (policyForCall) {
                if (policyForCall.type === "ResetArguments") {
                    if (this.doesResetArgumentsResetArgument(argValueThing, argumentActionName, previousApply, policyForCall, previousExpression.checker)) {
                        isResetByResetArguments = true;
                        break;
                    }
                }
                else if (policyForCall.type === "ResetAllArguments") {
                    resetAllArgumentsSeen = true;
                }
            }
            const previousCallArguments = previousApply.getArguments() || {};
            if (resetAllArgumentsSeen) {
                for (const resetArgumentsActionArgValue of Object.values(previousCallArguments)) {
                    const previousCallArgThing = previousExpression.checker.getThing(resetArgumentsActionArgValue.value);
                    if (!previousCallArgThing) {
                        continue;
                    }
                    resetAllArgumentsArguments.add(previousCallArgThing.token);
                }
            }
            continue;
        }
        if (isResetByResetArguments) {
            return true;
        }
        return resetAllArgumentsArguments.has(argValueThing.token);
    }
}
exports.Flow = Flow;
/**
 * Because of the unfortunate requirement of ACDL to reference an Action by its arguments. E.g. MyAction.arguments.argName
 * The abstract representation of a Function, e.g. `Function1<String, Void>`, does not capture the argument names,
 *
 * This function, `mapInterface`, maps between these interfaces. It is used by {@link Flow} when pushing or popping
 * a stack frame. This is because the expected interface of a caller or calee may be different than the actual value
 * during evaluation.
 *
 * Note: this code will mutate the TypeChecker instance passed into it. This is because we need a TypeChecker instance
 * prior constructing a Thing with a mapped interface. This is unfortuante and quite hacky, but it works for now.
 *
 * @param checker TypeChecker environment of the environment being mapped into into.
 * @param thing value of the Thing to map into the environment
 * @param type type of the Thing required in this environment
 * @returns a Thing with a mapped interface
 */
function mapInterface(checker, thing, type) {
    var _a, _b;
    if (type !== undefined && thing !== undefined) {
        if (thing.isFunction() && type.isFunctionN()) {
            return thing.withArgumentNameMappings(type.getFunctionArgumentDeclarationMappings(thing.type));
        }
        if (thing.isArguments()) {
            return new thing_1.ArgumentsThing(checker, thing.token, thing.type, thing.origin, (_b = mapInterface(checker, thing.parent, (_a = thing.type.genericArguments) === null || _a === void 0 ? void 0 : _a[0])) === null || _b === void 0 ? void 0 : _b.asFunction());
        }
        if (thing.isLiteral()) {
            // Literal Lists and Objects may contain literal Function references that need to be mapped, so we recurse over them.
            if (thing.isObject() && type.isObject()) {
                const props = thing.getProperties();
                if (props) {
                    Object.entries(props).forEach(([propName, propThing]) => {
                        var _a;
                        const arg = thing.apply.getArgument(propName);
                        propThing = (_a = mapInterface(checker, propThing, type.getPropertyType(propName))) !== null && _a !== void 0 ? _a : propThing;
                        if (propThing && arg) {
                            // here, we override the mapping between the arg Node and the Thing value
                            checker.localThingIndex.set(arg, propThing);
                            if (arg.value) {
                                checker.localThingIndex.set(arg.value, propThing);
                            }
                        }
                    });
                }
                return new thing_1.ObjectThing(checker, thing.token, thing.type, new apply_1.Apply(checker, thing.apply.call, thing.apply.decl), thing.origin, thing.parent, thing.loc, thing.uri);
            }
            if (thing.isList()) {
                if (ask.isListLiteral(thing.apply.call.arguments)) {
                    thing.apply.call.arguments.items.forEach((item, i) => {
                        if (item.item) {
                            const itemThing = mapInterface(checker, thing.getItem(i), type.getListItemType());
                            if (itemThing) {
                                // here, we override the mapping between the ListItem Nodes and the Thing value
                                checker.localThingIndex.set(item, itemThing);
                                checker.localThingIndex.set(item.item, itemThing);
                            }
                        }
                    });
                }
                return new thing_1.ListThing(checker, thing.token, thing.type, new apply_1.Apply(checker, thing.apply.call, thing.apply.decl), thing.origin, thing.parent, thing.loc, thing.uri);
            }
        }
    }
    return thing;
}
/**
 * Determines if a Type or Thing contains Function types as properties.
 */
function hasFunctions(thing, seen = immutable_1.default.Set()) {
    if (thing === undefined) {
        return undefined;
    }
    if (thing.kind === "Thing") {
        return hasFunctions(thing.type, seen);
    }
    if (seen.has(thing)) {
        return undefined;
    }
    seen = seen.add(thing);
    if (thing.isFunction()) {
        return true;
    }
    if (thing.isObject()) {
        for (const prop of thing.properties) {
            if (hasFunctions(prop.type, seen)) {
                return true;
            }
        }
    }
    else if (thing.isList()) {
        return hasFunctions(thing.getListItemType(), seen);
    }
    return false;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxvdy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9mbG93LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMERBQWtDO0FBRWxDLDJDQUE2QjtBQUU3Qix1Q0FBa0Q7QUFDbEQsbUNBQXNFO0FBQ3RFLDZDQVlzQjtBQUV0QixtQ0FBOEI7QUFTOUIsTUFBYSxJQUFJO0lBQ2Y7SUFDRTs7T0FFRztJQUNNLE9BQW9CO0lBQzdCOztPQUVHO0lBQ00sVUFBYTtJQUN0Qjs7T0FFRztJQUNNLElBQXNCO0lBQy9COztPQUVHO0lBQ00sS0FBbUM7SUFDNUM7O09BRUc7SUFDTSxTQUFTLG1CQUFTLENBQUMsR0FBRyxFQUEwQjtJQUN6RDs7T0FFRztJQUNNLFFBQVEsbUJBQVMsQ0FBQyxHQUFHLEVBQWtDOzs7OzttQkFwQnZEOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7SUFDUixDQUFDO0lBRUo7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BK0NHO0lBQ0ksU0FBUyxDQUNkLFdBQXlELEVBQ3pELElBQTZCO1FBRTdCLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksRUFBVyxFQUFFO1lBQzNDLE1BQU0sSUFBSSxHQUFHLGFBQWEsRUFBRSxDQUFDO1lBQzdCLElBQUksSUFBSSxLQUFLLFNBQVMsRUFBRTtnQkFDdEIsTUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMvQixJQUFJLE9BQU8sSUFBSSxLQUFLLFVBQVUsRUFBRTtvQkFDOUIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQW9ELEVBQUUsSUFBSSxDQUFDLENBQUM7aUJBQ25GO2dCQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNmO1lBQ0QsZ0dBQWdHO1lBQ2hHLE9BQU8s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