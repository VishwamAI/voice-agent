"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeParameter = exports.isTypeParameter = exports.TypeReference = exports.isTypeReference = exports.TypeProperty = exports.isTypeProperty = exports.TypeDeclaration = exports.isTypeDeclaration = void 0;
const guard_1 = require("./guard");
const tree_1 = require("./tree");
/**
 * Check if an expression is a TypeDeclaration.
 */
exports.isTypeDeclaration = (0, guard_1.guard)("TypeDeclaration");
/**
 * Type Declaration Expression.
 */
class TypeDeclaration extends tree_1.Tree {
    constructor(
    /**
     * Name of the Type.
     */
    name, 
    /**
     * Type properties.
     */
    properties, 
    /**
     * Optional list of type parameters.
     */
    genericArguments, 
    /**
     * Optional list of super types.
     */
    extensions, 
    /**
     * Annotations attached to this Type Declaration.
     */
    annotations, loc) {
        super("TypeDeclaration", loc);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "properties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: properties
        });
        Object.defineProperty(this, "genericArguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: genericArguments
        });
        Object.defineProperty(this, "extensions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: extensions
        });
        Object.defineProperty(this, "annotations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: annotations
        });
        this.setAsParentOn(name);
        this.setAsParentOn(properties);
        this.setAsParentOn(genericArguments);
        this.setAsParentOn(extensions);
        this.setAsParentOn(annotations);
    }
    clone() {
        var _a, _b, _c, _d, _e;
        return new TypeDeclaration((_a = this.name) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.properties) === null || _b === void 0 ? void 0 : _b.map((p) => p.clone()), (_c = this.genericArguments) === null || _c === void 0 ? void 0 : _c.map((a) => a.clone()), (_d = this.extensions) === null || _d === void 0 ? void 0 : _d.map((e) => e.clone()), (_e = this.annotations) === null || _e === void 0 ? void 0 : _e.map((e) => e.clone()), this.loc);
    }
}
exports.TypeDeclaration = TypeDeclaration;
/**
 * Check if an expression is a TypeProperty.
 */
exports.isTypeProperty = (0, guard_1.guard)("TypeProperty");
/**
 * Defines a property in type declaration.
 */
class TypeProperty extends tree_1.Tree {
    constructor(
    /**
     * Name of the property.
     */
    name, 
    /**
     * Type of the property.
     */
    type, 
    /**
     * TODO: can we define this as a union type instead?
     */
    optional, 
    /**
     * Annotations attached to this Type Property.
     */
    annotations, loc) {
        super("TypeProperty", loc);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: type
        });
        Object.defineProperty(this, "optional", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: optional
        });
        Object.defineProperty(this, "annotations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: annotations
        });
        this.setAsParentOn(name);
        this.setAsParentOn(type);
        this.setAsParentOn(annotations);
    }
    clone() {
        var _a, _b, _c;
        return new TypeProperty((_a = this.name) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.type) === null || _b === void 0 ? void 0 : _b.clone(), this.optional, (_c = this.annotations) === null || _c === void 0 ? void 0 : _c.map((a) => a.clone()), this.loc);
    }
}
exports.TypeProperty = TypeProperty;
exports.isTypeReference = (0, guard_1.guard)("TypeReference");
/**
 * Used to define type of variable, return type of an expression, type of event or action declaration.
 * <code> MyType<String> </code>
 * Here MyType is name of type and String is type argument.
 */
class TypeReference extends tree_1.Tree {
    constructor(
    /**
     * Name of the type being referenced.
     */
    name, 
    /**
     * Generic Type arguments to this Type Reference.
     */
    typeArgs, 
    /**
     * Annotations attached to this Type Reference.
     */
    annotations, 
    /**
     * If this TypeReference is using Function syntax, this array contains a mapping of position to argument name.
     * ex.
     * ```
     * foo(String str)
     * ```
     *
     * This is of type `Function1<String, Nothing>`.
     *
     * Its functionArgumentNames are `["str"]`, meaning the `String` type of `arg0` should be mapped to `str`.
     *
     * This data only exists when parsing ACDL syntax.
     *
     * TODO: should we create a separate Expression kind for this? We don't have one in ASKIR.
     */
    functionArgumentNames, loc, 
    /**
     * internal flag to indicate this type reference was inferred and should not have errors placed on it
     */
    inferred) {
        super("TypeReference", loc);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "annotations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: annotations
        });
        Object.defineProperty(this, "functionArgumentNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: functionArgumentNames
        });
        Object.defineProperty(this, "inferred", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: inferred
        });
        /**
         * Generic Type arguments to this Type Reference.
         */
        Object.defineProperty(this, "arguments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.setAsParentOn(name);
        this.setAsParentOn(typeArgs);
        this.setAsParentOn(annotations);
        this.arguments = typeArgs;
    }
    clone() {
        var _a, _b, _c;
        return new TypeReference((_a = this.name) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.arguments) === null || _b === void 0 ? void 0 : _b.map((a) => a === null || a === void 0 ? void 0 : a.clone()), (_c = this.annotations) === null || _c === void 0 ? void 0 : _c.map((a) => a.clone()), this.functionArgumentNames, this.loc, this.inferred);
    }
}
exports.TypeReference = TypeReference;
exports.isTypeParameter = (0, guard_1.guard)("TypeParameter");
/**
 * Generic type parameter.
 */
class TypeParameter extends tree_1.Tree {
    constructor(
    /**
     * Name of the Type Parameter.
     */
    name, 
    /**
     * Optional bound for the Type Parameter.
     */
    constraints, loc) {
        super("TypeParameter", loc);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "constraints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: constraints
        });
        this.setAsParentOn(name);
        this.setAsParentOn(constraints);
    }
    clone() {
        var _a, _b;
        return new TypeParameter((_a = this.name) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.constraints) === null || _b === void 0 ? void 0 : _b.map((c) => c.clone()), this.loc);
    }
}
exports.TypeParameter = TypeParameter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hc3QvdHlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFHQSxtQ0FBOEI7QUFLOUIsaUNBQTRCO0FBSTVCOztHQUVHO0FBQ1UsUUFBQSxpQkFBaUIsR0FBRyxJQUFBLGFBQUssRUFBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBRTFEOztHQUVHO0FBQ0gsTUFBYSxlQUFnQixTQUFRLFdBQStCO0lBQ2xFO0lBQ0U7O09BRUc7SUFDTSxJQUFXO0lBQ3BCOztPQUVHO0lBQ00sVUFBMkI7SUFDcEM7O09BRUc7SUFDTSxnQkFBa0M7SUFDM0M7O09BRUc7SUFDTSxVQUE0QjtJQUNyQzs7T0FFRztJQUNNLFdBQTBCLEVBQ25DLEdBQW9CO1FBRXBCLEtBQUssQ0FBQyxpQkFBaUIsRUFBRSxHQUFHLENBQUMsQ0FBQzs7Ozs7bUJBbkJyQjs7Ozs7O21CQUlBOzs7Ozs7bUJBSUE7Ozs7OzttQkFJQTs7Ozs7O21CQUlBOztRQUlULElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMvQixJQUFJLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMvQixJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFTSxLQUFLOztRQUNWLE9BQU8sSUFBSSxlQUFlLENBQ3hCLE1BQUEsSUFBSSxDQUFDLElBQUksMENBQUUsS0FBSyxFQUFFLEVBQ2xCLE1BQUEsSUFBSSxDQUFDLFVBQVUsMENBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsRUFDdEMsTUFBQSxJQUFJLENBQUMsZ0JBQWdCLDBDQUFFLEdBQUcsQ0FBQyxD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