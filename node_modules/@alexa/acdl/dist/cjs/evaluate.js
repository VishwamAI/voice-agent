"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatePriorResponseCall = exports.evaluateConditionalBranch = exports.validateSampleStartWithInvoke = exports.validateSkillLevelResponses = exports.validateGlobalWelcome = exports.validatePayload = exports.evaluateInvokeApi = exports.validateRequestPromptInArgsList = exports.validatePrompt = exports.validateArgumentListThing = exports.validateArgumentList = exports.evaluateEnsure = exports.validateConfirmArgsFlow = exports.validateConfirmArgsAct = exports.evaluateConfirmArgs = exports.evaluateConfirmAction = exports.validateNextAct = exports.addPendingOfferIfAction = exports.validateResponseAct = exports.evaluateResponse = exports.evaluateExpect = exports.evaluateDialogExpansion = exports.evaluateEnd = exports.evaluateExpression = exports.evaluateFlow = exports.evaluateDialogFlow = void 0;
const ask = __importStar(require("./ast"));
const ast_1 = require("./ast");
const error_1 = require("./error");
const error_factory_1 = require("./error-factory");
/**
 * Validates that the Dialog is deployable. A deployable dialog is one that accepts no arguments and returns `Nothing` or `Void`.
 */
function evaluateDialogFlow(flow, state) {
    // TODO: validate that it does not accept arguments
    var _a, _b;
    return [
        evaluateFlow(flow, state).map((state) => state.errors),
        (_b = (_a = flow.expression.samples) === null || _a === void 0 ? void 0 : _a.map((sample) => (0, exports.validateSampleStartWithInvoke)(flow.step(sample), state))) !== null && _b !== void 0 ? _b : [],
    ].flat(2);
}
exports.evaluateDialogFlow = evaluateDialogFlow;
/**
 * Validates that the data flow is correct.
 *
 * @param node
 * @param flow
 * @returns
 */
function evaluateFlow(flow, state) {
    return flow.interpret(function evaluate(expr, nextState = state) {
        if (expr.isEnd()) {
            return evaluateEnd(expr, nextState.pushExpr(expr));
        }
        nextState = evaluateExpression(expr, nextState).pushExpr(expr);
        if (nextState.isCircular) {
            // detected a circular reference, stop execution.
            return nextState;
        }
        return (next) => evaluate(next, nextState);
    }, undefined);
}
exports.evaluateFlow = evaluateFlow;
function evaluateExpression(expr, state) {
    if (expr.isExpect()) {
        return (0, exports.evaluateExpect)(expr, state);
    }
    if (expr.isResponse()) {
        return (0, exports.evaluateResponse)(expr, state);
    }
    if (expr.isConfirmAction()) {
        return (0, exports.evaluateConfirmAction)(expr, state);
    }
    if (expr.isConfirmArgs()) {
        return (0, exports.evaluateConfirmArgs)(expr, state);
    }
    if (expr.isEnsure()) {
        return (0, exports.evaluateEnsure)(expr, state);
    }
    if (expr.isInvokeApi()) {
        return (0, exports.evaluateInvokeApi)(expr, state);
    }
    if (expr.isConditionalBranch()) {
        return (0, exports.evaluateConditionalBranch)(expr, state);
    }
    if (expr.isDialogExpansion()) {
        return evaluateDialogExpansion(expr, state);
    }
    return state;
}
exports.evaluateExpression = evaluateExpression;
/**
 * Called at the end of a single dialog flow. During evaluation, we often delay validation until
 * the end as an optimization. For example, checking if an argument is requested - if the ensure()
 * block is called later on in the dialog flow, we don't want to be searching forward all the time
 * because searching forward is slow. Instead, we track that in {@link EvaluationState} and then
 * peform the validation here. This reduces the time complexity significantly.
 */
function evaluateEnd(endExpr, state) {
    return state.withError(...validateLastExpressionIsResponse(), ...evaluatePendingRequestPromptValidations());
    function isFlowExpressionResponseCall(flow) {
        var _a, _b, _c;
        return (_c = (((_a = flow === null || flow === void 0 ? void 0 : flow.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call" && ((_b = flow.checker.getApply(flow === null || flow === void 0 ? void 0 : flow.expression)) === null || _b === void 0 ? void 0 : _b.isResponse()))) !== null && _c !== void 0 ? _c : false;
    }
    // Validates the last expression in a sample is either a response call or a return value from a reusable
    // dialog that finishes with a response call.
    function validateLastExpressionIsResponse() {
        var _a, _b;
        // The last flow containing an expression in the dialog sample
        const lastFlow = endExpr.flow.prev;
        if (isFlowExpressionResponseCall(lastFlow)) {
            return [];
        }
        const isLastExprFromDialogCall = isFlowFromDialogCall(lastFlow);
        // Handle when a sample ends with a name reference and not a response call, in which case
        // we need to ensure the name reference is from a reusable dialog call that ends with response call/return value.
        if (((_a = lastFlow === null || lastFlow === void 0 ? void 0 : lastFlow.expression) === null || _a === void 0 ? void 0 : _a.kind) === "NameReference" && isLastExprFromDialogCall) {
            // The flow containing the second to last expression in the dialog sample
            let prevFlow = lastFlow === null || lastFlow === void 0 ? void 0 : lastFlow.prev;
            // Go up the flow stack until we hit the previous expression
            while (((_b = prevFlow === null || prevFlow === void 0 ? void 0 : prevFlow.expression) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                prevFlow = prevFlow === null || prevFlow === void 0 ? void 0 : prevFlow.prev;
            }
            if (isFlowExpressionResponseCall(prevFlow)) {
                return [];
            }
        }
        const errorFactory = isLastExprFromDialogCall
            ? error_factory_1.ValidationErrorFactory.InvalidLastExpressionInSampleFromDialogCall
            : error_factory_1.ValidationErrorFactory.InvalidLastExpressionInSample;
        return [errorFactory({ expr: lastFlow === null || lastFlow === void 0 ? void 0 : lastFlow.expression })];
    }
    /**
     * Under the right conditions produces one error message for each string in paths
     * @param expr API with error
     * @param argument argument that gave origin to the paths
     * @param paths paths where an error should be produced
     * @returns the errors for the paths
     */
    function getPendingRequestValidationError(expr, argument, paths) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
        if (expr.isInvokeApi()) {
            if (argument.argumentName !== undefined) {
                const argValue = (_a = expr.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue(argument);
                return paths.map((path) => {
                    var _a;
                    return error_factory_1.ValidationErrorFactory.MissingRequestPromptForRequiredApiArgument({
                        expr: argValue,
                        attributes: { argumentName: path, actionName: (_a = expr.action) === null || _a === void 0 ? void 0 : _a.actionName },
                    });
                });
            }
            else {
                return [];
            }
        }
        else if (expr.isEnsure() || expr.isConfirmArgs()) {
            const errors = [];
            const requestArgs = expr.isEnsure() ? expr.requestArgs : expr.confirmArgs;
            if (requestArgs !== undefined) {
                const items = requestArgs.getItems();
                if (items !== undefined) {
                    for (let requestArgumentsIndex = 0; requestArgumentsIndex < items.length; requestArgumentsIndex++) {
                        const requestArg = items[requestArgumentsIndex];
                        const args = (_b = requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) === null || _b === void 0 ? void 0 : _b.getArgumentValueThing("arguments");
                        const argsNode = (_c = requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue("arguments");
                        if ((args === null || args === void 0 ? void 0 : args.isLiteral()) && args.isList()) {
                            const argsList = args.getItems();
                            if (argsList !== undefined) {
                                for (let argIndex = 0; argIndex < argsList.length; argIndex++) {
                                    const thisArg = argsList[argIndex];
                                    if (thisArg === argument) {
                                        const requestArgsNode = (_d = expr.apply) === null || _d === void 0 ? void 0 : _d.getArgumentValue(expr.isEnsure() ? "requestArgs" : "confirmArgs");
                                        let loc = expr.loc; // default to the entire `ensure` block
                                        loc = (_e = requestArgsNode === null || requestArgsNode === void 0 ? void 0 : requestArgsNode.loc) !== null && _e !== void 0 ? _e : loc;
                                        if ((requestArgsNode === null || requestArgsNode === void 0 ? void 0 : requestArgsNode.kind) === "Call" && ask.isListLiteral(requestArgsNode.arguments)) {
                                            // in-lined list, `ensure(RequestArguments { .. }, RequestArguments { .. }, ..)`
                                            const requestArgNode = requestArgsNode.arguments.items[requestArgumentsIndex].item;
                                            loc = (_f = requestArgNode === null || requestArgNode === void 0 ? void 0 : requestArgNode.loc) !== null && _f !== void 0 ? _f : loc;
                                            if ((requestArgNode === null || requestArgNode === void 0 ? void 0 : requestArgNode.kind) === "Call") {
                                                // this is the Requestarguments { .. } node, it is still inline so let's try and make the error even more granular
                                                loc = (_g = argsNode === null || argsNode === void 0 ? void 0 : argsNode.loc) !== null && _g !== void 0 ? _g : loc;
                                                if ((argsNode === null || argsNode === void 0 ? void 0 : argsNode.kind) === "Call" && ask.isListLiteral(argsNode.arguments)) {
                                                    loc = (_h = argsNode.arguments.items[argIndex].item) === null || _h === void 0 ? void 0 : _h.loc;
                                                }
                                            }
                                        }
                                        errors.push(...paths.map((path) => {
                                            const errorArgument = {
                                                expr: { loc: loc !== null && loc !== void 0 ? loc : expr.loc, uri: expr.uri },
                                                attributes: {
                                                    argumentName: path,
                                                },
                                            };
                                            return expr.isEnsure()
                                                ? error_factory_1.ValidationErrorFactory.MissingRequestPromptForMultipleArguments(errorArgument)
                                                : error_factory_1.ValidationErrorFactory.MissingRequestPromptForConfirmArgs(errorArgument);
                                        }));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return errors;
        }
        else {
            // do our best to resolve the location of the argument missing the request prompt
            let loc = (_k = (_j = expr.actNode) === null || _j === void 0 ? void 0 : _j.loc) !== null && _k !== void 0 ? _k : expr.loc;
            // options:
            // response(Request { arguments = [ Foo.arguments.arg ] })
            // response(Request { arguments = nameRef })
            // response(nameRef)
            if (((_l = expr.actNode) === null || _l === void 0 ? void 0 : _l.kind) === "Call") {
                const argsNode = (_o = (_m = expr.act) === null || _m === void 0 ? void 0 : _m.apply) === null || _o === void 0 ? void 0 : _o.getArgumentValue("arguments");
                const args = (_s = (_r = (_q = (_p = expr.act) === null || _p === void 0 ? void 0 : _p.apply) === null || _q === void 0 ? void 0 : _q.getArgumentValueThing("arguments")) === null || _r === void 0 ? void 0 : _r.asLiteralList()) === null || _s === void 0 ? void 0 : _s.getItems();
                if (args !== undefined && (argsNode === null || argsNode === void 0 ? void 0 : argsNode.kind) === "Call" && ask.isListLiteral(argsNode.arguments)) {
                    for (const [i, arg] of args.entries()) {
                        if ((arg === null || arg === void 0 ? void 0 : arg.isArgument()) && arg === argument) {
                            loc = (_u = (_t = argsNode.arguments) === null || _t === void 0 ? void 0 : _t.items) === null || _u === void 0 ? void 0 : _u[i].loc;
                            break;
                        }
                    }
                }
            }
            let errorExpr = (0, error_factory_1.getExpressionIfLocField)(expr.actNode, expr);
            if ((_w = (_v = expr.act) === null || _v === void 0 ? void 0 : _v.apply) === null || _w === void 0 ? void 0 : _w.isConfirmArgsAct()) {
                return paths.map((path) => error_factory_1.ValidationErrorFactory.MissingRequestPromptForConfirmArgs({
                    expr: errorExpr,
                    attributes: {
                        argumentName: path,
                    },
                }));
            }
            else if (((_y = (_x = expr.act) === null || _x === void 0 ? void 0 : _x.apply) === null || _y === void 0 ? void 0 : _y.isRequestArguments()) || ((_0 = (_z = expr.act) === null || _z === void 0 ? void 0 : _z.apply) === null || _0 === void 0 ? void 0 : _0.isRequestAct())) {
                return paths.map((path) => error_factory_1.ValidationErrorFactory.MissingRequestPromptForMultipleArguments({
                    expr: errorExpr,
                    attributes: {
                        argumentName: path,
                    },
                }));
            }
            return [];
        }
    }
    function evaluatePendingRequestPromptValidations() {
        const returnValue = [];
        const pendingRequests = Array.from(state.pendingRequestPromptValidation.entries());
        for (const [api, argumentsMap] of pendingRequests) {
            const sortedArgumentsAndPaths = Array.from(argumentsMap.entries())
                .map((argumentAndSet) => ({ argument: argumentAndSet[0], paths: Array.from(argumentAndSet[1]) }))
                .sort((a, b) => a.argument.argumentName.localeCompare(b.argument.argumentName));
            for (const argumentAndPaths of sortedArgumentsAndPaths) {
                returnValue.push(...getPendingRequestValidationError(api, argumentAndPaths.argument, argumentAndPaths.paths));
            }
        }
        return returnValue;
    }
}
exports.evaluateEnd = evaluateEnd;
function evaluateDialogExpansion(expr, state) {
    var _a, _b, _c;
    if (state.hasExpandedDialog(expr)) {
        const apply = expr.apply;
        for (const node of expr.flow.stack) {
            if (node.kind === "Call") {
                const prevApply = expr.flow.checker.getApply(node);
                if (apply.getName() === (prevApply === null || prevApply === void 0 ? void 0 : prevApply.getName())) {
                    const validationErrorExpr = (0, error_factory_1.getExpressionIfLocField)((_a = apply.call) === null || _a === void 0 ? void 0 : _a.name, apply.call);
                    return state.withCircular(true).withError(apply.decl.kind === "DialogDeclaration"
                        ? error_factory_1.ValidationErrorFactory.CircularReferenceDialog({
                            expr: validationErrorExpr,
                            attributes: {
                                dialogName: (_b = apply.decl.name) === null || _b === void 0 ? void 0 : _b.name,
                            },
                        })
                        : error_factory_1.ValidationErrorFactory.CircularReferenceName({
                            expr: validationErrorExpr,
                            attributes: {
                                name: (_c = apply.decl.name) === null || _c === void 0 ? void 0 : _c.name,
                            },
                        }), ...collectCallStackErrors(expr.flow));
                }
            }
        }
    }
    return state;
}
exports.evaluateDialogExpansion = evaluateDialogExpansion;
function collectCallStackErrors(flow) {
    var _a, _b;
    if ((flow === null || flow === void 0 ? void 0 : flow.expression) === undefined) {
        return [];
    }
    if (flow.expression.kind === "Call") {
        const apply = flow.checker.getApply(flow.expression);
        if (apply === null || apply === void 0 ? void 0 : apply.isDialog()) {
            return [
                error_factory_1.ValidationErrorFactory.CircularReferenceDialog({
                    expr: (0, error_factory_1.getExpressionIfLocField)((_a = apply.call) === null || _a === void 0 ? void 0 : _a.name, apply.call),
                    attributes: {
                        dialogName: (_b = apply.decl.name) === null || _b === void 0 ? void 0 : _b.name,
                    },
                }),
                ...flow.visitPrevious(collectCallStackErrors),
            ];
        }
    }
    return flow.visitPrevious(collectCallStackErrors);
}
/**
 * Validate the prior lines to expect.
 *
 * 1. `Invoke` must be first event or follow response with `Request`, `Notify`, `Offer`, `ReqMore`, or `ReqAlt` Acts. TODO: we must verify if it is valid to follow `Request` - our tests used this case but it is documented as invalid.
 * 2. `Affirm` or `Deny` must follow response with `ConfirmArgs`, `ConfirmAction`, `Offer` Acts or `confirmAction`.
 * 3. `Inform` must follow response with `Request` or `ReqAlt` Acts.
 *
 * @param expect expect being evaluated
 * @param expectActType expect's actType
 * @param expectActValue expect's act argument value from expect.apply?.getArgumentValue("act")
 * @param stateExpressionStack expression stack from the state
 * @returns errors from lines prior tp expect
 */
function validateEventPriorToExpect(expect, expectActType, expectActValue, stateExpressionStack) {
    var _a, _b;
    for (const expr of stateExpressionStack) {
        if (expr.isInvokeApi() || expr.isExpect()) {
            const errorArguments = {
                expr: expectActValue,
                attributes: {
                    requestAct: expectActType.toString(expectActValue),
                },
            };
            if (expectActType.isInvoke()) {
                // TODO: verify if Invoke can follow 'Request' act.
                return [error_factory_1.ValidationErrorFactory.InvalidEventInvoke(errorArguments)];
            }
            if (expectActType.isAffirm() || expectActType.isDeny()) {
                return [error_factory_1.ValidationErrorFactory.InvalidEventAffirmOrDeny(errorArguments)];
            }
            if (expectActType.isInform()) {
                return [error_factory_1.ValidationErrorFactory.InvalidEventInform(errorArguments)];
            }
            // catch all, we should never reach here since we first validate that actType is Invoke, Inform, Affirm or Deny
            return [error_factory_1.ValidationErrorFactory.InvalidEvent(errorArguments)];
        }
        if (expr.isEnsure() || expr.isDialogExpansion() || expr.isConfirmArgs() || expr.isBlock() || expr.isConditionalBranch()) {
            // ignore these calls since they do not affect the user/alexa lines.
            // TODO: why ignore ConfirmArgs?
            // return [];
        }
        else if (expr.isConfirmAction()) {
            if (expectActType.isAffirm() || expectActType.isDeny()) {
                return [];
            }
            return [
                error_factory_1.ValidationErrorFactory.InvalidEventFollowingConfirmAction({
                    expr: expectActValue,
                    attributes: {
                        requestAct: expectActType.toString(expect.node),
                    },
                }),
            ];
        }
        else if (expr.isResponse()) {
            const nextRequestActType = (_a = expr.nextAct) === null || _a === void 0 ? void 0 : _a.type;
            let requestActType = (_b = expr.act) === null || _b === void 0 ? void 0 : _b.type;
            if (nextRequestActType && !(nextRequestActType.isNothing() || nextRequestActType.isVoid())) {
                requestActType = nextRequestActType;
            }
            if (requestActType === undefined) {
                // could not resolve the request act, so ignore these validations
                return [];
            }
            if (requestActType.isOffer()) {
                // all dialog acts can follow Offer
                return [];
            }
            if (requestActType.isConfirmArgs() || requestActType.isConfirmAction()) {
                if (expectActType.isAffirm() || expectActType.isDeny()) {
                    return [];
                }
                return [invalidEventError("Affirm", "Deny")];
            }
            if (requestActType.isNotify() || requestActType.isReqMore() || requestActType.isBye()) {
                if (expectActType.isInvoke()) {
                    return [];
                }
                return [invalidEventError("Invoke")];
            }
            if (requestActType.isReqAlt()) {
                if (expectActType.isInvoke() || expectActType.isInform()) {
                    return [];
                }
                return [invalidEventError("Invoke", "Inform")];
            }
            if (requestActType.isRequest()) {
                if (expectActType.isInform()) {
                    return [];
                }
                return [invalidEventError("Inform")];
            }
            function invalidEventError(...expected) {
                const suggestions = expected.length === 1
                    ? `'${expected[0]}'`
                    : `${expected
                        .slice(0, expected.length - 1)
                        .map((e) => `'${e}'`)
                        .join(", ")} or '${expected[expected.length - 1]}'`;
                return error_factory_1.ValidationErrorFactory.InvalidEventResponse({
                    expr: (0, error_factory_1.getExpressionIfLocField)(expectActValue, expect),
                    attributes: {
                        responseAct: expectActType.toString(expect.node),
                        requestAct: requestActType === null || requestActType === void 0 ? void 0 : requestActType.toString(expect.node),
                        suggestions,
                    },
                });
            }
        }
    }
    if (expectActType.isInvoke()) {
        return [];
    }
    return [
        error_factory_1.ValidationErrorFactory.InvalidFirstEvent({
            expr: expectActValue,
            attributes: {
                dialogAct: expectActType.toString(expect.node),
            },
        }),
    ];
}
/**
 * Called to peerform Inform validations if the expect's act is inform
 * @param expect expect being evaluated
 * @returns errors for expect with Inform act
 */
function validateExpectInform(expect) {
    var _a, _b, _c;
    const errors = [];
    // Each sample sentence in "inform" event should contain at least one slot.
    const eventValue = (_a = expect.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("event");
    if (!expect.checker.isNameReference(eventValue)) {
        // this case should already be caught by other validation
        return errors;
    }
    const nameDecl = expect.checker.resolveNameReference(eventValue);
    if (ask.isCall(nameDecl)) {
        const apply = expect.checker.getApply(nameDecl);
        if ((apply === null || apply === void 0 ? void 0 : apply.getName()) === ast_1.AlexaConversations.utterances) {
            let items = [];
            const value = apply.getArgumentValue("samples");
            if (expect.checker.isNameReference(value)) {
                const found = expect.checker.resolveNameReference(value);
                const foundType = expect.checker.getType(value);
                if (ask.isCall(found) && ask.isListLiteral(found.arguments) && (foundType === null || foundType === void 0 ? void 0 : foundType.isList())) {
                    items = found.arguments.items;
                }
            }
            else if ((value === null || value === void 0 ? void 0 : value.kind) === "Call" && ask.isListLiteral(value.arguments)) {
                items = value.arguments.items;
            }
            for (const item of items) {
                if (item.item === undefined || item.item.kind !== "Call") {
                    // do nothing, because this case should already be caught by other validation
                }
                else if (typeof item.item.arguments === "string" ||
                    (ask.isUtterance(item.item.arguments) && ((_b = item.item.arguments.names) === null || _b === void 0 ? void 0 : _b.length) === 0)) {
                    errors.push(error_factory_1.ValidationErrorFactory.InformUtteranceSampleMissingSlot({
                        expr: (0, error_factory_1.getExpressionIfLocField)((_c = expect.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue("event"), expect),
                    }));
                    // only report this error once
                    break;
                }
            }
        }
    }
    return errors;
}
const evaluateExpect = (expect, state) => {
    var _a, _b, _c, _d, _e, _f;
    // for expect action, the RequestAct could only be Invoke, Inform, Affirm or Deny
    const value = (_a = expect.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("act");
    const actType = expect.getActType();
    if (actType === undefined) {
        // don't do anything when type is undefined as it should be caught by another validator
        return state;
    }
    if (!expect.isInvoke() && !expect.isInform() && !expect.isAffirm() && !expect.isDeny()) {
        return state.withError(error_factory_1.ValidationErrorFactory.InvalidRequestAct({
            expr: value,
            attributes: { actName: actType === null || actType === void 0 ? void 0 : actType.toString(value) },
        }));
    }
    if ((actType.isAffirm() || actType.isDeny()) && ((_c = (_b = expect.event) === null || _b === void 0 ? void 0 : _b.apply) === null || _c === void 0 ? void 0 : _c.isUtterances())) {
        const utteranceType = (_f = (_e = (_d = expect.event) === null || _d === void 0 ? void 0 : _d.apply) === null || _e === void 0 ? void 0 : _e.getReturnType()) === null || _f === void 0 ? void 0 : _f.getUtteranceEventType();
        if (!(utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.isNothing()) && !(utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.isThing())) {
            return state.withError(error_factory_1.ValidationErrorFactory.ExpectedEmptyRequestActType({
                expr: value,
                attributes: { typeName: utteranceType === null || utteranceType === void 0 ? void 0 : utteranceType.shortName, actType: actType === null || actType === void 0 ? void 0 : actType.toString(value) },
            }));
        }
        if (actType.isDeny()) {
            // resets pending offer if action is not affirmed
            state = state.clearPendingOffer();
        }
    }
    if (actType.isInform()) {
        return state.withError(...validateEventPriorToExpect(expect, actType, value, state.expressionStack), ...validateExpectInform(expect));
    }
    return state.withError(...validateEventPriorToExpect(expect, actType, value, state.expressionStack));
};
exports.evaluateExpect = evaluateExpect;
/**
 * Validate Response action used in dialog sample
 * including specific validations to the four args (Response, ResponseAct, next ResponseAct, Payload)
 * and make sure those args are used in allowed combination
 */
const evaluateResponse = (response, state) => (0, exports.validateResponseAct)(response, state.withRequestedArguments(false, ...response.getIndividuallyRequestedArguments())).withError(
// 2. validations for the nextAct
...(0, exports.validateNextAct)(response, state), 
// 3. validations for the payload
...(0, exports.validatePayload)(response, state), 
// 4. validations for the prompt
...(0, exports.validatePrompt)(response.apply), ...(0, exports.validatePriorResponseCall)(response));
exports.evaluateResponse = evaluateResponse;
/**
 * Validate the act used in response action
 * 1. The act could only be one of valid ResponseAct: 'Request', 'ConfirmArgs', 'ConfirmAction', 'Notify', 'Offer', 'ReqAlt', 'Bye', 'ReqMore'
 * 2. ReqAlt cannot be the first act
 * 3. for ConfirmArgs, make sure the items in the "arguments" list should be from the same Action
 * 4. for ConfirmArgs, make sure the payload property exist in argument list
 */
const validateResponseAct = (response, state) => {
    var _a, _b;
    const { act } = response;
    const actNode = response.apply.getArgumentValue("act");
    if (act === undefined || !act.isLiteral()) {
        // don't do anything when actType is undefined as it should be caught by another validator
        return state;
    }
    // 1. The act could only be one of valid ResponseAct
    if (!act.type.isResponseAct()) {
        state = state.withError(error_factory_1.ValidationErrorFactory.InvalidDialogActArgument({
            expr: actNode,
            attributes: {
                dialogAct: act.type.toString(actNode),
            },
        }));
    }
    if (act.type.isConfirmAction()) {
        state = (0, exports.evaluateConfirmAction)(response, state);
    }
    // 2. ReqAlt cannot be the first act
    if (act.type.isReqAlt()) {
        state = state.withError(error_factory_1.ValidationErrorFactory.InvalidReqAltFirstAct({
            expr: actNode,
        }));
    }
    // 3. for ConfirmArgs, make sure the items in the "arguments" list should be from the same Action
    if (act.isObject() && act.type.isConfirmArgs()) {
        const preErrorCount = state.errors.length;
        state = (0, exports.validateConfirmArgsAct)(response, state);
        // 4. for ConfirmArgs, make sure the payload property exist in argument list
        if (preErrorCount === state.errors.length) {
            if (act.isObject()) {
                const args = act.getProperty("arguments");
                const nameSet = new Set();
                if ((args === null || args === void 0 ? void 0 : args.isList()) && args.isLiteral()) {
                    args.apply.call.arguments.items.forEach((item) => {
                        var _a, _b, _c, _d, _e;
                        if (response.checker.isNameReference(item.item)) {
                            const nameDecl = response.checker.resolveNameReference(item.item);
                            if ((nameDecl === null || nameDecl === void 0 ? void 0 : nameDecl.kind) !== undefined && nameDecl.kind === "PropertyReference" && ((_a = nameDecl.name) === null || _a === void 0 ? void 0 : _a.name) !== undefined) {
                                nameSet.add(nameDecl.name.name);
                            }
                        }
                        else if (((_b = item.item) === null || _b === void 0 ? void 0 : _b.kind) === "PropertyReference") {
                            if (((_d = (_c = item.item) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name) !== undefined) {
                                nameSet.add((_e = item.item) === null || _e === void 0 ? void 0 : _e.name.name);
                            }
                        }
                    });
                }
                const payloadValue = response.apply.getPayloadValue();
                if ((payloadValue === null || payloadValue === void 0 ? void 0 : payloadValue.kind) === "Call") {
                    const payloadApply = response.checker.getApply(payloadValue);
                    if (payloadApply !== undefined && payloadApply.call.arguments !== undefined && Array.isArray(payloadApply.call.arguments)) {
                        for (const args of payloadApply.call.arguments) {
                            const name = typeof args.name === "string" ? args.name : (_a = args.name) === null || _a === void 0 ? void 0 : _a.name;
                            if (name !== undefined) {
                                if (!nameSet.has(name)) {
                                    state = state.withError(error_factory_1.ValidationErrorFactory.MismatchedConfirmArgsPayloadProperty({
                                        expr: payloadValue,
                                        attributes: {
                                            propertyName: name,
                                        },
                                    }));
                                }
                                else {
                                    nameSet.delete(name);
                                }
                            }
                        }
                        if (nameSet.size > 0) {
                            for (const name of nameSet) {
                                state = state.withError(error_factory_1.ValidationErrorFactory.MissingConfirmedArgsInPayload({
                                    expr: payloadValue,
                                    attributes: {
                                        argumentName: name,
                                    },
                                }));
                            }
                        }
                    }
                }
            }
        }
    }
    // 4. OfferAct arguments should belong to the Offered actionName
    if (act.isObject() && act.type.isOffer()) {
        const offerActionName = act.getProperty("actionName");
        const offerArguments = act.getProperty("arguments");
        const offerArgumentsNode = act.apply.getArgumentValue("arguments");
        if (offerArguments === undefined || offerActionName === undefined || !offerActionName.isAction()) {
            if (offerActionName) {
                return (0, exports.addPendingOfferIfAction)(act, state);
            }
            return state; // should not happen as actionName for Offer act is required
        }
        // return errors; // should not happen as the arguments for Offer act must be a List Call
        if (offerArguments.isList() && offerArguments.isLiteral()) {
            offerArguments.apply.call.arguments.items.forEach((arg, i) => {
                var _a, _b, _c, _d, _e;
                const argItem = response.checker.isNameReference(arg.item)
                    ? response.checker.resolveNameReference(arg.item)
                    : arg.item;
                if (!ask.isPropRef(argItem)) {
                    return; // TODO: check if "Call" can be assigned to argument(s)
                }
                // determine the precise location for this error
                let expr = response;
                if ((actNode === null || actNode === void 0 ? void 0 : actNode.kind) === "Call") {
                    expr = (0, error_factory_1.getExpressionIfLocField)(actNode, expr);
                    if ((offerArgumentsNode === null || offerArgumentsNode === void 0 ? void 0 : offerArgumentsNode.kind) === "Call") {
                        expr = (0, error_factory_1.getExpressionIfLocField)(offerArgumentsNode, expr);
                        if (ask.isListLiteral(offerArgumentsNode.arguments)) {
                            expr = (0, error_factory_1.getExpressionIfLocField)((_b = (_a = offerArgumentsNode.arguments) === null || _a === void 0 ? void 0 : _a.items[i]) === null || _b === void 0 ? void 0 : _b.item, expr);
                        }
                    }
                }
                const argValueStr = argItem.printPropertyChainThroughRoot();
                const argThing = response.checker.getThing(arg);
                if (((_d = (_c = argThing === null || argThing === void 0 ? void 0 : argThing.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.isAction()) && !argThing.parent.parent.equals(offerActionName)) {
                    state = state.withError(error_factory_1.ValidationErrorFactory.MismatchedActionArgumentsListValue({
                        expr,
                        attributes: {
                            argumentValue: argValueStr,
                            actionName: (_e = offerActionName.origin.name) === null || _e === void 0 ? void 0 : _e.name,
                        },
                    }));
                }
            });
        }
        // Offer.carryOverArguments
        const offerCarryoverArguments = act.getProperty("carryOverArguments");
        const offerCarryoverArgumentsNode = act.apply.getArgumentValue("carryOverArguments");
        if (offerCarryoverArguments === undefined || !offerCarryoverArguments.isList() || !offerCarryoverArguments.isLiteral()) {
            return state; // should not happen as the arguments for Offer act must be a List Call
        }
        (_b = offerCarryoverArguments.getItems()) === null || _b === void 0 ? void 0 : _b.forEach((carryOverArgument, i) => {
            var _a, _b, _c, _d, _e, _f;
            if ((carryOverArgument === null || carryOverArgument === void 0 ? void 0 : carryOverArgument.isObject()) && carryOverArgument.isLiteral()) {
                const arg = carryOverArgument.getProperty("argument");
                if ((arg === null || arg === void 0 ? void 0 : arg.type.isArgument()) && ((_b = (_a = arg.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.isAction())) {
                    if (!arg.parent.parent.equals(offerActionName)) {
                        const carryOverValueStr = ask.isPropRef((_c = arg.origin) === null || _c === void 0 ? void 0 : _c.context) ? arg.origin.context.printPropertyChainThroughRoot() : "todo";
                        // determine the most precise location for the argument's error.
                        // TODO: this is gross, refactor it
                        let expr = response;
                        if ((actNode === null || actNode === void 0 ? void 0 : actNode.kind) === "Call") {
                            expr = (0, error_factory_1.getExpressionIfLocField)(actNode, expr);
                            if ((offerCarryoverArgumentsNode === null || offerCarryoverArgumentsNode === void 0 ? void 0 : offerCarryoverArgumentsNode.kind) === "Call") {
                                expr = (0, error_factory_1.getExpressionIfLocField)(offerCarryoverArgumentsNode, expr);
                                if (ask.isListLiteral(offerCarryoverArgumentsNode.arguments)) {
                                    const carryOverArgNode = (_e = (_d = offerCarryoverArgumentsNode.arguments) === null || _d === void 0 ? void 0 : _d.items[i]) === null || _e === void 0 ? void 0 : _e.item;
                                    if (carryOverArgNode !== undefined) {
                                        expr = (0, error_factory_1.getExpressionIfLocField)(carryOverArgNode, expr);
                                        if (carryOverArgNode.kind === "Call") {
                                            expr = (0, error_factory_1.getExpressionIfLocField)(carryOverArgument.apply.getArgumentValue("argument"), expr);
                                        }
                                    }
                                }
                            }
                        }
                        state = state.withError(error_factory_1.ValidationErrorFactory.MismatchedActionCarryOverArguments({
                            expr,
                            attributes: {
                                carryOverValue: carryOverValueStr,
                                actionName: (_f = offerActionName.origin.name) === null || _f === void 0 ? void 0 : _f.name,
                            },
                        }));
                    }
                }
            }
        });
        return state;
    }
    // 5. validate ConfirmAction Act
    // if (act.type.isConfirmAction()) {
    //   errors.push(...validateConfirmAction(apply, checker));
    // }
    // 6. validate Request Act
    if (act.type.isRequest()) {
        const args = act.getProperty("arguments");
        if ((args === null || args === void 0 ? void 0 : args.isList()) && args.isLiteral()) {
            state = state.withError(...validateArgumentList(act.apply.getArgumentValue("arguments"), act.getProperty("arguments")));
        }
        // If the argList contains multiple args, make sure each arg has request prompt
        state = (0, exports.validateRequestPromptInArgsList)(response, act, state);
    }
    // 7. For Notify Act, it can only use the last API action name and an API call can only be notified once
    if (act.type.isNotify() && act.isObject() && act.isLiteral()) {
        // const actValueApply = act.apply;
        const actionDecl = act.getProperty("actionName");
        if (actionDecl === null || actionDecl === void 0 ? void 0 : actionDecl.isAction()) {
            const validateNotify = (expr) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j;
                if (expr === undefined) {
                    return [
                        error_factory_1.ValidationErrorFactory.InvalidNotifyActionNameUnusedAction({
                            expr: response,
                            attributes: {
                                actionName: (_a = actionDecl.name) === null || _a === void 0 ? void 0 : _a.name,
                            },
                        }),
                    ];
                }
                if (expr.isInvokeApi()) {
                    const actionName = (_b = expr.action) === null || _b === void 0 ? void 0 : _b.actionName;
                    if (actionName && actionName !== ((_c = actionDecl.name) === null || _c === void 0 ? void 0 : _c.name)) {
                        return [
                            error_factory_1.ValidationErrorFactory.InvalidNotifyActionNameLastAction({
                                expr: (0, error_factory_1.getExpressionIfLocField)((actNode === null || actNode === void 0 ? void 0 : actNode.kind) === "Call" ? (_e = (_d = response.apply.getArgumentValueThing("act")) === null || _d === void 0 ? void 0 : _d.apply) === null || _e === void 0 ? void 0 : _e.getArgumentValue("actionName") : actNode, response),
                                attributes: {
                                    currentActionName: (_f = actionDecl.name) === null || _f === void 0 ? void 0 : _f.name,
                                    previousActionName: actionName,
                                },
                            }),
                        ];
                    }
                    return [];
                }
                if (expr.isResponse()) {
                    const actionName = (_g = actionDecl.name) === null || _g === void 0 ? void 0 : _g.name;
                    const { act } = expr;
                    if ((act === null || act === void 0 ? void 0 : act.type.isNotify()) && act.isObject() && act.isLiteral()) {
                        const actionNameProp = act.getProperty("actionName");
                        if ((actionNameProp === null || actionNameProp === void 0 ? void 0 : actionNameProp.isAction()) && actionName === ((_h = actionNameProp.origin.name) === null || _h === void 0 ? void 0 : _h.name)) {
                            return [
                                error_factory_1.ValidationErrorFactory.InvalidNotifyActionNameAlreadyNotified({
                                    expr: response,
                                    attributes: {
                                        actionName: (_j = actionDecl.name) === null || _j === void 0 ? void 0 : _j.name,
                                    },
                                }),
                            ];
                        }
                    }
                }
                return validateNotify(expr.prev);
            };
            state = (0, exports.addPendingOfferIfAction)(response.nextAct, state.withError(...validateNotify(response.prev)));
        }
    }
    return state;
};
exports.validateResponseAct = validateResponseAct;
/**
 * Modifies pending offer state if actionName is provided in Offer
 */
const addPendingOfferIfAction = (act, state) => {
    var _a, _b, _c, _d;
    if (act === null || act === void 0 ? void 0 : act.type.isOffer()) {
        const action = (_a = act.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValueThing("actionName");
        if (((_b = action === null || action === void 0 ? void 0 : action.origin) === null || _b === void 0 ? void 0 : _b.kind) === "ActionDeclaration" && ((_d = (_c = action === null || action === void 0 ? void 0 : action.origin) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.name)) {
            return state.withPendingOffer(action.origin.name.name);
        }
    }
    return state;
};
exports.addPendingOfferIfAction = addPendingOfferIfAction;
/**
 * Validate nextAct used in response action
 * 1. next Act could only be Offer, ReqMore, ReqAlt, or Bye.
 * 2. nextAct could only follow Notify act
 * 3. the ReqAlt act can only be the next Act to a Notify Act with "success = false"
 * 4. for ReqAlt, the items in the "arguments" list should be from the same Action
 * 5. for ReqAlt, actionName used in Notify and ReqAlt argument list should be consistent
 */
const validateNextAct = (response, state) => {
    var _a, _b, _c, _d, _e, _f;
    const errors = [];
    const { act } = response;
    const actArg = response.apply.getArgumentValue("act");
    const actionName = act === null || act === void 0 ? void 0 : act.getProperty("actionName");
    const actType = act === null || act === void 0 ? void 0 : act.type;
    if (actArg === undefined || act === undefined || actType === undefined || !act.isLiteral()) {
        // don't do anything when actType is undefined as it should be caught by another validator
        return [];
    }
    const { nextAct } = response;
    const nextActArg = response.apply.getArgument("nextAct");
    const nextActType = nextAct === null || nextAct === void 0 ? void 0 : nextAct.type;
    if (nextActArg === undefined || nextAct === undefined || nextActType === undefined || nextActType.isNothing() || nextActType.isVoid()) {
        // don't do anything when type is undefined as it is an optional argument
    }
    else if (!nextActType.isOffer() && !nextActType.isBye() && !nextActType.isReqAlt() && !nextActType.isReqMore()) {
        // 1. next Act could only be Offer, ReqMore, ReqAlt, or Bye.
        errors.push(error_factory_1.ValidationErrorFactory.InvalidNextAct({
            expr: nextActArg,
            attributes: {
                responseAct: nextActType.toString(nextActArg),
            },
        }));
    }
    else {
        // 2. nextAct could only follow Notify act
        if (!actType.isNotify()) {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidNextActNotify({
                expr: actArg,
                attributes: {
                    responseAct: actType.toString(actArg),
                },
            }));
        }
        else {
            // validations for ReqAlt act
            if (nextAct.type.isReqAlt()) {
                const successValue = act.getProperty("success");
                if (successValue === undefined || !successValue.isBoolean()) {
                    // should be caught by other validation
                    return errors;
                }
                if (successValue.literal === true) {
                    // 3. The ReqAlt act can only be the next Act to a Notify Act with "success = false"
                    errors.push(error_factory_1.ValidationErrorFactory.InvalidReqAltNextAct({
                        expr: nextActArg,
                    }));
                }
                if (nextAct.isObject() && nextAct.isLiteral()) {
                    const reqAlt = nextAct.getProperty("arguments");
                    const reqAltNode = nextAct.apply.getArgumentValue("arguments");
                    if ((reqAlt === null || reqAlt === void 0 ? void 0 : reqAlt.isList()) && reqAlt.isLiteral()) {
                        const argumentListErrors = validateArgumentList(reqAltNode, reqAlt);
                        if (argumentListErrors.length > 0) {
                            errors.push(...argumentListErrors);
                        }
                        else {
                            // 5. actionName used in Notify and ReqAlt argument list should be consistent
                            // could rely on the first item to retrieve rootExpr cause we already checked the items in the list are from the same Action
                            const item = reqAlt.getItem(0);
                            if (((_b = (_a = item === null || item === void 0 ? void 0 : item.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.isAction()) && (actionName === null || actionName === void 0 ? void 0 : actionName.isAction())) {
                                if (((_c = item.parent.parent.origin.name) === null || _c === void 0 ? void 0 : _c.name) !== ((_d = actionName.origin.name) === null || _d === void 0 ? void 0 : _d.name)) {
                                    errors.push(error_factory_1.ValidationErrorFactory.MismatchedArgsInReqAlt({
                                        expr: reqAltNode,
                                        attributes: {
                                            reqAltActionName: (_e = item.parent.parent.origin.name) === null || _e === void 0 ? void 0 : _e.name,
                                            notifyActionName: (_f = actionName.origin.name) === null || _f === void 0 ? void 0 : _f.name,
                                        },
                                    }));
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return errors;
};
exports.validateNextAct = validateNextAct;
/**
 * Validate confirmAction action used in dialog sample
 */
const evaluateConfirmAction = (confirm, state) => {
    var _a, _b, _c, _d, _e;
    let action;
    // location of the ConfirmAction act on which we will attach errors.
    let errorExpr;
    // let actionNameLoc: ask.SourceLocation | undefined;
    if (confirm.isResponse()) {
        if (!((_a = confirm.act) === null || _a === void 0 ? void 0 : _a.type.isConfirmAction())) {
            // why?
            return state;
        }
        const actionName = confirm.act.getProperty("actionName");
        if (actionName === null || actionName === void 0 ? void 0 : actionName.isAction()) {
            action = actionName;
            errorExpr =
                ((_b = confirm.actNode) === null || _b === void 0 ? void 0 : _b.kind) === "Call"
                    ? (0, error_factory_1.getExpressionIfLocField)((_c = confirm.act.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue("actionName"), confirm.actNode, confirm)
                    : (0, error_factory_1.getExpressionIfLocField)(confirm.actNode, confirm);
        }
        else {
            return state;
        }
    }
    else if (confirm.isConfirmAction()) {
        action = confirm.actionName;
        errorExpr = (0, error_factory_1.getExpressionIfLocField)((_d = confirm.actionNameNode) === null || _d === void 0 ? void 0 : _d.value, confirm);
    }
    const confirmedPayload = confirm.payload;
    if (action === undefined) {
        return state;
    }
    if (!action.isAction()) {
        return state;
    }
    const actionName = (_e = action.origin.name) === null || _e === void 0 ? void 0 : _e.name;
    return state.withError(...[
        (0, exports.validatePayload)(confirm, state),
        confirm.flow.interpret((expr) => interpret(expr, state), confirm).map((state) => state.errors),
    ].flat(2));
    function interpret(expr, state, foundEvent = false) {
        var _a;
        const errorArguments = {
            expr: errorExpr,
            attributes: {
                actionName,
            },
        };
        const missingApiInvocationError = error_factory_1.ValidationErrorFactory.MissingApiInvocationAfterConfirmAction(errorArguments);
        const missingAffirmOrDenyError = error_factory_1.ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmAction(errorArguments);
        if (expr.isEnd()) {
            return state.withError(missingApiInvocationError);
        }
        if (expr.isInvokeApi()) {
            if ((_a = expr.action) === null || _a === void 0 ? void 0 : _a.equals(action)) {
                if (!foundEvent) {
                    return state.withError(missingAffirmOrDenyError);
                }
                if (confirmedPayload) {
                    return validateConfirmPayload(state, confirm, expr);
                }
                return state;
            }
        }
        else if (expr.isResponse() || expr.isConfirmAction()) {
            return foundEvent ? state.withError(missingApiInvocationError) : state.withError(missingAffirmOrDenyError, missingApiInvocationError);
        }
        else if (expr.isExpect()) {
            const type = expr.getActType();
            if (type !== undefined) {
                if (type.isAffirm() || (type === null || type === void 0 ? void 0 : type.isDeny())) {
                    if (type.isDeny()) {
                        // it's ok for an api call to not proceed a deny.
                        return state;
                    }
                    return (next) => interpret(next, state.pushExpr(expr), true);
                }
                return state.withError(missingAffirmOrDenyError);
            }
        }
        return (next) => interpret(next, state.pushExpr(expr), foundEvent);
    }
};
exports.evaluateConfirmAction = evaluateConfirmAction;
/**
 * Validate confirmArgs action used in dialog sample
 * traverse the confirmArgs list and do the following validations
 * 1. Make sure each response contain APL-A
 * 2. Make sure all arguments in the argument list refer to the same action
 * 3. Make sure all arguments in the argument list has request prompt
 */
const evaluateConfirmArgs = (confirm, state) => {
    var _a, _b;
    if (confirm.node === undefined) {
        return state;
    }
    const errors = [];
    // const confirmArgs = act.getArgumentValueThing("confirmArgs");
    if (((_a = confirm.confirmArgs) === null || _a === void 0 ? void 0 : _a.isList()) && confirm.confirmArgs.isLiteral()) {
        if (confirm.isResponse())
            errors.push(...(0, exports.validateConfirmArgsFlow)(confirm, state));
        for (const arg of (_b = confirm.confirmArgs.getItems()) !== null && _b !== void 0 ? _b : []) {
            if ((arg === null || arg === void 0 ? void 0 : arg.type.isConfirmArguments()) && arg.isObject() && arg.isLiteral()) {
                errors.push(...(0, exports.validatePrompt)(arg.apply));
                const confirmedArgs = arg.getProperty("arguments");
                const confirmedArgsNode = arg.apply.getArgumentValue("arguments");
                if ((confirmedArgs === null || confirmedArgs === void 0 ? void 0 : confirmedArgs.isList()) && (confirmedArgs === null || confirmedArgs === void 0 ? void 0 : confirmedArgs.isLiteral())) {
                    // the items in the "arguments" list should be from the same Action
                    errors.push(...validateArgumentList(confirmedArgsNode, confirmedArgs));
                    // Make sure all arguments in the argument list has request prompt
                    state = (0, exports.validateRequestPromptInArgsList)(confirm, arg, state);
                }
            }
        }
    }
    return state.withError(...errors);
};
exports.evaluateConfirmArgs = evaluateConfirmArgs;
/**
 * Validate the ConfirmArgs act used in response action
 * 1. make sure the items in the "arguments" list should be from the same Action
 * 2. make sure all arguments in the argument list has request prompt
 * 3. make sure there exist Affirm or Deny event after ConfirmArgs Act
 * 4. make sure the next api call is consistent with the action whose arguments are been confirmed
 * @param response
 * @param confirmArgsAct
 * @param branch
 */
const validateConfirmArgsAct = (confirm, state) => {
    var _a, _b;
    const errors = [];
    const args = (_a = confirm.act) === null || _a === void 0 ? void 0 : _a.getProperty("arguments");
    const argsNode = (_b = confirm.apply) === null || _b === void 0 ? void 0 : _b.getArgumentValue("act");
    if ((args === null || args === void 0 ? void 0 : args.isList()) && args.isLiteral()) {
        const argumentListErrors = validateArgumentList(argsNode, args);
        errors.push(...argumentListErrors);
        // when all arguments in the list are from the same action
        // make sure the next api call is consistent with the action whose arguments are been confirmed
        if (argumentListErrors.length === 0) {
            errors.push(...(0, exports.validateConfirmArgsFlow)(confirm, state));
        }
        // Make sure all arguments in the argument list has request prompt
        state = (0, exports.validateRequestPromptInArgsList)(confirm, confirm.act, state);
    }
    return state.withError(...errors);
};
exports.validateConfirmArgsAct = validateConfirmArgsAct;
/**
 * The next api call after Confirm Args dialog act must be consistent with the action which is been confirmed.
 */
const validateConfirmArgsFlow = (confirm, state) => {
    var _a, _b, _c;
    let actionDeclaration = undefined;
    const args = (_a = confirm.act) === null || _a === void 0 ? void 0 : _a.getProperty("arguments");
    if (args === null || args === void 0 ? void 0 : args.isList()) {
        for (const arg of (_b = args.getItems()) !== null && _b !== void 0 ? _b : []) {
            const argItem = arg === null || arg === void 0 ? void 0 : arg.asArgument();
            if (!argItem) {
                continue;
            }
            actionDeclaration = argItem.getReferencedActionArgumentActionDeclaration();
            if (actionDeclaration) {
                break;
            }
        }
    }
    else if (args === null || args === void 0 ? void 0 : args.isUnion()) {
        // TODO: validate each variation of the arguments.
        // return state;
        throw new Error("should be impossible.");
    }
    if (actionDeclaration === undefined) {
        return [];
    }
    const actionName = (_c = actionDeclaration.name) === null || _c === void 0 ? void 0 : _c.name;
    const errorExpr = (0, error_factory_1.getExpressionIfLocField)(confirm.apply.getArgumentValue("act"), confirm);
    return confirm.flow
        .interpret((expr) => visit(expr, state), confirm)
        .map((state) => state.errors)
        .flat();
    function visit(expr, state, affirmed = false) {
        var _a;
        const { flow } = expr;
        const missingEventAfterConfirmArgsError = error_factory_1.ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgs({
            expr: errorExpr,
            attributes: {
                actionName,
            },
        });
        if (expr.isEnd()) {
            const missingApiError = error_factory_1.ValidationErrorFactory.MissingApiInvocationAfterConfirmArgs({
                expr: errorExpr,
                attributes: {
                    actionName,
                },
            });
            return affirmed ? state.withError(missingApiError) : state.withError(missingEventAfterConfirmArgsError, missingApiError);
        }
        if (expr.isAction()) {
            if (expr === null || expr === void 0 ? void 0 : expr.isInvokeApi()) {
                if (!affirmed) {
                    return state.withError(missingEventAfterConfirmArgsError, error_factory_1.ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgsBeforeCall({
                        expr,
                        attributes: {
                            calledActionName: (_a = expr.action) === null || _a === void 0 ? void 0 : _a.actionName,
                            confirmedActionName: actionName,
                        },
                    }));
                }
                if (confirm.payload) {
                    return validateConfirmPayload(state, confirm, expr);
                }
                return state;
            }
            if (expr.isExpect() && !affirmed) {
                const actType = expr.getActType();
                if ((actType === null || actType === void 0 ? void 0 : actType.isAffirm()) || (actType === null || actType === void 0 ? void 0 : actType.isDeny())) {
                    if (actType.isDeny()) {
                        return state;
                    }
                    return (next) => visit(next, state.pushExpr(expr), true);
                }
                if (actType) {
                    return state.withError(missingEventAfterConfirmArgsError, error_factory_1.ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgsBeforeExpect({
                        expr,
                        attributes: {
                            actionName,
                            requestAct: actType.toString(flow.expression),
                        },
                    }));
                }
            }
            else if (!affirmed && ((expr === null || expr === void 0 ? void 0 : expr.isResponse()) || (expr === null || expr === void 0 ? void 0 : expr.isConfirmAction()))) {
                return state.withError(error_factory_1.ValidationErrorFactory.MissingAffirmORDenyEventAfterConfirmArgs({
                    expr: confirm,
                    attributes: {
                        actionName,
                    },
                }));
            }
        }
        return (next) => visit(next, state.pushExpr(expr), affirmed);
    }
};
exports.validateConfirmArgsFlow = validateConfirmArgsFlow;
/**
 * Validate the arguments to an API match the payload in a previous ConfirmArgs or ConfirmAction act.
 */
function validateConfirmPayload(state, confirm, api) {
    var _a;
    const confirmedPayload = confirm.isResponse() || confirm.isConfirmAction() ? confirm.payload : undefined;
    const errors = Object.entries((_a = api.arguments) !== null && _a !== void 0 ? _a : {})
        .map(([name, arg]) => {
        var _a, _b, _c, _d;
        const actualArg = confirmedPayload === null || confirmedPayload === void 0 ? void 0 : confirmedPayload.getProperty(name);
        if (actualArg === undefined || actualArg.equals(arg)) {
            return [];
        }
        // return a pair of errors for the mis-matched argument
        return [
            error_factory_1.ValidationErrorFactory.MismatchedPayloadPropertyValueActionArgument({
                expr: (0, error_factory_1.getExpressionIfLocField)((_a = confirm.apply) === null || _a === void 0 ? void 0 : _a.getArgument("payload"), confirm),
                attributes: {
                    propertyName: name,
                    actionName: (_b = api.action) === null || _b === void 0 ? void 0 : _b.actionName,
                },
            }),
            error_factory_1.ValidationErrorFactory.MismatchedPayloadPropertyValuePreviouslyConfirmed({
                expr: (0, error_factory_1.getExpressionIfLocField)((_c = api.apply) === null || _c === void 0 ? void 0 : _c.getArgumentValue(name), arg),
                attributes: {
                    argumentName: name,
                    actionName: (_d = api.action) === null || _d === void 0 ? void 0 : _d.actionName,
                },
            }),
        ];
    })
        .reduce((a, b) => a.concat(b), []);
    return state.withError(...errors);
}
/**
 * Validate ensure action used in dialog sample
 * traverse the requestArgs list and do the following validations
 * 1. Make sure each response contain APL-A
 * 2. Make sure each all arguments in the argument list refer to the same action
 * 3. When the arguments list of RequestArguments contains multiple args, make sure each arg has request prompt
 */
const evaluateEnsure = (ensure, state) => {
    var _a, _b;
    if (ensure.node === undefined) {
        return state;
    }
    const errors = [];
    state = state.withRequestedArguments(true, ...ensure.getIndividuallyRequestedArguments());
    // const requestArgsNode = ensure.requestArgs.origin;
    if (((_a = ensure.requestArgs) === null || _a === void 0 ? void 0 : _a.isList()) && ensure.requestArgs.isLiteral()) {
        for (const requestArg of (_b = ensure.requestArgs.getItems()) !== null && _b !== void 0 ? _b : []) {
            const args = requestArg === null || requestArg === void 0 ? void 0 : requestArg.getProperty("arguments");
            errors.push(...validateArgumentListThing(args, args === null || args === void 0 ? void 0 : args.origin));
            if (requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) {
                errors.push(...(0, exports.validatePrompt)(requestArg.apply));
            }
            if (requestArg === null || requestArg === void 0 ? void 0 : requestArg.apply) {
                state = (0, exports.validateRequestPromptInArgsList)(ensure, requestArg, state);
            }
        }
    }
    return state.withError(...errors);
};
exports.evaluateEnsure = evaluateEnsure;
/**
 * Validations of the List<Argument<Thing>> type
 * the items in the "arguments" list should be from the same Action
 * @param value
 * @param branch
 */
function validateArgumentList(value, valueThing) {
    return validateArgumentListThing(valueThing, value);
}
exports.validateArgumentList = validateArgumentList;
function validateArgumentListThing(list, expr) {
    var _a, _b;
    const parseErrors = [];
    if (list === undefined) {
        return parseErrors;
    }
    else if (list.isUnion()) {
        return list.things.map((t) => validateArgumentListThing(t, expr)).reduce((a, b) => a.concat(b), []);
    }
    else if ((list === null || list === void 0 ? void 0 : list.isLiteral()) && list.isList()) {
        const actionNamesSet = new Set();
        const items = (_a = list.getItems()) !== null && _a !== void 0 ? _a : [];
        if (items.length === 0) {
            parseErrors.push(error_factory_1.ValidationErrorFactory.ExpectedNonEmptyArgumentList({ expr }));
            return parseErrors;
        }
        for (const itemThing of (_b = list.getItems()) !== null && _b !== void 0 ? _b : []) {
            if (itemThing === undefined) {
                // This will happen when referring to the arguments of a reusable dialog:
                //    ensure(RequestArguments {arguments = [saveRating.arguments.arg0], response = feedback_prompt})
                // saveRating is an argument to the reusable dialog:
                //    dialog Nothing GetFeedback(Action1<Number, Nothing> saveRating)
                // For this case, currently skipping the validations for argument reference and type below
                continue;
            }
            if (!itemThing.isArgument()) {
                continue;
            }
            const argumentInformation = itemThing.getReferencedActionArgumentTypeInformation();
            if (!argumentInformation || !argumentInformation.actionName) {
                parseErrors.push(error_factory_1.ValidationErrorFactory.ArgumentMustReferToActionArgument({
                    expr: { loc: itemThing === null || itemThing === void 0 ? void 0 : itemThing.loc, uri: expr === null || expr === void 0 ? void 0 : expr.uri },
                    attributes: { argumentName: itemThing.argumentName },
                }));
            }
            else {
                actionNamesSet.add(argumentInformation.actionName);
                if (argumentInformation.type && !argumentInformation.type.isValidForUtterance()) {
                    parseErrors.push(error_factory_1.ValidationErrorFactory.ArgumentMustReferToActionArgumentWithUtteranceType({
                        expr: { loc: itemThing === null || itemThing === void 0 ? void 0 : itemThing.loc, uri: expr === null || expr === void 0 ? void 0 : expr.uri },
                        attributes: { argumentName: itemThing.argumentName, typeName: argumentInformation.type.toString() },
                    }));
                }
            }
        }
        if (actionNamesSet.size > 1) {
            const actionNames = Array.from(actionNamesSet.values())
                .map((n) => "'" + n + "'")
                .join(", ");
            return [
                error_factory_1.ValidationErrorFactory.MismatchedActionArgumentsList({
                    expr,
                    attributes: {
                        actionNames: actionNames,
                    },
                }),
            ];
        }
    }
    return parseErrors;
}
exports.validateArgumentListThing = validateArgumentListThing;
/**
 * Validate response argument in response, confirmAction, ensure and confirmArgs actions
 * The type of response should be APL-A
 *
 * Right now the type validation won't check response type cause the response type could be anything
 */
const validatePrompt = (apply) => {
    var _a, _b, _c;
    const errors = [];
    const promptNode = apply.getArgumentValue("response");
    const prompt = apply.getArgumentValueThing("response");
    if (prompt !== undefined) {
        if (((_a = prompt.type) === null || _a === void 0 ? void 0 : _a.isApla()) || ((_b = prompt.type) === null || _b === void 0 ? void 0 : _b.isMultiModalResponse())) {
            // APLA and MultiModalResponse are valid prompt
            // TODO: we should probably check if the APLA property is set, right?
        }
        else {
            errors.push(error_factory_1.ValidationErrorFactory.MissingAplaInResponse({
                expr: promptNode,
                attributes: {
                    type: (_c = prompt.type) === null || _c === void 0 ? void 0 : _c.toString(promptNode),
                },
            }));
        }
    }
    return errors;
};
exports.validatePrompt = validatePrompt;
const validateRequestPromptInArgsList = (expr, act, state) => {
    var _a, _b, _c, _d;
    if (act === undefined) {
        return state;
    }
    if (act.isUnion()) {
        // return args.things.map((thing) => validateRequestPromptInArgsList(thing, state)).reduce((a, b) => a.concat(b), []);
        throw new Error("this should be impossible.");
    }
    else if (expr.isConfirmArgs() || act.type.isRequest() || act.type.isRequestArguments() || act.type.isConfirmArgs()) {
        const args = (_c = (_b = (_a = act.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValueThing("arguments")) === null || _b === void 0 ? void 0 : _b.asLiteralList()) === null || _c === void 0 ? void 0 : _c.getItems();
        if (args && args.length > 1) {
            for (const arg of args) {
                const argName = (_d = arg === null || arg === void 0 ? void 0 : arg.origin) === null || _d === void 0 ? void 0 : _d.name;
                if ((arg === null || arg === void 0 ? void 0 : arg.isArgument()) && argName !== undefined) {
                    if ((expr.isResponse() || expr.isEnsure() || expr.isConfirmArgs()) && !state.isArgumentRequested(arg)) {
                        state = state.withPendingRequestPromptValidation(expr, arg);
                    }
                }
            }
        }
    }
    return state;
};
exports.validateRequestPromptInArgsList = validateRequestPromptInArgsList;
/**
 * Validate the user Defined api call inside dialog sample
 * 1. make sure the argument is api result or event result
 * 2. make sure the required argument has Request Prompt
 * 3. make sure the argument(event result) has not been reset
 */
const evaluateInvokeApi = (api, state) => {
    var _a;
    if (api.node === undefined) {
        return state;
    }
    const actionName = (_a = api.action) === null || _a === void 0 ? void 0 : _a.actionName;
    const errors = [...validateLoadContextIsCalledOnce(), ...validateArguments(), ...validateOfferedApiInvocation()];
    return state.withError(...errors).clearPendingOffer();
    function validateArguments() {
        var _a, _b, _c, _d;
        return ((_d = (_c = (_b = (_a = api.action) === null || _a === void 0 ? void 0 : _a.getArguments()) === null || _b === void 0 ? void 0 : _b.getArgumentsList()) === null || _c === void 0 ? void 0 : _c.map((arg) => {
            const argValueNode = api.apply.getArgumentValue(arg);
            const argValue = api.apply.getArgumentValueThing(arg);
            if (argValue !== undefined) {
                return validateArgValue(argValueNode, argValue, arg);
            }
            return [];
        }).reduce((a, b) => a.concat(b), [])) !== null && _d !== void 0 ? _d : []);
    }
    function validateOfferedApiInvocation() {
        var _a, _b;
        const invokedAction = (_b = (_a = api.apply) === null || _a === void 0 ? void 0 : _a.decl.name) === null || _b === void 0 ? void 0 : _b.name;
        if (state.pendingOffer && state.pendingOffer != invokedAction) {
            return [
                error_factory_1.ValidationErrorFactory.InvokedActionNotOffered({
                    expr: api,
                    attributes: {
                        offeredAction: state.pendingOffer,
                        invokedAction: invokedAction,
                    },
                }),
            ];
        }
        return [];
    }
    /**
     * validate argument value
     * 1. make sure the argument value is api result or event result
     * 2. when the argValue is event result, make sure it has request prompt
     * @param argValue the argument value
     * @param argDecl the declaration of the argument, we could know the argument name, type and whether the argument is optional based on it
     * @returns
     */
    function validateArgValue(argValue, argValueThing, argDecl) {
        var _a, _b;
        const argDeclType = argDecl.type.getArgumentType();
        const invalidApiArgumentError = error_factory_1.ValidationErrorFactory.InvalidApiArgument({
            expr: argValue,
        });
        if (argValueThing === undefined || argValueThing.isNothing()) {
            return [];
        }
        if (argValueThing.isLiteral()) {
            if (argValueThing.isList()) {
                return ((_b = (_a = argValueThing
                    .getItems()) === null || _a === void 0 ? void 0 : _a.map(validateArgValueThing).reduce((a, b) => a.concat(b), [])) !== null && _b !== void 0 ? _b : []);
            }
            else {
                return [];
            }
            return [invalidApiArgumentError];
        }
        return validateArgValueThing(argValueThing);
        function validateArgValueThing(argValueThing) {
            var _a;
            const origin = getOriginType(argValueThing);
            if (argValueThing === undefined || argValueThing.isNothing()) {
                return [];
            }
            if (argValueThing.isUnion()) {
                return argValueThing.things.map(validateArgValueThing).reduce((a, b) => a.concat(b), []);
            }
            if (argValueThing.parent === undefined) {
                // if we're directly referencing a value, it must be an API cal
                if (isFromOrigin(origin, "api") === false) {
                    return [invalidApiArgumentError];
                }
            }
            else if (isFromOrigin(origin, "event", "api") === false) {
                // if we're indexing an object, it can be from an event or an API call.
                return [invalidApiArgumentError];
            }
            if (isFromOrigin(origin, "event")) {
                if (!state.isArgumentRequested(argDecl, argValueThing)) {
                    if (!((argDeclType === null || argDeclType === void 0 ? void 0 : argDeclType.isOptional()) || (argDeclType === null || argDeclType === void 0 ? void 0 : argDeclType.isArgs()))) {
                        // if this is a required argument and it has not been requested in this dialog flow, we must keep track of it
                        // and only error if we don't find an `ensure` block later in the dialog flow.
                        // const arg = api.action?.getArgument(argDecl);
                        state = state.withPendingRequestPromptValidation(api, argDecl);
                    }
                }
            }
            // Both the eventResult and apiResult follow the same reset rule
            if (api.flow.isArgumentReset(argValueThing, api.apply.decl)) {
                const argumentName = (argValue === null || argValue === void 0 ? void 0 : argValue.kind) === "PropertyReference" ? argValue.printPropertyChainThroughRoot() : (_a = argValue === null || argValue === void 0 ? void 0 : argValue.name) === null || _a === void 0 ? void 0 : _a.name;
                return [
                    error_factory_1.ValidationErrorFactory.ResetArgument({
                        expr: argValue,
                        attributes: {
                            argumentName,
                        },
                    }),
                ];
            }
            return [];
        }
    }
    /**
     * A call to the configured loadContext action must be called at most once per dialog sample.
     *
     * @see https://github.com/alexa/ask-ac/issues/225
     */
    function validateLoadContextIsCalledOnce() {
        var _a, _b, _c;
        if (actionName && ((_c = (_b = (_a = state.skillContext) === null || _a === void 0 ? void 0 : _a.loadContext) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.name) === actionName) {
            return api.flow.visitPrevious(function walk(flow) {
                var _a;
                if ((flow === null || flow === void 0 ? void 0 : flow.expression) === undefined) {
                    return [];
                }
                if (((_a = flow === null || flow === void 0 ? void 0 : flow.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call") {
                    const apply = flow.checker.getApply(flow.expression);
                    if (apply === null || apply === void 0 ? void 0 : apply.isUserDefinedApi()) {
                        const thisName = apply === null || apply === void 0 ? void 0 : apply.getName();
                        if (thisName) {
                            if (thisName === actionName) {
                                return [
                                    error_factory_1.ValidationErrorFactory.InvalidLoadContextMultipleCall({
                                        expr: api,
                                        attributes: {
                                            actionName,
                                        },
                                    }),
                                ];
                            }
                            return [
                                error_factory_1.ValidationErrorFactory.InvalidLoadContextNotFirstCall({
                                    expr: api,
                                    attributes: {
                                        actionName,
                                    },
                                }),
                            ];
                        }
                    }
                }
                return flow.visitPrevious(walk);
            });
        }
        return [];
    }
};
exports.evaluateInvokeApi = evaluateInvokeApi;
/**
 * Validate payload argument in response and confirmAction action
 *
 * 1. the expression assigned to payload is either null, Thing, or an ObjectLiteral
 * 2. the value assigned to payload property can only be a name directly referring to an api result or a type used in an event
 * 3. validate payload against next api call
 *
 * The Simulator can only understand payload values to be either a slot in the event or the return value of an api invocation
 */
const validatePayload = (response, state) => {
    var _a;
    if (response.payload === undefined) {
        return [];
    }
    const errors = [];
    const expr = (0, error_factory_1.getExpressionIfLocField)((_a = response.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("payload"), response);
    validatePayloadThing(response.payload);
    return errors;
    function validatePayloadThing(payload) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (payload.isUnion()) {
            throw new Error("this should be impossible.");
            // payload.things.forEach(validatePayloadThing);
        }
        else if (payload.isPrimitive()) {
            if (payload.isLiteral() && (payload.isVoid() || payload.isNothing())) {
                // null and nothing literals are allowed.
            }
            else {
                // TODO: i need to properly handle Optional -> which is AnyThing right now
                errors.push(error_factory_1.ValidationErrorFactory.InvalidPayloadType({
                    expr,
                }));
            }
        }
        else if (!payload.isLiteral()) {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidPayloadType({
                expr,
            }));
        }
        else {
            // now we have an object literal `{ prop = value }`
            Object.entries((_a = payload.getProperties()) !== null && _a !== void 0 ? _a : {}).forEach(([name, propThing]) => {
                if (propThing !== undefined) {
                    const origin = getOriginType(propThing);
                    if (propThing.parent === undefined) {
                        // if we're directly referencing a value, it must be an API cal
                        if (isFromOrigin(origin, "api") === false) {
                            errors.push(error_factory_1.ValidationErrorFactory.InvalidPayloadPropertyValue({
                                expr,
                            }));
                        }
                    }
                    else if (isFromOrigin(origin, "event", "api") === false) {
                        // if we're indexing an object, it can be from an event or an API call.
                        errors.push(error_factory_1.ValidationErrorFactory.InvalidPayloadPropertyValue({
                            expr,
                        }));
                    }
                }
            });
        }
        // payload type should be consistent with response type
        if (((_c = (_b = response.response) === null || _b === void 0 ? void 0 : _b.type) === null || _c === void 0 ? void 0 : _c.genericArguments) && ((_e = (_d = response.response) === null || _d === void 0 ? void 0 : _d.type) === null || _e === void 0 ? void 0 : _e.genericArguments.length) > 0) {
            const responseGenericType = (_g = (_f = response.response) === null || _f === void 0 ? void 0 : _f.type) === null || _g === void 0 ? void 0 : _g.genericArguments[0];
            if (responseGenericType !== undefined && !payload.type.extends(responseGenericType)) {
                errors.push((0, error_1.typeError)(payload.type, responseGenericType, response.node, (0, error_factory_1.getExpressionIfLocField)((_h = response.apply) === null || _h === void 0 ? void 0 : _h.getArgumentValue("payload"), response)));
            }
        }
    }
};
exports.validatePayload = validatePayload;
function isFromOrigin(actualOrigin, ...expectedOrigin) {
    const allowedOrigins = new Set(expectedOrigin);
    if (actualOrigin === undefined) {
        return undefined;
    }
    if (typeof actualOrigin === "string") {
        return allowedOrigins.has(actualOrigin);
    }
    let accum = true;
    for (const o of actualOrigin) {
        if (o === undefined) {
            return undefined;
        }
        accum = allowedOrigins.has(o) && accum;
    }
    return accum;
}
function getOriginType(thing) {
    var _a;
    if (thing === undefined) {
        return undefined;
    }
    if (thing.parent !== undefined) {
        // a thing is from an API call or an Event if the root is from an API or expect event
        return getOriginType(thing.parent);
    }
    if (thing.isLiteral()) {
        return "literal";
    }
    if (thing.isUnion()) {
        return thing.things
            .map((t) => getOriginType(t))
            .reduce((a, b) => {
            if (Array.isArray(a) && Array.isArray(b)) {
                return a.concat(b);
            }
            if (Array.isArray(a)) {
                return [...a, b];
            }
            if (Array.isArray(b)) {
                return [a, ...b];
            }
            return [a, b];
        }, []);
    }
    if (((_a = thing.origin) === null || _a === void 0 ? void 0 : _a.kind) === "ArgumentDeclaration") {
        // origin is an argument declaration, this relies on re-usable dialog expansion logic ....
        // for now, return false?
        return "argument";
    }
    const { apply } = thing;
    if (apply === undefined) {
        return undefined;
    }
    if (apply.isExpect()) {
        return "event";
    }
    if (apply.isUserDefinedApi()) {
        return "api";
    }
    if (apply.isOperator()) {
        return "operator";
    }
    if (apply.isNativeAction()) {
        return "native";
    }
    if (apply.isBuiltin()) {
        return "built-in";
    }
    return undefined;
}
function validateGlobalWelcome(project, checker) {
    const welcomeCalls = project.modules
        .map((module) => {
        var _a, _b, _c;
        return (_c = (_b = (_a = module.content) === null || _a === void 0 ? void 0 : _a.expressions) === null || _b === void 0 ? void 0 : _b.map((expr) => {
            var _a;
            if (expr.kind === "Call" || (expr.kind === "NameDeclaration" && ((_a = expr.expression) === null || _a === void 0 ? void 0 : _a.kind) === "Call")) {
                const apply = checker.getApply(expr.kind === "Call" ? expr : expr.expression);
                if (apply === null || apply === void 0 ? void 0 : apply.isWelcome()) {
                    return [expr];
                }
            }
            return [];
        }).reduce((a, b) => a.concat(b), [])) !== null && _c !== void 0 ? _c : [];
    })
        .reduce((a, b) => a.concat(b), []);
    if (welcomeCalls.length > 1) {
        return welcomeCalls.map((welcome) => error_factory_1.ValidationErrorFactory.TooManyWelcomeCalls({
            expr: welcome,
            attributes: {
                welcomeCallCount: welcomeCalls.length,
            },
        }));
    }
    return [];
}
exports.validateGlobalWelcome = validateGlobalWelcome;
/**
 * validate all required prompts are exist in current skill
 */
function validateSkillLevelResponses(project) {
    var _a;
    const errors = [];
    const promptsNameSet = new Set();
    // Check if required prompts exist in current skill
    (_a = project.responseTemplates) === null || _a === void 0 ? void 0 : _a.forEach((prompt) => {
        if (prompt.isPrompt()) {
            promptsNameSet.add(prompt.name);
        }
    });
    Object.values(ask.AlexaConversationPrompts).forEach((requiredPrompt) => {
        if (!promptsNameSet.has(requiredPrompt)) {
            errors.push(error_factory_1.ValidationErrorFactory.MissingRequiredPrompts({
                attributes: {
                    promptName: requiredPrompt,
                },
            }));
        }
    });
    return errors;
}
exports.validateSkillLevelResponses = validateSkillLevelResponses;
/**
 * Verify the expect of Invoke event exists by recursively calling the @function doesSampleStartWithInvoke
 *
 * E.G. Below is a valid example, as it has expect with Invoke event:
 * dialog void A {
 *   sample {
 *     expect(Invoke, invocationUtterances)
 *     // ... conversation flow's logic
 *     response(APLA {}, Bye {})
 *   }
 * }
 *
 * It makes sure all the branches have an Invoke event if conditional branches exist.
 * E.G. The dialog below is not a valid one as it misses Invoke in one condition branch:
 * dialog void B {
 *   sample {
 *     if (some_condition) {
 *       expect(RequestAlt, invocationUtterances)
 *     } else {
 *       expect(Invoke, invocationUtterances)
 *     }
 *     response(APLA {}, Bye {})
 *   }
 * }
 *
 * @param sample sample node to validate through the expressions to find Invoke event
 * @param flow type checker
 * @returns
 */
const validateSampleStartWithInvoke = (flow, state) => {
    const sample = flow.expression;
    const dialogDecl = sample.context;
    return flow
        .interpret((expr) => visit(expr, state), undefined)
        .map((state) => state.errors)
        .flat();
    function visit(expr, state) {
        var _a, _b, _c;
        if (expr.isEnd()) {
            // if we reach the end then don't report any error - the sample will be flagged as not having an expressions.
            return state;
        }
        if (expr.isDialogExpansion()) {
            // skip dialog expansion (treat it as transient).
            return (next) => visit(next, state);
        }
        if (expr.isExpect()) {
            if (expr.isInvoke()) {
                return state;
            }
            // TODO: specialize error message for the wrong act typ
            // TODO: is the origin location a bad idea?
            return state.withError(error_factory_1.ValidationErrorFactory.MissingExpectInvokeEvent({
                expr: (0, error_factory_1.getExpressionIfLocField)((_a = expr.apply) === null || _a === void 0 ? void 0 : _a.getArgumentValue("act"), expr, sample),
                attributes: {
                    dialogName: (_b = dialogDecl.name) === null || _b === void 0 ? void 0 : _b.name,
                },
            }));
        }
        if (expr.isEnsure() || expr.isConditionalBranch() || expr.isDialogExpansion() || expr.isBlock()) {
            // these blocks don't count as evaluated actions, so we  move to the next expressions
            // return expr.flow.interpret(state, EvaluationState.combine, evaluate);
            return (next) => visit(next, state.pushExpr(expr));
        }
        return state.withError(error_factory_1.ValidationErrorFactory.MissingExpectInvokeEvent({
            expr: (0, error_factory_1.getExpressionIfLocField)(expr, sample),
            attributes: {
                dialogName: (_c = dialogDecl.name) === null || _c === void 0 ? void 0 : _c.name,
            },
        }));
    }
};
exports.validateSampleStartWithInvoke = validateSampleStartWithInvoke;
/**
 * Returns true if conditionExpressionThing or its root parent is from the last API/from expect
 * or an operator/native action with at least one argument that is from the last API/from expect.
 * This will recursevely follow conditionExpressionThing.parent to find the root parent. Once there
 * returns true if it is either:
 *   1) the last user defined API or
 *   2) an event out of an expect call or
 *   3) an operator or native action where at least one argument is 1) or 2)
 * @param conditionExpressionThing condition expression thing
 * @param lastApiName name of the last user defined API called
 * @returns true if conditionExpressionThing or its root parent is from the last API/from expect
 * or an operator/native action with at least one argument that is from the last API/from expect.
 */
const isConditionExpressionFromLastApiOrFromExpect = (conditionExpressionThing, lastApiName) => {
    if (conditionExpressionThing === undefined) {
        return false;
    }
    if (conditionExpressionThing.parent !== undefined) {
        return isConditionExpressionFromLastApiOrFromExpect(conditionExpressionThing.parent, lastApiName);
    }
    if (!conditionExpressionThing.apply) {
        return false;
    }
    if (conditionExpressionThing.apply.isExpect()) {
        return true;
    }
    if (conditionExpressionThing.apply.isUserDefinedApi()) {
        return conditionExpressionThing.apply.getName() === lastApiName;
    }
    if (conditionExpressionThing.apply.isOperator() || conditionExpressionThing.apply.isNativeAction()) {
        for (const arg in conditionExpressionThing.apply.getArguments()) {
            const argThing = conditionExpressionThing.apply.getArgumentValueThing(arg);
            if (!argThing || isConditionExpressionFromLastApiOrFromExpect(argThing, lastApiName)) {
                return true;
            }
        }
    }
    return false;
};
/**
 * This function validates Condition.when for the following checkpoints:
 * 2. validate the when condition contains any data from the last API invocation call
 * 3. validate then when expression to have a boolean return type
 *
 * @param cond Condition.when Call | NameReference
 * @param condition type checker for querying the expressions
 * @returns type Validator<T>
 */
const evaluateConditionalBranch = (condition, state) => {
    var _a, _b;
    state = state.withError(...validateFirstExpressionInCondition());
    const { when } = condition.flow.expression;
    if ((when === null || when === void 0 ? void 0 : when.expression) === undefined) {
        return state;
    }
    if (!isConditionExpressionFromLastApiOrFromExpect(condition.expr, (_b = (_a = state.previousApi) === null || _a === void 0 ? void 0 : _a.apply) === null || _b === void 0 ? void 0 : _b.getName())) {
        return state.withError(error_factory_1.ValidationErrorFactory.ConditionWhenMustCompareApiResponse({
            expr: (0, error_factory_1.getExpressionIfLocField)(when, when.context),
        }));
    }
    return state;
    // check that the first expression in each conditional block is another ConditionalBranch, API invocation, Notify Response or Confirm Action
    function validateFirstExpressionInCondition() {
        return condition.flow
            .interpret(function visit(expr, block) {
            var _a;
            if (expr.isEnd() || !isInCondition(expr)) {
                // This Expression does not exist within the ConditionalBranch, so let the "a condition must contain at least one expression" validator catch this.
                return [
                    error_factory_1.ValidationErrorFactory.ExprRequiredInConditionBlock({
                        expr: (0, error_factory_1.getExpressionIfLocField)(block, condition),
                    }),
                ];
            }
            if (expr.isConditionalBranch()) {
                // if the next expression is a Conditional, it's valid
                return [];
            }
            if (expr.isBlock() && block === undefined) {
                // this is the first block encountered after the Conditional Branch, we should use this as the location of the errors.
                return (next) => visit(next, expr);
            }
            if (expr.isDialogExpansion() || expr.isEnsure() || expr.isConfirmArgs() || expr.isBlock()) {
                // if we encounter another conditional branch, dialog expansion or an ambient expression such as ensure or confirmArgs - continue evaluating the dialog flow
                return (expr) => visit(expr, block);
            }
            if (expr.isInvokeApi()) {
                // we allow API invocations and ConfirmAction
                // TODO: need to confirm whether ConfirmAction is allowed in a Conditional Branch. I can't remember why ... it doesn't seem to align with requirements?
                return [];
            }
            if (expr.isResponse()) {
                if (((_a = expr.act) === null || _a === void 0 ? void 0 : _a.type.isNotify()) === false) {
                    return [
                        error_factory_1.ValidationErrorFactory.InvalidFirstResponseInConditionBlock({
                            expr: (0, error_factory_1.getExpressionIfLocField)(expr.actNode, expr),
                        }),
                    ];
                }
                // Notify Response is valid, no error.
                return [];
            }
            return [
                error_factory_1.ValidationErrorFactory.InvalidFirstExprInConditionBlock({
                    expr,
                }),
            ];
        }, condition)
            .flat();
    }
    /**
     * HACK: Check if this Expression is directly in the context of the ConditionalBranch being expanded.
     *
     * We need this hack because of a short-coming of interpret (ugh!) - we don't know when an Expression
     * in the Stream originated from within a Condition or outside, making this validation difficult.
     */
    function isInCondition(expr) {
        if (expr.flow.stack.length === 0) {
            return false;
        }
        for (const prevExpr of expr.flow.stack) {
            if (prevExpr.kind === "Condition") {
                return prevExpr === condition.flow.expression;
            }
        }
        return false;
    }
};
exports.evaluateConditionalBranch = evaluateConditionalBranch;
/**
 * Returns true if the flow originated from a dialog call.
 */
function isFlowFromDialogCall(flow) {
    if ((flow === null || flow === void 0 ? void 0 : flow.stack.length) !== 1) {
        return false;
    }
    const stackNode = flow.stack[0];
    if ((stackNode === null || stackNode === void 0 ? void 0 : stackNode.kind) === "Call") {
        const apply = flow.checker.getApply(stackNode);
        return apply === null || apply === void 0 ? void 0 : apply.isDialog();
    }
    return false;
}
/**
 * Validates if response calls with 'Request' request acts are called consecutively
 */
const validatePriorResponseCall = (response) => {
    var _a, _b, _c, _d;
    const errors = [];
    if ((_a = response.prev) === null || _a === void 0 ? void 0 : _a.isResponse()) {
        const reqAct = response.apply.getArgumentValue("act");
        const prevReqAct = response.prev.apply.getArgumentValue("act");
        if (((_b = reqAct === null || reqAct === void 0 ? void 0 : reqAct.name) === null || _b === void 0 ? void 0 : _b.name) === ((_c = prevReqAct === null || prevReqAct === void 0 ? void 0 : prevReqAct.name) === null || _c === void 0 ? void 0 : _c.name) && ((_d = prevReqAct === null || prevReqAct === void 0 ? void 0 : prevReqAct.name) === null || _d === void 0 ? void 0 : _d.name) === "Request") {
            errors.push(error_factory_1.ValidationErrorFactory.InvalidEventInform({
                expr: response,
                attributes: {
                    requestAct: "Inform",
                },
            }));
        }
    }
    return errors;
};
exports.validatePriorResponseCall = validatePriorResponseCall;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZhbHVhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZXZhbHVhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBNkI7QUFJN0IsK0JBQTREO0FBRTVELG1DQUE0RDtBQWtCNUQsbURBQTZIO0FBUTdIOztHQUVHO0FBQ0gsU0FBZ0Isa0JBQWtCLENBQUMsSUFBaUMsRUFBRSxLQUFzQjtJQUMxRixtREFBbUQ7O0lBRW5ELE9BQU87UUFDTCxZQUFZLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUN0RCxNQUFBLE1BQUEsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLDBDQUFFLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsSUFBQSxxQ0FBNkIsRUFBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLG1DQUFJLEVBQUU7S0FDeEcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDWixDQUFDO0FBUEQsZ0RBT0M7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixZQUFZLENBQUMsSUFBVSxFQUFFLEtBQXNCO0lBQzdELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLFFBQVEsQ0FBQyxJQUFJLEVBQUUsU0FBUyxHQUFHLEtBQUs7UUFDN0QsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDaEIsT0FBTyxXQUFXLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNwRDtRQUNELFNBQVMsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9ELElBQUks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